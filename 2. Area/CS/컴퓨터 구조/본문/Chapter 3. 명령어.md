1. 소스 코드와 명령어
    - 고급 언어와 저급 언어
        - 고급 언어 : 사람을 위한 프로그래밍 언어
        - 저급 언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어
            - 기계어 - 0과 1의 명령어 비트로 이루어진 언어
            - 어셈블리어 - 기계어를 읽기 편한 형태로 번역한 언어
    - 컴파일 언어와 인터프리터 언어
        - 컴파일 언어
            - 컴파일러가 소스 코드 전체를 저급 언어로 변환해 실행하는 고급 언어
            - 컴파일 ⇒ 전체 소스 코드가 저급 언어로 변환되는 과정
            - 목적 코드 ⇒ 컴파일러를 통해 저급 언어로 변환된 코드
        - 인터프리트 언어
            - 인터프리터가 소스 코드를 한 줄씩 실행하는 고급 언어
            - 인터프리터 ⇒ 소스 코드가 한 줄씩 저급 언어로 변환되도록 실행해주는 도구
        - 목적 파일 vs 실행 파일
            - 목적 파일 ⇒ 목적 코드로 이루어진 파일
            - 실행 파일 ⇒ 실행 코드로 이루어진 파일
            - 링킹 ⇒ 목적 코드가 실행 파일이 되기 위환 작업
2. 명령어의 구조
    - 명령어의 구조
        - **무엇**을 대상으로, 어떤 **작동을 수행**하는 구조
        - 연산 코드(operation code) : 명령어가 수행할 연산
        - 오퍼랜드(operand) : 연산에 사용할 데이터 & 연산에 사용할 데이터가 저장된 위치
        - 연산 코드⇒ 연산자 | 오퍼랜드 ⇒ 피연산자
        - 연산 코드 필드 : 연산 코드가 담기는 영역
        - 오퍼랜드 필드 : 오퍼랜드가 담기는 영역
    - 오퍼랜드
        - 오퍼랜드 필드에는 데이터 또는 메모리나 레지스터 주소가 올 수 있음
        - 주소 필드
        - 오퍼랜드 개수에 따라 0-주소 명령어,1-주소 명령어~ 3-주소 명령어
    - 연산 코드
        - 연산 코드 유형
            - 데이터 전송
                - Move : 데이터를 옮겨라
                - Store : 메모리에 저장하라
                - Load(fetch) : 메모리에서 CPU로 데이터를 가져와라
                - Push : 스택에 데이터를 저장하라
                - Pop : 스택의 최상단 데이터를 가져와라
            - 산술|논리 연산
                - Add|subtract|multiply|divide : 덧셈|뺄셈|곱셈|나눗셈을 수행하라
                - Increment|decrement : 오퍼랜드에 1을 더하라 | 1을 빼라
                - And|or|not : and | or | not 연산을 수행하라
                - Compare : 두 개의 숫자 또는 True|False 값을 비교하라
            - 제어 흐름 변경
                - Jump : 특정 주소로 실행 순서를 옮겨라
                - Conditional jump : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
                - Halt : 프로그램의 실행을 멈춰라
                - Call : 되돌아올 주소를 저장한 책 특정 주소로 실행 순서를 옮겨라
                - Return : call을 호출할 때 저장했던 주소로 돌아가라
            - 입출력 제어
                - Read(input) : 특정 입출력 장치로부터 데이터를 읽어라
                - Write(output) : 특정 입출력 장치로 데이터를 써라
                - Start IO : 입출력 장치를 시작하라
                - Test IO : 입출력 장치의 상태를 확인하라
        - 주소 지정 방식
            - 오퍼랜드에 메모리나 레지스터 주소를 담을 경우 표현할 수 있는 정보의 가짓수가 커진다(96P)
            - 유효 주소 : 연산의 대상인 데치터가 저장된 위치
            - 주소 지정 방식 : 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
            - 즉시 주소 지정 방식(immediate addressing mode) : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식 ⇒ 데이터의 크기가 작아지는 단점 | 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없어 다른 주소 지정 방식에 비해 빠름
            - 직접 주소 지정 방식(direct addressing mode) : 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식 ⇒ 즉시 주소 지정 방식보다 데이터는 크지만 유효 주소의 표현 범위가 연산 코드의 비트 수 만큼 감소 ⇒ 유효 주소에 제한 발생 가능성이 있음
            - 간접 주소 지정 방식(indirect addressing mode) : 유효 주소의 주소를 오퍼랜드 필드에 명시 ⇒ 유효 주소의 범위는 넓지만 두 번의 메모리 접근으로 다른 주소 지정 방식들에 비해 느림
            - 레지스터 주소 지정 방식(register addressing mode) : 직접 주소 지정 방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법⇒ 레지스터는 cpu보다 빨라 빠르게 데이터에 접근할 수 있지만 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음
            - 레지스터 간접 주소 지정 방식(register indirect addressing mode) : 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법 ⇒ 유효 주소흘 찾는 과정은 간접 주소 지정 방식과 유사하나, 메모리에 접근하는 횟수가 한 번으로 줄어듦