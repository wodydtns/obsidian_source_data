# 이진 인덱스 트리 (Binary Indexed Tree)

**이진 인덱스 트리(Binary Indexed Tree, BIT)**는 효율적으로 누적 합을 계산하고 업데이트할 수 있는 자료구조입니다. 주로 배열의 구간 합을 빠르게 계산하거나 특정 인덱스의 값을 빈번하게 업데이트해야 할 때 사용됩니다. 이진 인덱스 트리는 간단한 구현과 효율적인 성능으로 인해 많은 알고리즘 문제에서 활용됩니다.

## 목차
- [개념](#개념)
- [특징](#특징)
- [기본 연산](#기본-연산)
  - [업데이트(Update)](#업데이트update)
  - [쿼리(Query)](#쿼리query)
- [자바 구현 예제](#자바-구현-예제)
- [시간 복잡도](#시간-복잡도)
- [응용 분야](#응용-분야)
- [예제 문제](#예제-문제)
- [결론](#결론)

## 개념

이진 인덱스 트리는 **트리 기반의 자료구조**로, 주로 배열의 **누적 합**을 효율적으로 계산하고 업데이트하기 위해 사용됩니다. BIT는 배열을 1부터 시작하는 인덱스를 사용하여 구현되며, 각 노드는 특정 구간의 합을 저장합니다.

### 기본 아이디어

- **누적 합 계산**: BIT는 배열의 특정 인덱스까지의 누적 합을 빠르게 계산할 수 있습니다.
- **효율적인 업데이트**: 배열의 특정 인덱스 값을 변경할 때, BIT는 최소한의 연산으로 해당 변경을 반영할 수 있습니다.

## 특징

- **공간 복잡도**: O(n)
- **업데이트 및 쿼리 시간 복잡도**: O(log n)
- **단순한 구현**: 배열을 기반으로 간단하게 구현할 수 있습니다.
- **부분 합 및 누적 합 처리에 최적화**: 특정 범위의 합을 빠르게 계산할 수 있습니다.

## 기본 연산

이진 인덱스 트리에서 주로 사용하는 두 가지 기본 연산은 **업데이트(Update)**와 **쿼리(Query)**입니다.

### 업데이트(Update)

배열의 특정 인덱스에 값을 추가하거나 변경할 때, BIT를 업데이트하는 과정입니다.

**업데이트 알고리즘:**

1. 업데이트할 인덱스를 `i`라 하고, 추가할 값을 `val`이라 합시다.
2. BIT 배열의 `i`번째 위치에 `val`을 더합니다.
3. `i`를 `i + (i & -i)`로 업데이트하여 상위 노드로 이동합니다.
4. `i`가 BIT 배열의 크기를 초과할 때까지 2-3 과정을 반복합니다.

### 쿼리(Query)

배열의 특정 인덱스까지의 누적 합을 계산하는 과정입니다.

**쿼리 알고리즘:**

1. 누적 합을 계산할 인덱스를 `i`라 합시다.
2. 결과를 저장할 변수를 `sum`으로 초기화합니다.
3. `i`번째 위치의 값을 `sum`에 더합니다.
4. `i`를 `i - (i & -i)`로 업데이트하여 하위 노드로 이동합니다.
5. `i`가 0이 될 때까지 3-4 과정을 반복합니다.
6. 최종적으로 `sum`을 반환합니다.

## 자바 구현 예제

아래는 이진 인덱스 트리를 사용하여 배열의 누적 합을 계산하고 업데이트하는 Java 코드입니다.

### 코드 구현

```java
public class BinaryIndexedTree {
    private int[] BIT;
    private int size;

    // 생성자: 주어진 크기로 BIT 초기화
    public BinaryIndexedTree(int size) {
        this.size = size;
        BIT = new int[size + 1]; // 1-based 인덱스
    }

    // 인덱스 i에 val을 추가하는 업데이트 메서드
    public void update(int i, int val) {
        while (i <= size) {
            BIT[i] += val;
            i += i & (-i);
        }
    }

    // 인덱스 1부터 i까지의 누적 합을 반환하는 쿼리 메서드
    public int query(int i) {
        int sum = 0;
        while (i > 0) {
            sum += BIT[i];
            i -= i & (-i);
        }
        return sum;
    }

    // 범위 [l, r]의 합을 구하는 메서드
    public int rangeQuery(int l, int r) {
        return query(r) - query(l - 1);
    }

    // 주어진 배열로 BIT를 초기화하는 메서드
    public void build(int[] arr) {
        for (int i = 1; i <= size; i++) {
            update(i, arr[i - 1]);
        }
    }

    // 테스트를 위한 main 메서드
    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 7, 9, 11};
        int n = arr.length;
        BinaryIndexedTree bit = new BinaryIndexedTree(n);
        bit.build(arr);

        System.out.println("구간 [1, 3]의 합: " + bit.rangeQuery(1, 3)); // 출력: 9
        System.out.println("구간 [1, 6]의 합: " + bit.rangeQuery(1, 6)); // 출력: 36

        bit.update(3, 6); // 인덱스 3에 6을 추가
        System.out.println("업데이트 후 구간 [1, 3]의 합: " + bit.rangeQuery(1, 3)); // 출력: 15
    }
}
```

### 코드 설명

- **`BinaryIndexedTree` 클래스**: 이진 인덱스 트리를 구현한 클래스입니다.
    - **멤버 변수**:
        - `BIT[]`: 이진 인덱스 트리를 저장하는 배열입니다. 1-based 인덱스를 사용합니다.
        - `size`: 배열의 크기입니다.
    - **생성자**:
        - 주어진 크기로 BIT 배열을 초기화합니다.
    - **`update` 메서드**:
        - 주어진 인덱스 `i`에 값 `val`을 추가합니다.
        - 상위 노드로 이동하면서 BIT 배열을 업데이트합니다.
    - **`query` 메서드**:
        - 인덱스 `i`까지의 누적 합을 계산합니다.
        - 하위 노드로 이동하면서 BIT 배열에서 값을 합산합니다.
    - **`rangeQuery` 메서드**:
        - 구간 `[l, r]`의 합을 계산합니다.
        - `query(r)`에서 `query(l - 1)`을 빼서 구간 합을 구합니다.
    - **`build` 메서드**:
        - 주어진 배열을 이용하여 BIT를 초기화합니다.
    - **`main` 메서드**:
        - 예제 배열을 생성하고 BIT를 초기화합니다.
        - 초기 구간 합을 출력하고, 업데이트 후 구간 합을 다시 출력합니다.

## 시간 복잡도

- **업데이트 연산**: O(log n)
- **쿼리 연산**: O(log n)
- **빌드 연산**: O(n log n)

이진 인덱스 트리는 업데이트와 쿼리 연산 모두에서 로그 시간 복잡도를 가지므로, 대규모 데이터에 대해서도 효율적으로 동작합니다.

## 응용 분야

- **구간 합 계산**: 배열의 특정 구간 합을 빠르게 계산할 때 사용됩니다.
- **다이나믹 인버스 카운팅**: 역수열 문제 등에서 사용됩니다.
- **게임 개발**: 플레이어의 점수 관리 등에서 사용될 수 있습니다.
- **통계학**: 누적 분포 함수 계산 등에 활용됩니다.
- **데이터베이스**: 빠른 쿼리 응답을 위한 인덱스 구조로 사용될 수 있습니다.

## 예제 문제

### 문제 1: 구간 합과 업데이트

주어진 배열에 대해 다음 두 가지 연산을 수행하세요.

1. 배열의 특정 인덱스에 값을 추가합니다.
2. 특정 구간의 합을 계산합니다.

**입력 예시:**

less

코드 복사

`배열: [1, 3, 5, 7, 9, 11] 연산: 1. 구간 [1, 3]의 합을 계산 2. 구간 [1, 6]의 합을 계산 3. 인덱스 3에 6을 추가 4. 업데이트 후 구간 [1, 3]의 합을 계산`

**출력 예시:**

less

코드 복사

`구간 [1, 3]의 합: 9 구간 [1, 6]의 합: 36 업데이트 후 구간 [1, 3]의 합: 15`

**해결 방법:**

위의 자바 구현 예제를 참고하여 BIT를 사용하면 효율적으로 해결할 수 있습니다.

### 문제 2: 다이나믹한 구간 합

길이가 `n`인 배열이 주어지고, `m`개의 연산이 주어집니다. 연산은 두 가지 유형입니다.

1. `1 i val`: 배열의 `i`번째 요소에 `val`을 더합니다.
2. `2 l r`: 배열의 `l`번째부터 `r`번째까지의 합을 출력합니다.

**제한 사항:**

- `1 ≤ n, m ≤ 10^5`
- `1 ≤ i, l, r ≤ n`
- `|val| ≤ 10^9`

**입력 예시:**

코드 복사

`6 4 1 3 5 7 9 11 2 1 3 2 1 6 1 3 6 2 1 3`

**출력 예시:**

코드 복사

`9 36 15`

**해결 방법:**

BIT를 사용하여 각 연산을 O(log n) 시간 내에 처리할 수 있습니다.

## 결론

이진 인덱스 트리는 배열의 누적 합과 같은 구간 합 문제를 효율적으로 해결할 수 있는 강력한 자료구조입니다. 업데이트와 쿼리 연산을 모두 O(log n) 시간에 처리할 수 있어, 대규모 데이터에서도 빠르게 동작합니다. 간단한 구현과 높은 효율성으로 인해 다양한 알고리즘 문제와 응용 분야에서 널리 사용됩니다. 이진 인덱스 트리의 개념과 구현 방법을 잘 이해하면, 복잡한 데이터 처리 문제를 효과적으로 해결할 수 있습니다.