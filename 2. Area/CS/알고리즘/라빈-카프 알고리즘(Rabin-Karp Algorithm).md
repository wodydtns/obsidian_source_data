**라빈-카프 알고리즘**은 문자열 검색 알고리즘으로, 본문 문자열에서 패턴 문자열을 효율적으로 찾기 위해 사용됩니다. 이 알고리즘은 **해시 함수**를 사용하여 패턴 문자열과 본문 문자열의 부분 문자열의 해시 값을 비교함으로써 문자열 검색을 수행합니다. 특히 여러 개의 패턴을 동시에 검색하는 데 효과적입니다.

## 개념

- **해시(Hash) 함수**: 문자열을 정수 값으로 매핑하는 함수로, 문자열의 내용을 대표하는 숫자를 생성합니다.
- **슬라이딩 윈도우(Sliding Window)**: 본문 문자열에서 패턴의 길이만큼의 부분 문자열을 순차적으로 비교합니다.
- **충돌(Collision)**: 서로 다른 문자열이 동일한 해시 값을 가질 수 있으며, 이를 해결하기 위해 문자열 자체의 비교가 필요할 수 있습니다.

## 특징

- **효율성**: 일반적인 경우 시간 복잡도는 O(n)이며, 해시 충돌이 많을 경우 최악의 시간 복잡도는 O(nm)입니다.
- **다중 패턴 검색**: 여러 패턴을 동시에 검색하는 경우에도 효율적으로 동작합니다.
- **간단한 구현**: 해시 함수를 잘 설계하면 비교적 간단하게 구현할 수 있습니다.

## 적용 분야

- **텍스트 편집기**: 문자열 검색 및 치환 기능 구현.
- **플라그먼트 서치**: DNA 서열 등에서 특정 패턴 검색.
- **정보 검색 시스템**: 대용량 데이터에서 키워드 검색.

## 라빈-카프 알고리즘의 동작 원리

### 1. 패턴과 부분 문자열의 해시 값 계산

- 패턴 문자열의 해시 값을 계산합니다.
- 본문 문자열에서 패턴의 길이만큼의 부분 문자열의 해시 값을 계산합니다.

### 2. 해시 값 비교

- 패턴의 해시 값과 부분 문자열의 해시 값을 비교합니다.
- 해시 값이 동일하면 문자열 자체를 비교하여 일치 여부를 확인합니다.

### 3. 슬라이딩 윈도우를 통한 이동

- 한 칸씩 이동하면서 새로운 부분 문자열의 해시 값을 갱신합니다.
- 이전 해시 값을 이용하여 빠르게 새로운 해시 값을 계산합니다.

## 자바로 구현하기

### 라빈-카프 알고리즘 코드

```Java
public class RabinKarpAlgorithm {

    public final static int d = 256; // 입력 알파벳의 개수

    // q는 해시 값을 계산할 때 사용할 소수입니다.
    public static void search(String pattern, String text, int q) {
        int m = pattern.length();
        int n = text.length();
        int i, j;
        int p = 0; // 패턴의 해시 값
        int t = 0; // 텍스트의 현재 윈도우 해시 값
        int h = 1;

        // h 계산 (h = d^(m-1) % q)
        for (i = 0; i < m - 1; i++) {
            h = (h * d) % q;
        }

        // 패턴과 텍스트의 첫 윈도우 해시 값 계산
        for (i = 0; i < m; i++) {
            p = (d * p + pattern.charAt(i)) % q;
            t = (d * t + text.charAt(i)) % q;
        }

        // 슬라이딩 윈도우를 통해 텍스트 내에서 패턴 검색
        for (i = 0; i <= n - m; i++) {

            // 해시 값이 일치하는 경우
            if (p == t) {
                // 문자 하나하나 비교하여 확인
                for (j = 0; j < m; j++) {
                    if (text.charAt(i + j) != pattern.charAt(j))
                        break;
                }

                if (j == m) {
                    System.out.println("패턴이 인덱스 " + i + "에서 발견되었습니다.");
                }
            }

            // 다음 윈도우의 해시 값 계산 (마지막 윈도우는 계산하지 않음)
            if (i < n - m) {
                t = (d * (t - text.charAt(i) * h) + text.charAt(i + m)) % q;

                // 음수 해시 값을 양수로 변환
                if (t < 0)
                    t = (t + q);
            }
        }
    }

    // 테스트를 위한 main 메서드
    public static void main(String[] args) {
        String text = "GEEKS FOR GEEKS";
        String pattern = "GEEK";
        int q = 101; // 소수

        search(pattern, text, q);
    }
}


```

### 코드 설명

- **상수 `d`**: 사용 가능한 문자 집합의 크기입니다. 예를 들어, ASCII 문자는 256개입니다.
- **해시 값 계산**:
    - 초기 해시 값을 계산할 때, 패턴과 첫 번째 윈도우의 해시 값을 계산합니다.
    - 해시 값은 모듈러 연산을 사용하여 오버플로우를 방지합니다.
- **슬라이딩 윈도우**:
    - 해시 값을 이용하여 다음 윈도우의 해시 값을 빠르게 계산합니다.
    - 새로운 해시 값 `t`는 이전 해시 값에서 가장 왼쪽 문자와 가장 오른쪽 문자를 업데이트하여 계산합니다.
- **해시 값 비교와 실제 문자열 비교**:
    - 해시 값이 동일하면 실제 문자열을 비교하여 패턴이 존재하는지 확인합니다.
    - 해시 충돌로 인해 다른 문자열이 동일한 해시 값을 가질 수 있으므로, 문자열 비교가 필요합니다.

## 라빈-카프 알고리즘의 시간 복잡도

- **평균 시간 복잡도**: O(n + m)
    - 해시 함수를 사용하여 평균적으로 빠른 검색이 가능합니다.
- **최악의 시간 복잡도**: O(nm)
    - 해시 충돌이 빈번하게 발생하면, 실제 문자열 비교가 많이 필요하여 성능이 저하될 수 있습니다.

## 라빈-카프 알고리즘 사용 시 고려사항

- **해시 함수 선택**: 좋은 해시 함수를 선택하여 해시 충돌을 최소화해야 합니다.
- **모듈러 연산**: 큰 수의 오버플로우를 방지하기 위해 적절한 소수를 선택하여 모듈러 연산을 수행합니다.
- **해시 충돌 처리**: 해시 값이 같을 때 문자열을 직접 비교하여 일치 여부를 확인합니다.
- **알파벳 크기**: 사용하는 문자 집합의 크기에 따라 `d`의 값을 설정해야 합니다.

## 라빈-카프 알고리즘의 응용 분야

- **멀티 패턴 검색**: 여러 패턴을 동시에 검색할 때 효율적입니다.
- **플래기어리즘 검출**: 문서 내에서 특정 문구나 구절을 검색하여 표절을 확인합니다.
- **네트워크 보안**: 패킷 검사에서 특정 패턴의 데이터 탐지.

## 결론

라빈-카프 알고리즘은 해시 함수를 활용하여 문자열 검색을 효율적으로 수행하는 알고리즘입니다. 특히 여러 패턴을 동시에 검색하거나 긴 문자열에서 부분 문자열을 찾는 데 유용합니다. 해시 충돌을 최소화하기 위한 해시 함수의 선택과 모듈러 연산의 적절한 사용이 알고리즘의 성능에 중요한 영향을 미칩니다.