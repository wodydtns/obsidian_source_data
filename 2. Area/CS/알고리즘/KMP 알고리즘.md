**KMP(Knuth-Morris-Pratt) 알고리즘**은 문자열 검색 알고리즘으로, 본문 문자열에서 패턴 문자열을 효율적으로 찾기 위해 사용됩니다. 일반적인 브루트 포스 방식의 문자열 검색은 시간 복잡도가 O(nm)이지만, KMP 알고리즘은 전처리 과정을 통해 시간 복잡도를 O(n + m)으로 줄일 수 있습니다.

## 개념

- **부분 일치 테이블(Partial Match Table, LPS 배열)**: 패턴 내에서 자기 자신을 찾는 데 사용되는 배열로, 각 위치에서의 접두사와 접미사의 최대 일치 길이를 저장합니다.
- **불일치 발생 시 이동 거리**: 불일치가 발생하면 부분 일치 테이블을 참조하여 이동해야 할 위치를 결정합니다.

## 특징

- **효율성**: 중복 연산을 줄여 문자열 검색의 시간 복잡도를 개선합니다.
- **전처리 단계**: 패턴 문자열에 대한 부분 일치 테이블을 미리 계산하여 검색 단계에서 활용합니다.
- **O(n + m) 시간 복잡도**: n은 본문 문자열의 길이, m은 패턴 문자열의 길이입니다.

## 적용 분야

- **텍스트 에디터**: 문자열 검색 및 치환 기능 구현.
- **DNA 서열 분석**: 특정 서열의 패턴을 찾는 데 사용.
- **보안 분야**: 악성 코드 탐지 등 패턴 매칭이 필요한 분야.

## KMP 알고리즘의 동작 원리

### 1. 부분 일치 테이블(LPS 배열) 생성

- 패턴 문자열의 접두사와 접미사가 일치하는 최대 길이를 계산하여 배열에 저장합니다.
- 이 테이블은 불일치가 발생했을 때 패턴을 얼마나 이동해야 하는지를 결정합니다.

#### 부분 일치 테이블 생성 예시

패턴 문자열: "ABABCABAB"

|인덱스(i)|문자|LPS[i]|
|---|---|---|
|0|A|0|
|1|B|0|
|2|A|1|
|3|B|2|
|4|C|0|
|5|A|1|
|6|B|2|
|7|A|3|
|8|B|4|

### 2. 문자열 검색

- 본문 문자열과 패턴 문자열을 비교하면서 일치 여부를 검사합니다.
- 불일치가 발생하면 부분 일치 테이블을 참고하여 패턴을 이동시킵니다.
- 이미 비교한 문자를 다시 비교하지 않으므로 효율성이 높습니다.

## 자바로 구현하기

### KMP 알고리즘 코드

```Java
public class KMPAlgorithm {

    // 부분 일치 테이블(LPS 배열) 생성
    public static int[] computeLPSArray(String pattern) {
        int m = pattern.length();
        int[] lps = new int[m];
        int len = 0; // 이전 일치한 접두사 길이
        lps[0] = 0; // 첫 번째 문자에 대한 lps는 0

        int i = 1;
        while (i < m) {
            if (pattern.charAt(i) == pattern.charAt(len)) {
                len++;
                lps[i] = len;
                i++;
            } else {
                if (len != 0) {
                    len = lps[len - 1];
                    // len을 조정한 후 다시 비교
                } else {
                    lps[i] = 0;
                    i++;
                }
            }
        }
        return lps;
    }

    // KMP 알고리즘으로 문자열 검색
    public static void KMPSearch(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();

        // 부분 일치 테이블 생성
        int[] lps = computeLPSArray(pattern);

        int i = 0; // text의 인덱스
        int j = 0; // pattern의 인덱스

        while (i < n) {
            if (text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            }

            if (j == m) {
                System.out.println("패턴이 인덱스 " + (i - j) + "에서 발견되었습니다.");
                j = lps[j - 1]; // 다음 비교를 위해 j를 조정
            } else if (i < n && text.charAt(i) != pattern.charAt(j)) {
                if (j != 0) {
                    j = lps[j - 1]; // lps 배열을 사용하여 j를 조정
                } else {
                    i++;
                }
            }
        }
    }

    // 테스트를 위한 main 메서드
    public static void main(String[] args) {
        String text = "ABABDABACDABABCABAB";
        String pattern = "ABABCABAB";

        KMPSearch(text, pattern);
    }
}

```

### 코드 설명

- **`computeLPSArray` 메서드**: 패턴 문자열에 대한 부분 일치 테이블(LPS 배열)을 생성합니다.
    - `len`은 현재 접두사와 접미사가 일치하는 최대 길이를 나타냅니다.
    - 패턴의 각 문자에 대해 접두사와 접미사의 최대 일치 길이를 계산하여 `lps` 배열에 저장합니다.
- **`KMPSearch` 메서드**: 본문 문자열에서 패턴 문자열을 검색합니다.
    - `i`는 본문 문자열의 인덱스, `j`는 패턴 문자열의 인덱스입니다.
    - 문자 일치 여부에 따라 `i`와 `j`를 증가시키거나, `lps` 배열을 사용하여 `j`를 조정합니다.
    - 패턴이 발견되면 해당 인덱스를 출력하고, `j`를 조정하여 다음 검색을 진행합니다.

## KMP 알고리즘의 시간 복잡도

- **전처리 단계**: O(m)
    - 부분 일치 테이블을 생성하는 데 소요되는 시간.
- **검색 단계**: O(n)
    - 본문 문자열을 한 번만 순회하면서 패턴을 검색.
- **전체 시간 복잡도**: O(n + m)

## KMP 알고리즘 사용 시 고려사항

- **부분 일치 테이블의 이해**: LPS 배열을 정확히 이해하고 구현해야 알고리즘을 올바르게 동작시킬 수 있습니다.
- **패턴이 반복되는 경우**: 패턴 내에 반복되는 부분이 많을수록 LPS 배열의 값이 커져 효율성이 높아집니다.
- **대소문자 구분**: 문자 비교 시 대소문자를 구분하므로, 필요에 따라 문자열을 동일한 대소문자로 변환해야 합니다.

## KMP 알고리즘의 응용 분야

- **텍스트 편집기**: 문자열 검색 및 치환 기능 구현.
- **인터넷 검색 엔진**: 키워드 검색 최적화.
- **DNA 서열 분석**: 유전체 내 특정 서열 패턴 검색.
- **네트워크 보안**: 패킷 내 특정 패턴(예: 바이러스 서명) 탐지.

## 결론

KMP 알고리즘은 문자열 검색을 효율적으로 수행하기 위한 알고리즘으로, 부분 일치 테이블을 활용하여 불필요한 비교를 줄입니다. 이를 통해 본문 문자열의 길이에 선형적으로 비례하는 시간 내에 패턴을 검색할 수 있습니다. 문자열 처리 분야에서 자주 사용되며, 알고리즘의 원리를 이해하고 구현하는 것은 컴퓨터 과학 및 소프트웨어 개발에서 중요한 기술입니다.