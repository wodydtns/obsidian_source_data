**에드몬드-카프 알고리즘(Edmonds-Karp Algorithm)**은 최대 유량 문제를 해결하기 위한 알고리즘으로, **포드-풀커슨 알고리즘**의 특정 구현입니다. 이 알고리즘은 **너비 우선 탐색(BFS)**을 사용하여 잔여 그래프에서 최단 경로의 증가 경로를 찾음으로써 포드-풀커슨 알고리즘의 성능을 개선합니다.

## 개념

- **유량 네트워크(Flow Network)**: 각 간선이 용량을 가지는 방향 그래프.
- **소스(Source)와 싱크(Sink)**: 유량이 시작되는 노드와 종료되는 노드.
- **잔여 그래프(Residual Graph)**: 현재 유량을 고려하여 추가로 보낼 수 있는 유량을 나타내는 그래프.
- **증가 경로(Augmenting Path)**: 소스에서 싱크로 추가 유량을 보낼 수 있는 경로.

## 특징

- **너비 우선 탐색(BFS) 사용**: 증가 경로를 찾을 때 BFS를 사용하여 가장 적은 간선 수를 가진 경로를 찾습니다.
- **시간 복잡도 개선**: 일반적인 포드-풀커슨 알고리즘의 비합리적인 시간 복잡도를 O(V * E^2)로 개선합니다.
- **신뢰성**: 항상 최단 증가 경로를 선택하므로 알고리즘의 수행 시간이 안정적입니다.

## 알고리즘의 동작 원리

1. **초기화**:
    
    - 모든 간선의 초기 유량을 0으로 설정합니다.
2. **잔여 그래프 생성**:
    
    - 각 간선에 대해 용량에서 현재 유량을 뺀 값을 용량으로 가지는 잔여 그래프를 생성합니다.
3. **BFS를 통한 증가 경로 찾기**:
    
    - 잔여 그래프에서 소스에서 싱크로의 최단 증가 경로를 찾습니다.
    - 경로를 찾을 수 없을 때까지 반복합니다.
4. **유량 갱신**:
    
    - 증가 경로에서의 최소 잔여 용량을 찾아 해당 경로의 간선에 유량을 추가합니다.
    - 반대 방향의 간선에 대해 유량을 감소시킵니다(역방향 간선 고려).
5. **최대 유량 계산**:
    
    - 각 증가 경로에서 추가된 유량을 합산하여 최대 유량을 계산합니다.

## 자바로 구현하기

### 코드 구현
```Java
import java.util.LinkedList;
import java.util.Queue;

public class EdmondsKarp {
    static final int V = 6; // 노드의 수

    // BFS를 사용하여 증가 경로를 찾습니다.
    boolean bfs(int[][] rGraph, int s, int t, int[] parent) {
        boolean[] visited = new boolean[V];
        Queue<Integer> queue = new LinkedList<>();
        queue.add(s);
        visited[s] = true;
        parent[s] = -1;

        while (!queue.isEmpty()) {
            int u = queue.poll();

            for (int v = 0; v < V; v++) {
                if (!visited[v] && rGraph[u][v] > 0) {
                    queue.add(v);
                    parent[v] = u;
                    visited[v] = true;

                    // 싱크에 도달하면 조기 종료
                    if (v == t) {
                        return true;
                    }
                }
            }
        }

        // 싱크에 도달하지 못하면 false 반환
        return false;
    }

    // 에드몬드-카프 알고리즘으로 최대 유량을 계산합니다.
    int edmondsKarp(int[][] graph, int s, int t) {
        int u, v;

        // 잔여 그래프 생성 및 초기화
        int[][] rGraph = new int[V][V];
        for (u = 0; u < V; u++) {
            for (v = 0; v < V; v++) {
                rGraph[u][v] = graph[u][v];
            }
        }

        int[] parent = new int[V]; // 경로를 저장할 배열
        int maxFlow = 0; // 초기 유량은 0

        // 증가 경로가 존재하는 동안 반복
        while (bfs(rGraph, s, t, parent)) {
            // 증가 경로에서의 최소 잔여 용량 찾기
            int pathFlow = Integer.MAX_VALUE;
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                pathFlow = Math.min(pathFlow, rGraph[u][v]);
            }

            // 유량 갱신
            for (v = t; v != s; v = parent[v]) {
                u = parent[v];
                rGraph[u][v] -= pathFlow;
                rGraph[v][u] += pathFlow;
            }

            // 최대 유량에 경로 유량 추가
            maxFlow += pathFlow;
        }

        return maxFlow;
    }

    // 테스트를 위한 main 메서드
    public static void main(String[] args) {
        int graph[][] = new int[][] {
            { 0, 16, 13, 0, 0, 0 },
            { 0, 0, 10, 12, 0, 0 },
            { 0, 4, 0, 0, 14, 0 },
            { 0, 0, 9, 0, 0, 20 },
            { 0, 0, 0, 7, 0, 4 },
            { 0, 0, 0, 0, 0, 0 }
        };
        EdmondsKarp m = new EdmondsKarp();

        System.out.println("주어진 그래프에서 최대 유량은 " +
            m.edmondsKarp(graph, 0, 5));
    }
}

```

### 코드 설명

- **`bfs` 메서드**:
    
    - 잔여 그래프에서 소스 `s`에서 싱크 `t`까지의 최단 증가 경로를 찾습니다.
    - `parent` 배열에 각 노드의 부모 노드를 저장하여 경로를 추적합니다.
    - 싱크에 도달하면 `true`를 반환하고, 도달하지 못하면 `false`를 반환합니다.
    - 조기 종료를 통해 불필요한 탐색을 줄입니다.
- **`edmondsKarp` 메서드**:
    
    - 잔여 그래프를 초기화하고 최대 유량 `maxFlow`를 0으로 설정합니다.
    - 증가 경로가 존재하는 동안 반복하여 유량을 갱신합니다.
    - 각 증가 경로에서 최소 잔여 용량(`pathFlow`)을 찾습니다.
    - 경로의 간선들에 대해 유량을 감소시키고, 역방향 간선의 유량을 증가시킵니다.
    - `maxFlow`에 `pathFlow`를 누적합니다.
- **`main` 메서드**:
    
    - 그래프를 인접 행렬로 표현하고, 소스는 0번 노드, 싱크는 5번 노드로 설정합니다.
    - `edmondsKarp` 메서드를 호출하여 최대 유량을 계산하고 출력합니다.

## 시간 복잡도 분석

- **시간 복잡도**: O(V * E^2)
    
    - V는 노드의 수, E는 간선의 수입니다.
    - BFS를 사용하여 최단 증가 경로를 찾으므로, 각 증가 경로는 최소 간선 수를 가집니다.
    - 최대 반복 횟수는 O(E * V)이며, 각 BFS의 시간 복잡도는 O(E)입니다.
    - 따라서 전체 시간 복잡도는 O(V * E^2)입니다.
- **성능 개선**:
    
    - 에드몬드-카프 알고리즘은 일반적인 포드-풀커슨 알고리즘보다 안정적이고 효율적입니다.
    - 특히, 간선의 용량이 큰 경우에도 성능이 좋습니다.

## 에드몬드-카프 알고리즘의 장점과 단점

### 장점

- **안정적인 성능**: 항상 최단 증가 경로를 선택하므로 수행 시간이 예측 가능합니다.
- **구현의 간단함**: BFS를 활용하여 구현이 비교적 간단합니다.
- **유량 네트워크의 다양한 문제에 적용 가능**: 최대 매칭, 최소 컷 등 다양한 문제 해결에 사용됩니다.

### 단점

- **큰 그래프에서의 성능 제한**: 간선 수가 매우 많은 그래프에서는 시간 복잡도가 높아질 수 있습니다.
- **더 빠른 알고리즘 존재**: Dinic 알고리즘 등 더 효율적인 알고리즘이 존재합니다.

## 응용 분야

- **네트워크 흐름 문제**:
    
    - 통신 네트워크에서 데이터 패킷의 최대 전송량 계산.
    - 교통 시스템에서 차량 흐름 최적화.
- **이분 매칭**:
    
    - 작업과 작업자 간의 최대 매칭을 찾는 문제.
    - 대학 지원자와 대학 간의 매칭.
- **이미지 분할**:
    
    - 그래프 컷(Graph Cut)을 이용한 이미지 처리 분야.
- **프로젝트 스케줄링**:
    
    - 작업 간의 의존성을 고려하여 자원 할당 최적화.

## 결론

에드몬드-카프 알고리즘은 최대 유량 문제를 해결하는 데 널리 사용되는 알고리즘으로, 포드-풀커슨 알고리즘의 성능을 개선한 버전입니다. BFS를 사용하여 최단 증가 경로를 찾음으로써 알고리즘의 안정성과 효율성을 높였습니다. 다양한 분야에서 최대 유량 문제를 해결하는 데 활용되며, 알고리즘의 이해와 구현은 컴퓨터 과학 및 공학 분야에서 중요한 기술입니다.
