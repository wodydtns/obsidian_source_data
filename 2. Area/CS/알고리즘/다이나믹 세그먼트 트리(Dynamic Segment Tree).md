# 다이나믹 세그먼트 트리 (Dynamic Segment Tree)

**다이나믹 세그먼트 트리(Dynamic Segment Tree)**는 세그먼트 트리의 변형으로, 초기 배열의 크기가 매우 크거나, 배열의 크기가 동적으로 변할 때 효율적으로 동작할 수 있도록 설계된 자료구조입니다. 일반적인 세그먼트 트리는 고정된 크기의 배열에 적합하지만, 다이나믹 세그먼트 트리는 메모리 사용을 최적화하면서도 빠른 업데이트와 쿼리 성능을 유지할 수 있습니다.

## 목차
- [개념](#개념)
- [특징](#특징)
- [기본 연산](#기본-연산)
  - [업데이트(Update)](#업데이트update)
  - [쿼리(Query)](#쿼리query)
- [자바 구현 예제](#자바-구현-예제)
  - [노드 클래스 정의](#노드-클래스-정의)
  - [다이나믹 세그먼트 트리 클래스](#다이나믹-세그먼트-트리-클래스)
- [시간 복잡도](#시간-복잡도)
- [응용 분야](#응용-분야)
- [예제 문제](#예제-문제)
- [결론](#결론)

## 개념

다이나믹 세그먼트 트리는 세그먼트 트리의 구조를 동적으로 생성하여, 필요할 때마다 노드를 생성하는 방식으로 동작합니다. 이를 통해 초기 배열이 매우 크거나, 배열의 크기가 사전에 명확하지 않은 경우에도 효율적으로 사용할 수 있습니다.

### 세그먼트 트리와의 차이점

- **고정 세그먼트 트리**: 모든 노드를 미리 생성하여 고정된 크기의 배열을 사용합니다. 메모리 사용량이 클 수 있으며, 배열의 크기가 변경되면 트리를 다시 생성해야 합니다.
- **다이나믹 세그먼트 트리**: 필요한 노드만 동적으로 생성하여 메모리를 절약합니다. 배열의 크기가 변경되더라도 유연하게 대응할 수 있습니다.

## 특징

- **메모리 효율성**: 필요한 노드만 생성하므로, 메모리 사용량을 최소화할 수 있습니다.
- **유연성**: 배열의 크기가 동적으로 변하거나, 매우 큰 범위를 다룰 때 유용합니다.
- **빠른 업데이트 및 쿼리**: 일반적인 세그먼트 트리와 동일한 시간 복잡도로 동작합니다.

## 기본 연산

다이나믹 세그먼트 트리에서 주로 사용하는 두 가지 기본 연산은 **업데이트(Update)**와 **쿼리(Query)**입니다.

### 업데이트(Update)

배열의 특정 인덱스에 값을 추가하거나 변경할 때, 세그먼트 트리를 업데이트하는 과정입니다.

**업데이트 알고리즘:**

1. 업데이트할 인덱스를 `idx`라 하고, 추가할 값을 `val`이라 합시다.
2. 루트 노드부터 시작하여, 해당 인덱스가 속한 구간을 찾아가며 노드의 값을 업데이트합니다.
3. 필요할 경우, 자식 노드를 동적으로 생성합니다.

### 쿼리(Query)

배열의 특정 구간의 합이나 최소값 등을 계산하는 과정입니다.

**쿼리 알고리즘:**

1. 쿼리할 구간을 `[L, R]`이라 합시다.
2. 루트 노드부터 시작하여, 해당 구간과의 관계를 확인하며 필요한 노드의 값을 합산합니다.
3. 필요할 경우, 자식 노드를 동적으로 생성합니다.

## 자바 구현 예제

아래는 다이나믹 세그먼트 트리를 사용하여 배열의 누적 합을 계산하고 업데이트하는 Java 코드입니다.

### 노드 클래스 정의

먼저, 세그먼트 트리의 각 노드를 표현하는 `Node` 클래스를 정의합니다.

```java
// 세그먼트 트리 노드 클래스
class Node {
    long sum; // 현재 구간의 합
    Node left, right; // 왼쪽, 오른쪽 자식 노드

    public Node() {
        this.sum = 0;
        this.left = null;
        this.right = null;
    }
}
```

# 다이나믹 세그먼트 트리 (Dynamic Segment Tree)

**다이나믹 세그먼트 트리(Dynamic Segment Tree)**는 세그먼트 트리의 변형으로, 초기 배열의 크기가 매우 크거나, 배열의 크기가 동적으로 변할 때 효율적으로 동작할 수 있도록 설계된 자료구조입니다. 일반적인 세그먼트 트리는 고정된 크기의 배열에 적합하지만, 다이나믹 세그먼트 트리는 메모리 사용을 최적화하면서도 빠른 업데이트와 쿼리 성능을 유지할 수 있습니다.

## 목차
- [개념](#개념)
- [특징](#특징)
- [기본 연산](#기본-연산)
  - [업데이트(Update)](#업데이트update)
  - [쿼리(Query)](#쿼리query)
- [자바 구현 예제](#자바-구현-예제)
  - [노드 클래스 정의](#노드-클래스-정의)
  - [다이나믹 세그먼트 트리 클래스](#다이나믹-세그먼트-트리-클래스)
- [시간 복잡도](#시간-복잡도)
- [응용 분야](#응용-분야)
- [예제 문제](#예제-문제)
- [결론](#결론)

## 개념

다이나믹 세그먼트 트리는 세그먼트 트리의 구조를 동적으로 생성하여, 필요할 때마다 노드를 생성하는 방식으로 동작합니다. 이를 통해 초기 배열이 매우 크거나, 배열의 크기가 사전에 명확하지 않은 경우에도 효율적으로 사용할 수 있습니다.

### 세그먼트 트리와의 차이점

- **고정 세그먼트 트리**: 모든 노드를 미리 생성하여 고정된 크기의 배열을 사용합니다. 메모리 사용량이 클 수 있으며, 배열의 크기가 변경되면 트리를 다시 생성해야 합니다.
- **다이나믹 세그먼트 트리**: 필요한 노드만 동적으로 생성하여 메모리를 절약합니다. 배열의 크기가 변경되더라도 유연하게 대응할 수 있습니다.

## 특징

- **메모리 효율성**: 필요한 노드만 생성하므로, 메모리 사용량을 최소화할 수 있습니다.
- **유연성**: 배열의 크기가 동적으로 변하거나, 매우 큰 범위를 다룰 때 유용합니다.
- **빠른 업데이트 및 쿼리**: 일반적인 세그먼트 트리와 동일한 시간 복잡도로 동작합니다.

## 기본 연산

다이나믹 세그먼트 트리에서 주로 사용하는 두 가지 기본 연산은 **업데이트(Update)**와 **쿼리(Query)**입니다.

### 업데이트(Update)

배열의 특정 인덱스에 값을 추가하거나 변경할 때, 세그먼트 트리를 업데이트하는 과정입니다.

**업데이트 알고리즘:**

1. 업데이트할 인덱스를 `idx`라 하고, 추가할 값을 `val`이라 합시다.
2. 루트 노드부터 시작하여, 해당 인덱스가 속한 구간을 찾아가며 노드의 값을 업데이트합니다.
3. 필요할 경우, 자식 노드를 동적으로 생성합니다.

### 쿼리(Query)

배열의 특정 구간의 합이나 최소값 등을 계산하는 과정입니다.

**쿼리 알고리즘:**

1. 쿼리할 구간을 `[L, R]`이라 합시다.
2. 루트 노드부터 시작하여, 해당 구간과의 관계를 확인하며 필요한 노드의 값을 합산합니다.
3. 필요할 경우, 자식 노드를 동적으로 생성합니다.

## 자바 구현 예제

아래는 다이나믹 세그먼트 트리를 사용하여 배열의 누적 합을 계산하고 업데이트하는 Java 코드입니다.

### 노드 클래스 정의

먼저, 세그먼트 트리의 각 노드를 표현하는 `Node` 클래스를 정의합니다.

```java
// 세그먼트 트리 노드 클래스
class Node {
    long sum; // 현재 구간의 합
    Node left, right; // 왼쪽, 오른쪽 자식 노드

    public Node() {
        this.sum = 0;
        this.left = null;
        this.right = null;
    }
}



```

### 다이나믹 세그먼트 트리 클래스

다음으로, 다이나믹 세그먼트 트리의 주요 연산을 구현한 `DynamicSegmentTree` 클래스를 작성합니다.
```Java
public class DynamicSegmentTree {
    private Node root;
    private int size; // 배열의 최대 크기

    // 생성자: 트리 초기화
    public DynamicSegmentTree(int size) {
        this.size = size;
        this.root = new Node();
    }

    // 업데이트 메서드: idx 위치에 val을 추가
    public void update(int idx, long val) {
        update(root, 1, size, idx, val);
    }

    private void update(Node node, int left, int right, int idx, long val) {
        if (left == right) {
            node.sum += val;
            return;
        }
        int mid = left + (right - left) / 2;
        if (idx <= mid) {
            if (node.left == null) node.left = new Node();
            update(node.left, left, mid, idx, val);
        } else {
            if (node.right == null) node.right = new Node();
            update(node.right, mid + 1, right, idx, val);
        }
        node.sum = getSum(node.left) + getSum(node.right);
    }

    // 쿼리 메서드: [L, R] 구간의 합을 반환
    public long query(int L, int R) {
        return query(root, 1, size, L, R);
    }

    private long query(Node node, int left, int right, int L, int R) {
        if (node == null || L > right || R < left) return 0;
        if (L <= left && right <= R) return node.sum;
        int mid = left + (right - left) / 2;
        return query(node.left, left, mid, L, R) + query(node.right, mid + 1, right, L, R);
    }

    // 보조 메서드: 노드가 null인 경우 0 반환
    private long getSum(Node node) {
        return node == null ? 0 : node.sum;
    }

    // 테스트를 위한 main 메서드
    public static void main(String[] args) {
        int n = 1000000; // 배열의 크기 (예: 1,000,000)
        DynamicSegmentTree dst = new DynamicSegmentTree(n);

        // 초기 배열 값 설정 (예시)
        // 배열의 인덱스는 1부터 n까지
        dst.update(1, 5);
        dst.update(3, 10);
        dst.update(1000000, 7);

        // 쿼리 예시
        System.out.println("구간 [1, 3]의 합: " + dst.query(1, 3)); // 출력: 15
        System.out.println("구간 [1, 1000000]의 합: " + dst.query(1, 1000000)); // 출력: 22

        // 추가 업데이트
        dst.update(3, 5);
        System.out.println("업데이트 후 구간 [1, 3]의 합: " + dst.query(1, 3)); // 출력: 20
    }
}

```
### 코드 설명

- **`Node` 클래스**:
    - `sum`: 현재 구간의 합을 저장합니다.
    - `left`, `right`: 왼쪽과 오른쪽 자식 노드를 가리킵니다.
- **`DynamicSegmentTree` 클래스**:
    - **멤버 변수**:
        - `root`: 세그먼트 트리의 루트 노드입니다.
        - `size`: 배열의 최대 크기입니다.
    - **생성자**:
        - 주어진 크기로 세그먼트 트리를 초기화합니다.
    - **`update` 메서드**:
        - 특정 인덱스에 값을 추가하는 메서드입니다.
        - 트리를 탐색하며 필요한 노드를 동적으로 생성하고, 합계를 업데이트합니다.
    - **`query` 메서드**:
        - 특정 구간의 합을 반환하는 메서드입니다.
        - 트리를 탐색하며 해당 구간의 합을 계산합니다.
    - **`getSum` 메서드**:
        - 노드가 `null`인 경우 0을 반환하고, 그렇지 않으면 노드의 합계를 반환합니다.
    - **`main` 메서드**:
        - 예제 배열을 생성하고, 업데이트와 쿼리 연산을 수행하여 결과를 출력합니다.

## 시간 복잡도

- **업데이트 연산**: O(log n)
    - 트리의 높이에 비례하여 로그 시간 내에 업데이트를 수행할 수 있습니다.
- **쿼리 연산**: O(log n)
    - 트리의 높이에 비례하여 로그 시간 내에 구간 합을 계산할 수 있습니다.
- **공간 복잡도**: O(n log n) (최악의 경우)
    - 다이나믹 세그먼트 트리는 필요한 노드만 생성하므로, 실제 사용 시에는 일반 세그먼트 트리보다 메모리를 덜 사용할 수 있습니다.

## 응용 분야

- **구간 합 계산**: 대규모 배열에서 특정 구간의 합을 빠르게 계산할 때 사용됩니다.
- **다이나믹 데이터 처리**: 데이터가 동적으로 변하는 상황에서 효율적인 데이터 처리에 활용됩니다.
- **게임 개발**: 실시간 데이터 업데이트와 쿼리가 필요한 게임 로직에서 사용될 수 있습니다.
- **통계학 및 데이터 분석**: 누적 합계나 통계치를 빠르게 계산하는 데 유용합니다.
- **컴퓨터 그래픽스**: 이미지 처리에서 누적 합 등을 계산하는 데 사용될 수 있습니다.

## 예제 문제

### 문제 1: 구간 합과 업데이트

길이가 `n`인 배열이 주어지고, `m`개의 연산이 주어집니다. 연산은 두 가지 유형입니다.

1. `1 i val`: 배열의 `i`번째 요소에 `val`을 더합니다.
2. `2 l r`: 배열의 `l`번째부터 `r`번째까지의 합을 출력합니다.

**제한 사항:**

- `1 ≤ n, m ≤ 10^6`
- `1 ≤ i, l, r ≤ n`
- `|val| ≤ 10^9`

**입력 예시:**

코드 복사

`1000000 5 1 1 5 1 3 10 2 1 3 1 1000000 7 2 1 1000000`

**출력 예시:**

코드 복사

`15 22`

**해결 방법:**

다이나믹 세그먼트 트리를 사용하여 각 연산을 O(log n) 시간 내에 처리할 수 있습니다.

### 문제 2: 동적 범위 합

길이가 `n`인 배열이 주어지고, `m`개의 연산이 주어집니다. 연산은 다음과 같습니다.

1. `1 x y`: 배열의 `x`번째 요소를 `y`로 설정합니다.
2. `2 a b`: 배열의 `a`번째부터 `b`번째까지의 합을 출력합니다.

**제한 사항:**

- `1 ≤ n, m ≤ 10^5`
- `1 ≤ x, a, b ≤ n`
- `|y| ≤ 10^9`

**입력 예시:**

코드 복사

`5 5 1 1 10 1 2 20 2 1 2 1 3 30 2 1 3`

**출력 예시:**

코드 복사

`30 60`

**해결 방법:**

다이나믹 세그먼트 트리를 사용하여 배열의 업데이트와 구간 합을 효율적으로 관리할 수 있습니다.

## 결론

다이나믹 세그먼트 트리는 고정 세그먼트 트리의 한계를 극복하며, 메모리 효율성과 유연성을 제공합니다. 배열의 크기가 매우 크거나, 동적으로 변하는 데이터에 대해 빠른 업데이트와 쿼리를 필요로 하는 다양한 응용 분야에서 유용하게 사용됩니다. 세그먼트 트리의 기본 개념을 이해한 후, 다이나믹 세그먼트 트리를 구현하면 복잡한 데이터 처리 문제를 효과적으로 해결할 수 있습니다. 자바를 비롯한 여러 프로그래밍 언어로 쉽게 구현할 수 있으며, 알고리즘 문제 해결과 실무 프로젝트에서 큰 도움이 됩니다.