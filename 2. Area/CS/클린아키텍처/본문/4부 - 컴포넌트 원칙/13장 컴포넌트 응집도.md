## REP : 재사용/릴리스 등가 원칙
>[!note]
>재사용 단위는 릴리스 단위와 같다

- 재사용/릴리스 등가 원칙은 너무 당연
	- 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수 없고 하지도 않을 것이다
	- 릴리즈 번호가 없다면 재사용 컴포넌트들이 서로 호환되지는 보증할 방법이 전혀 없다
	- 새로운 버전이 언제 출시되고 무엇이 변했는지를 소프트웨어 개발자들이 알아야 하기 때문
- 릴리즈 절차에는 적절한 공지와 함께 릴리스 문서 작성도 포함되어야한다
- REP 원칙은 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야함을 의미
- 단순히 뒤죽박죽 임의로 선택된 클래스와 모듈로 구성되어서는 안된다. 컴포넌트를 구성하는 모든 모듈은 **서로 공유하는 중요한 테마나 목적이 있어야 한다**
- 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다는 사실은 컴포넌트 제작자 입장이나 사용자 입장에서도 이치에 맞는다

## CCP : 공통 폐쇄 원칙
>[!note]
>동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.
>서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라

- **이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다**
- 공통 폐쇄 원칙에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다
- CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 변경이 필요한 요구사항이 발생했을 때, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다

## CRP : 공통 재사용 원칙
>[!note]
>컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라

- CRP는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다
- 컴포넌트 내부에서는 클래스들 사이에 수많은 의존성이 있다
- 예시
	- [[container 클래스와 해당 클래스의 iterator 클래스]]
		- 이들 클래스는 서로 강하게 결합되어 있어 함께 재사용 된다
		- 따라서 이들 클래스는 반드시 동일한 컴포넌트에 위치해야 한다
- CRP는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말한다
	- 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야한다
	- 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다
	- 즉, 그중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실하게 인지해야한다
### ISP와의 관계
- CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전
- ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언한다
- CRP는 사용하지 안흔 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다

## 컴포넌트 응집도에 대한 균형 다이어그램
![[Pasted image 20250119154115.png]]
- REP와 CCP는 포함 원칙
	- 두 원칙은 컴포넌트를 더욱 크게 만든다
- CRP는 배제 원칙
	- 컴포넌트를 더욱 작게 만든다
- REP와 CRP 에만 집중하면 너무 많은 컴포넌트에 영향을 미친다
- CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 빈번해진다
- 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편이며, 이때는 오직 재사용성만 희생하면 된다
- 프로젝트가 성숙하고, 그 프로젝트로부터 파생된 또 다른 프로젝트가 시작되면, 프로젝트는 삼각형에서 점차 왼쪽으로 이동