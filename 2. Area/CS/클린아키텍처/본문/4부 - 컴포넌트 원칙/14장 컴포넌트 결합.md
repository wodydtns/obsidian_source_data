## ADP : 의존성 비순환 원칙
>[!important]
>컴포넌트 의존성 그래프에 순환이 있어서는 안된다

- '숙취 증후군'(the morning after syndrome)
	- 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생

### 주 단위 빌드(Weekly Build)
- 중간 규모의 프로젝트에서 흔하게 사용
- 방법
	- 모든 개발자가 일주일의 첫 4일 동안 서로를 신경쓰지 않고 개발자 모두 코드를 개인적으로 복사해 작업
	- 금요일에 변경된 코드를 모두 통합해 시스템 빌드
- 프로젝트가 커지면 프로젝트 통합은 금요일 하루 만에 끝마치는 게 불가능해짐
- 개발보다 코드 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠짐
- 이는 통합 & 테스트를 수행하기 점점 더 어려워지고, 팀은 빠른 피드백이 주는 장점을 잃음
### 순환 의존성 제거하기
- 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리
	- 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위로 분리
	- 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스해 다른 개발자가 사용할 수 있도록 만듦
- 컴포넌트가 새로 릴리스되어 사용할 수 있게 되면, 다른 팀에서는 새 릴리스를 당장 적용할지 결정해야함
	- 적용하지 않기로 했다면 과거 버전의 릴리스 계속 사용
	- 새 릴리스가 적용할 준비가 되었다고 판단하면 새 릴리스를 사용하기 시작
	- **즉, 어떤 팀도 다른 팀에 의해 좌우되지 않는다**
- 이 절차는 단순하고 합리적이어서 널리 사용되는 방식
	- 하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야함
- 예시![[Pasted image 20250125190202.png]]
	- 어느 컴포넌트에서 시작하더라도 의존성 관계를 따라가면 최초의 컴포넌트로 돌아갈 수 없음 => **"비순환 방향 그래프"**
	- Presenters를 릴리스하면 -> View, Main 컴포넌트 둘 다 영향
	- Main은 다른 어떤 것이 변경되더라도 무관하게 변경할 수 있음

### 순환이 컴포넌트 의존성 그래프에 미치는 영향
![[Pasted image 20250125190453.png]]
- Entities를 변경하면 Authorizer, Interactors 에 영향 -> 순환 의존성
- 예시
	- Database를 변경하면 Entities가 영향을 받음 -> Entities는 Authorizer에 영향을 Authorizer는 Interactors에 영향을 줌
		- 이 모든 컴포넌트가 서로 얽매이게 되어, 모두 항상 정확하게 동일한 릴리스 사용해야하게 된다
	- 또한 Entities 컴포넌트를 테스트하면 Authorizer, Interactors까지 반드시 빌드하고 통합해야함
- 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기 어려하기 어려워짐

### 순환 끊기
- 순환을 끊기 위한 두 가지 주요 메커니즘
	- 의존성 역전 원칙을 적용
	- Entities, Authorizer가 모두 의존하는 새로운 컴포넌트 생성 -> 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킴

### 흐트러짐(Jitters)
- 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다
- 컴포넌트 구조 변경에 따른 의존성 구조에 순환이 발생하는지 항상 관찰해야 한다

## 햐향식(top-down) 설계
>[!important]
>컴포넌트 구조는 하향식으로 설계될 수 없다.
>컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다

- 컴포넌트 의존성 다이어그램
	- 애플리케이션의 긴으을 기술하는 일과는 거의 관련이 없음
	- 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다
- 의존성 구조와 관련된 최우선 관심사는 변동성을 격리하는 일
	- 자주 변경되는 컴포넌트로 인해 변경이 없었다면 안정적이었을 컴포넌트가 영향받는 일을 원하지 않는다
	- 컴포넌트 의존성 그래프는 자주 변경되는 컴포넌트로부터 안정적이며 가치가 높은 컴포넌트를 보호하려는 아키텍트가 만들고 가다듬게 된다
- 아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도하면 상당히 큰 실패를 맛볼 수 있다
	- 공통 폐쇄에 대해 그다지 많이 파악하지 못하고 있고, 재사용 가능한 요소도 알지 못하며, 컴포넌트를 생성할 때 거의 확실히 순환 의존성이 발생할 것이다
	- **따라서 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야한다**

## SDP : 안정된 의존성 원칙
>[!important]
>안정성의 방향으로 (더 안정된 쪽에) 의존하라
- 설계는 가변적이므로 공통 폐쇄 원칙을 준수함으로써 컴포넌트가 다른 유형의 변경에는 영향받지 않으면서도 특정 유형의 변경에만 민감하게 만들 수 있다
- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안된다

### 안정성
- 소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다
	- 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라고 볼 수 있다

### 안정성 지표
- 안정성 지표 측정 방법
	- 컴포넌트로 들어오고 나가는 의존성의 개수 세기
		- Fan-in
			- 안으로 들어오는 의존성
			- 컴포넌트 내부의 클래스에 의존하는 컴포넌트 외부의 클래스 개수
		- Fan-out
			- 바깥으로 나가는 의존성
			- 컴포넌트 외부의 클래스에 의존하는 컴포넌트 내부의 클래스 개수
		- *I*
			- I = Fan-out / (Fan-in + Fan-out)
			- I가 0이면 최고로 안정된 컴포넌트이고 1이면 최고로 불안정한 컴포넌트
		- C++에는 \#include 를 기준으로, Java는 import문을 기준으로 
### 모든 컴포넌트가 안정적이어야 하는 것은 아니다
- 모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능 -> 바람직한 상황이 아님
- 우리가 컴포넌트 구조를 설계할 때 기대하는 것은 불안정한, 안정된 컴포넌트 모두 존재하는 상태가 이상적이다

#### 추상 컴포넌트
- 추상 컴포넌트는 상당히 안정적이고, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적 대상

## SAP : 안정된 추상화 원칙
>[!important]
>컴포넌트는 안정된 정도만큼만 추상화되어야 한다

### 고수준 정책을 어디에 위치시켜야 하는가?
- 시스템에는 자주 변경해서는 절대로 안되는 소프트웨어도 있다. 고수준 아키텍처나 정책 결정과 관련된 소프트웨어들이 그 예
	- 따라서 시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야한다
	- 하지만 이로 인해 시스템 전체 아키텍처의 유연성이 떨어지고, 소스 코드 수정이 어려워진다
- **컴포넌트가 최고로 안정된 상태이면서 동시에 변경에 충분히 대응할 수 있는 방법은 개방 폐쇄 원칙을 적용하는 것이다**
	- 이 원칙을 준수하는 클래스는 추상 클래스이다

### 안정된 추상화 원칙
- 안정된 추상화 원칙
	- 안정성과 추상화 정도 사이의 관계를 정의
	- 안정된 컴포넌트는 추상 컴포넌트여야 하고, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말한다
	- 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다 -> 변경이 수월하게 하기 위해
- 안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 하고, 안정된 컴포넌트가 확장이 가능해지면 유연성을 얻게 되고 아키텍처를 과도하게 제약하지 않게 된다

### 추상화 정도 측정하기
- 추상화 정도 측정하기
	- nc : 컴포넌트의 클래스 개수
	- Na : 컴포넌트의 추상 클래스와 인터페이스의 개수
	- A : 추상화 정도. A = Na / Nc
	- A가 0이면 추상 클래스가 하나도 없는것, A가 1이면 컴포넌트가 오로지 추상 클래스만을 포함한다는 의미

### 주계열
- 안정성(I)과 추상화 정도(A) 사이의 관계
- 배제할 구역
	- 컴포넌트가 절대 위치해서는 안되는 영역

#### 고통의 구역
- 안정성, 추상화 정도도 모두 0인 상태
	- 매우 안정적이고 구체적
	- 너무 뻣뻣한 상태
	- 추상적이지 않으므로 확장할 수 없고, 변경이 어려움
	- 모두 0 주변 영역은 배제해야할 구역
- 고통의 구역에 위치하는 소프트웨어들
	- 데이터베이스 스키마
		- 변동성이 매우 높고, 극단적으로 구체적이며, 많은 컴포넌트가 여기에 의존
		- 스키마 변동 시 매우 고통스러움
	- 유틸리티 라이브러리
		- 이 라이브러리의 추상화 정도가 1이더라도, 변동성이 거의 없음

#### 쓸모없는 구역
- 안정성, 추상화 정도도 모두 1인 상태
	- 최고로 추상적이지만, 누구도 그 컴포넌트에 의존하지 않음 => 쓸모없는 컴포넌트

### 배제 구역 벗어나기
- 변동성이 큰 컴포넌트 대부분은 두 배제 구역으로부터 가능한 한 멀리 떨어뜨려야한다
	- 이는 안정성(1), 추상화 정도(0) 과 안정성(0), 추상화 정도(1)을 잇는 선분 => **주계열**
	- 이는 너무 추상적이지도 않고, 너무 불안정적이지도 않은 상태

### 주계열과의 거리
- D4 
	- 거리. D=|A+I -1|
	- 이 지표의 유효범위는 [0,1]
	- D가 0이면 컴포넌트가 주계열 바로 위에 위치
	- 1이면 주계열로부터 가장 멀리 위치한다는 의미
- D4를 이용하는 바업
	- D값이 0에 가깝지 않은 컴포넌트가 있다면 해당 컴포넌트를 재검토한 후 재구성
	- 각 컴포넌트의 D 값을 시간에 따라 그리고, 이 컴포넌트가 주계열에서 멀리 벗어난 원인을 시간들여 조사

