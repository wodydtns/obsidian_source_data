>[!important]
>컴포넌트의 정의
> - 배포 단위
> - 시스템의 구성 요소를 배포할 수 있는 작은 단위
> - 자바의 경우 jar 파일이 컴포넌트


## 컴포넌트의 간략한 역사
- **소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 "직접" 제어했다**
- 요즘의 프로그래머는 프로그램을 메모리의 어느 위치에 로드할지 고민할 필요가 거의 없지만, 프로그래밍 초창기에는 프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정해야 하는 사항 중 하나였다. 이 시절에는 프로그램의 위치가 한번 결정되면, 재배치가 불가능했다
- 구시대에 라이브러리 함수 접근 방법은 프로그래머가 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일
- 라이브러리는 바이너리가 아니라 소스 코드 형태로 유지되었다
- 이 시대에는 장치는 느리고 메모리는 너무 비싸서 자원이 한정적이라 이 접근 방법은 문제가 있었다
	- 컴파일러는 소스 코드 전체를 여러 번에 걸쳐서 읽어야 했지만, 메모리가 너무 작아서 소스 코들전체를 메모리에 상주시킬 수가 없었다. 
	- 결국 컴파일러는 느린 장치를 이용해서 소스 코드를 여러 차례 읽어야만 했다
	- **"함수 라이브러리가 크면 클수록 컴파일은 더 오래 걸렸다"**
- 컴파일 시간 단축을 위해 프로그래머는 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리
	- 함수 라이브러리를 개별적으로 컴파일하고, 함수 라이브러리에 대한 심벌 테이블을 생성한 후 이를 이용해 애플리케이션 코드를 컴파일
	- 애플리케이션을 실행해야 한다면 바이너리 함수 라이브러리를 로드한 다음 애플리케이션을 로드
![[Pasted image 20250119143242.png]]

- 애플리케이션이 커진 경우
	- 애플리케이션을 두 개의 주소 세그먼트로 분리
![[Pasted image 20250119143322.png]]
- **지속 불가능한 방법**

## 재배치성
-  **재배치가 가능한 바이너리**로 해결
	- 지능적인 로더를 사용해 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 방법
	- 로더는 재배치 코드가 자리할 위치 정보를 전달받고, 재배치 코드에는 로드한 데이터에서 어느 부분을 수정해야 정해진 주소에 로드할 수 있는지를 알려주는 플래그가 삽입
	- 플래그는 메모리의 시작 주소
	- **이제 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었다**
- 로더는 여러 개의 바이너리를 입력받은 후, 단순히 하나씩 차례로 메모리로 로드하면서 재배치하는 작업을 처리 => 프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었다
- 또한 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성 수정
	- 만약 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부 참조로 생성
	- 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성
	- 이렇게 **링킹 로더**(linking loader)가 탄생

## 링커
- 링킹 로더로 인해 프로그래머는 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다
- 하지만 프로그램이 커지면서 링킹 로더가 너무 느려졌다
- 이를 해결하기 위해 **"로드"와 "링크"가 두 단계로 분리**
	- 프로그래머는 링크 과정을 담당
	- 링커라는 별도의 애플리케이션으로 이 작업을 처리하도록 만듦
	- 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라짐
- 1980년 이후 하드웨어 발전 속도가 빨라져 많은 부분을 해결할 수 있게 되었고, 1990년 후반이 되자 프로그래머가 야심차게 프로그램을 성장시키는 속도보다 링크 시간이 줄어는 속도가 더 빨라지기 시작

