# 캡슐화
- 객체 지향 프로그래밍을 정의하는 요소 중 캡슐화를 언급하는 이유는 데이터와 함수를 수비고 효과적으로 캡슐화하는 방법을 제공하기 때문
- 구분선 바깥의 데이터는 은닉되고, 일부 함수만이 외부로 노출
- public, private , protected 키워드를 통해 불완전한 캡슐화를 보완하긴 했지만, 컴파일러가 헤더 파일에서 멤버 변수를 볼 수 있어야 했기 때문에 조치한 임시 방편
- 즉, OO가 강력한 캡슐화에 의존한다고 정의하기 어려움(강제성 부족)
# 상속
- OO 언어는 상속을 확실하게 제공
- 상속은 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과

# 다형성
- **다형성은 함수를 가리키는 포인터를 응용한 것**
- 함수에 대한 포인터를 직접 사용해 다형적 행위를 만드는 이 방식은 문제가 있는데, 함수 포인터 위험하다는 것 => 프로그래머가 특정 관례를 수동으로 따르는 방식
- 즉, 이들 포인터를 초기화하는 관례를 준수해야 한다는 사실을 기억해야하고, 포인터를 통해 모든 함수를 호출하는 관례를 지켜야한 다는 것을 의미

## 다형성이 가진 힘
- 다형성을 사용할 경우 외부의 조건(장치)와 무관하게 프로그램을 작성할 수 있다

## 의존성 역전
- 다형성을 안전하고 편리하게 적용할 수 있는 메커니즘이 등장하기 전 소프트ㅏ웨어는 main함수가 고수준 함수를 호출하고, 고수준 함수가 중간 수준 함수를 호출하고 중간 수준 함수가 다시 저 수준 함수를 호출하는 호출 트리형태 
- 이런 호출 트리에서 소스 코드 의존성의 방향은 반드시 제어흐름(flow of control)을 따르게 된다
- 이런 제약 조건으로 인해 소프트웨어 아키텍트에게 남은 선택지가 별로 없다. 즉, 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정된다
- 하지만 다형성을 통해 "의존성 역전"이 발생해 안전하고 편리하게 함수를 사용가능하다
	- 소스 코드에서 모듈이 "인터페이스"를 통해 함수를 호출하는 형태이고, 이 인터페이스는 런타임에는 존재하지 않는다. 
- OO 언어가 다형성을 안전하고 편리하게 제공한다는 것은 소스 코드 의존성을 어디에서든 역전시킬 수 있다는 의미이다
- 이는 OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다
	- 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 안흔다. 
	- **호출하는 모듈이든 아니면 호출 받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다**
	- 이를 통해 분리된 컴포넌트 또는 배포 가능한 단위(jar 파일 등)로 컴파일 할 수 있고, 이 배포 단위들의 의존성 역시 소스 코드 사이의 의존성과 같다
	- 즉, "업무 규칙"을 UI와 데이터베이스와는 독립적으로 배포할 수 있다 **(배포 독립성)**
