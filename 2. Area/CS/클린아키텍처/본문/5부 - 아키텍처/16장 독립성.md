# 유스케이스
- 시스템의 아키텍처는 시스템의 의도를 지원해야한다
	- 만약 시스템이 장바구니 애플리케이션이라면, 이 아키텍처는 장바구니와 관련된 유스케이스를 지원해야한다
- 시스템의 행위와 관련해 아키텍처가 열어 둘 수 있는 선택사항은 거의 없다
- 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 일 중 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준으로 알아볼 수 있게 만드는 것

# 운영
- 시스템의 운영 지원 관점에서 볼 때 아키텍처는 더 실질적이며 덜 피상적인 역할
	- 시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다
- 운영 작업을 허용한다는 여러 의미들
	- 시스템의 처리 요소를 일련의 작은 서비스들로 배열해, 서로 다른 많은 서버에서 병렬로 실행할 수 있게 만들어야함
	- 경량의 수많은 스레드가 단일 프로세서에서 같은 주소 공간을 공유하도록 만들어야함
	- 독립된 주소 공간에서 실행되는 소수의 프로세스만으로도 충분한 시스템
	- **뛰어난 아키텍트라면 모두 열어두어야 하는 선택사항 중 하나**

# 개발
>[!important]
>콘웨이의 법칙
>시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다

- **아키텍처는 개발환경을 지원하는 데 있어 핵심적인 역할**
- 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보해 개발하는 동안 팀들이 서로를 방해하지 않도록 해야한다

# 배포
- 아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다. 이 때 목표는 **'즉각적인 배포'이다**
	- 좋은 아키텍처는 수십 개의 작은 설정 스크립트나 속성 파일을 약간씩 수정하는 방식을 사용하지 않는다
	- 이런 아키텍처를 만들려면 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야 한다
	- 여기에는 마스터 컴포넌트도 포함되는데, 마스터 컴포넌트는 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 한다

# 선택사항 열어놓기
- 좋은 아키텍처는 컴포넌트 구조와 관련된 이 관심사들 사이에서 균형을 맞추고, 각 관심사 모두를 만족시킨다 => "매우 어려운 일"
	- 대부분의 경우 모든 유스케이스를 알 수 없고, 운영하는 데 따르는 제약사항, 팀 구조, 배포 요구사항도 알지 못하기 때문
- 몇몇 아키텍처 원칙은 구현하는 비용이 비교적 비싸지 않고, 관심사들 사이에서 균형을 잡는 데 도움이 된다
	- 이들 원칙은 시스템을 제대로 격리된 컴포넌트 단위로 분할할 때 도움이 되며, 이를 통해 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 둘 수 있게 해준다

# 계층 결합 분리
- 아키텍트는 단일 책임 원칙과 공통 폐쇄 원칙을 적용해 그 의도의 맥락에 따라 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다
- 업무 규칙도 서로 분리하고, 독립적으로 변경할 수 있도록 만들어야 한다

# 유스케이스 결합 분리
- 유스케이스 그 자체가 서로 다른 이유로 변경된다
	- 주문 입력 시스템에서 주문을 추가하는 유스케이스는 주문을 삭제하는 유스케이스와는 다른 속도, 다른 이유로 변경된다
- 유스케이스는 시스템의 수평적인 계층을 가로지르도록 자른, 수직으로 좁다란 조각
	- 각 유스케이스는 UI의 일부, 애플리케이션 특화 업무 규칙의 일부, 애플리케이션 독립적 업무 규칙의 일부, 그리고 데이터베이스 기능의 일부를 사용
	- **시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는, 얇은 수직적인 유스케이스로 시스템을 분할할 수 있다**
- 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있다

# 결합 분리 모드
- 유스케이스에서 서로 다른 관점이 분리되었다면, 높은 처리량을 보장해야 하는 유스케이스와 낮은 처리량으로도 충분한 유스케이스는 이미 분리되어 있을 가능성이 높다
- 유스케이스를 위해 수행하는 그 작업들(결합 분리)은 운영에도 도움이 된다
	- 하지만 운영 측면에서 이점을 살리기 위해선 결합을 분리할 때 적절한 모드를 선택해야 한다

# 개발 독립성
- 컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다

# 배포 독립성
- 유스케이스와 계층의 결합이 분리되면 배포 측면에서도 고도의 유연성이 생긴다
- 실제로 결합을 제대로 분리했다면 운영 중인 시스템에서도 계층과 유스케이스를 교체할 수 있다
	- 새로운 유스케이스를 추가하는 일은 시스템의 나머지는 그대로 둔 채 새로운 jar 파일이나 서비스 몇 개를 추가하는 정도로 단순한 일이 된다

# 중복
- 중복의 종류
	- 진짜 중복
		- 이 경우 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 한다
	- 거짓된 또는 우발적인 중복
		- 중복으로 보이는 두 코드의 영역이 각자의 경로로 발전한다면, 즉 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아니다
		- 데이터베이스 레코드와 동일한 형태의 뷰 모델을 만들어 각 항목을 복사하는 게 아니라, 데이터베이스 레코드를 있는 그대로 UI까지 전달하고 싶은 유혹을 받을 수 있으나, 이를 조심해야한다
# 결합 분리모드(다시)
- 소스 수준 분리 모드
	- 소스 코드 모듈 사이의 의존성을 제어할 수 있다
	- 이를 통해 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일하지 않도록 만들 수 있다
- 배포 수준 분리 모드
	- jar 파일, DLL, 공유 라이브러리와 같이 배포 가능한 단위들 사이의 의존성을 제어할 수 있다.
	- 이를 통해 한 모듈의 소스 코드가 변하더라도 다른 모듈을 재빌드하거나 재배포하지 않도록 만들 수 있다
	- 많은 컴포넌트가 여전히 같은 주소 공간에 상주하며, 단순한 함수 호출을 통해 통신할 수 있다
	- 어떤 컴포넌트는 동일한 프로세서의 다른 프로세스에 상주하고, 프로세스 간 통신, 소켓, 또는 공유 메모리를 통해 통신할 수 있다
	- 이 모드의 중요한 특징은 결합이 분리된 컴포넌트가 jar 파일, Gem 파일, DLL과 같이 독립적으로 배포할 수 있는 단위로 분할되어 있다는 점
- 서비스 수준 분리 모드
	- 의존하는 수준을 데이터 구조 단위까지 낮출 수 있고, 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있다
	- 이를 통해 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이게 된다(예, 서비스 또는 마이크로 서비스)
- **프로젝트 초기에는 어떤 모드가 최선인지 알기 어렵다**
- 현 시점에서 가장 인기 있어 보이는 한 가지 해결책은 단순히 '서비스 수준에서의 분리'를 기본 정책으로 삼는 것
	- 이 방식은 비용이 많이 들고, 결합이 큰 단위에서 분리된다는 문제가 있다
	- 또한 개발 시간 측면뿐 아니라 시스템 자원 측면에서도 비용이 많이 든다
- 좋은 아키텍처
	- 시스템이 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다
	- 나중에 상황이 바뀌었을 때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌릴 수도 있어야 한다
	- 소스 코드 대부분을 보호
	- 결합 분리 모드를 선택사항으로 남겨두어 배포 규모에 따라 가장 적합한 모드를 선택해 사용할 수 있게 만들어 준다

