- 클린 아키텍처 특징
	- 프레임워크 독립성
		- 아키텍처는 다양한 기능의 라이브러리를 제공하는 소프트웨어, 즉 프레임워크의 존재 여부에 의존하지 않는다
		- 이를 통해 이러한 프레임워크를 도구로 사용할 수 있으며, 프레임워크가 지닌 제약사항 안으로 시스템을 욱여 넣도록 강제하지 않는다
	- 테스트 용이성
		- 업무 규칙은 UI, 데이터베이스, 웹 서버, 또는 여타 외부 요소가 없이도 테스트 할 수 있다
	- UI 독립성
		- 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다
			- 예시 - 업무 규칙을 변경하지 않은 채 웹 UI를 콘솔 UI로 대체
	- 데이터베이스 독립성
		- RDB, Nosql 등으로 교체 가능
		- 업무 규칙은 데이터베이스에 결합하지 않는다
	- 모든 외부 에이전시에 대한 독립성
		- 실제로 업무 규칙은 외부 시계와의 인터페이스에 대해 전혀 알지 못한다![[Pasted image 20250216153712.png]]
# 의존성 규칙
- 위 그림에서 보통 안으로 들어갈수록 고수준 소프트웨어가 된다
- 바깥쪽 원은 메커니즘이고, 안쪽 원은 정책
- **의존성 규칙(Dependency Rule)**
	- **소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다**
- 내부 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다
	- 내부의 원에 속한 코드는 외부의 원에 선언된 어떤 것도 그 이름을 언급해서는 안된다
	- **함수, 클래스, 변수, 소프트웨어 엔티티 포함**
- 외부의 원에 선언된 데이터 형식도 내부의 원에서 절대로 사용해서는 안된다

## 엔티티
- 엔티티
	- 전사적인 핵심 업무 규칙을 캡슐화
	- 메서드를 가지는 개체이거나 일련의 데이터 구조와 함수의 집합일 수 있다
	- 단일 애플리케이션을 작성하고 있다면 엔티티는 해당 애플리케이션의 업무 객체
	- 운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안된다
## 유스케이스
- 유스케이스 계층의 소프트웨어
	- 애플리케이션에 특화된 업무 규칙을 포함
	- 시스템의 모든 유스케이스를 캡슐화하고 구현
	- 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다
	- 이 계층의 변경이 엔티티에 영향을 주어서는 안되다
	- 데이터베이스, ui 또는 여타 공통 프레임워크와 같은 외부 요소에서 발생하는 변경이 계층에 영향을 줘서도 안된다
	- 운영 관점에서 애플리케이션이 변경된다면 유스케이스가 영향을 받으며, 이 계층의 소프트웨어도 영향을 주게 될 것이다

## 인터페이스 어댑터
- 인터페이스 어댑터 계층
	- 일련의 어댑터들로 구성
	- 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식으로 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환
	- 이 계층은 GUI의 MVC 아키텍처를 모두 포괄
		- Presenter, View, Controller는 모두 인터페이스 어댑터 계층에 속함
		- 모델은 그저 데이터 구조
	- 이 계층에서 데이터를 엔티ㅣ와 유스케이스에게 가장 편리한 형식에서 영속성용으로 사용 중인 임의의 프레임워크(즉, 데이터베이스)가 이용하기 가장 편리한 형식으로 변환
	- 이 계층에는 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터 필요

## 프레임워크와 드라이버
- 프레임워크와 드라이버 계층
	- DB, 웹 프레임워크 같은 프레임워크나 도구들로 구성
	- 이 계층에서는 안쪽 원과 통신하기 위한 접합 코드 외에는 특별히 더 작성해야 할 코드가 많지 않음
	- 세부사항이 위치한 곳(웹, DB 등)

## 원은 네 개여야만 하나?
- 원의 개수는 더 많아질 수 있지만 **어떤 경우에도 의존성 규칙은 적용된다**
- 소스 코드 의존성은 항상 안쪽을 향하고, 안쪽으로 이동할수록 추상화와 정책의 수준은 높아진다
- 가장 바깥쪽 원은 저수준의 구체적인 세부사항으로 구성된다
- 안쪽으로 향할수록 소프트웨어는 점점 추상화되고 더 높은 수준의 정책들을 캡슐화한다 -> 가장 안쪽 원은 가장 범용적이며 높은 수준을 가진다

## 경계 횡단하기
- 제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우 -> 의존성 역전 원칙을 사용해 해결
	- 인터페이스와 상속 관계를 적절히 배치해, 제어흐름이 경계를 가로지르는 바로 그 지점에서 소스코드 의존성을 제어흐름과 반대가 되게 만듦
	- 예시
		- 유스케이스에 프레젠터를 호출해야할 경우
			- 직접 호출하는 것은 의존성 규칙에 위배
			- 유스케이스가 내부 원의 인터페이스를 호출하도록 하고, 외부 원의 프레젠터가 그 인터페이스를 구현하도록 만듦
## 경계를 횡단하는 데이터는 어떤 모습인가
- 경계를 횡단하는 데이터는 흔히 간단한 데이터 구조로 이루어져 있다
	- 기본적인 구조체나 간단한 데이터 전송 객체 등 원하는 대로 구성 가능
	- 함수를 호출할 때 간단한 인자를 사용해 데이터로 전달할 수도 있다
	- **중요한 점은 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달된다는 사실**

## 전형적인 시나리오
![[Pasted image 20250216155249.png]]
1. 웹 서버가 사용자로부터 입력 데이터를 모아 Controller로 전달 
2. Controller가 데이터를 POJO로 묶은 후, InputBoundary 인터페이스를 통해 UseCaseInteractor로 전달
3. UseCaseInteractor는 데이터를 해석해 Entities가 어떻게 동작할 지 제어하는 데 사용하고, DataAccessInterace를 사용해 Entities가 사용할 데이터를 데이터베이스에서 불러와 메모리로 로드
4. Entities가 완성되면 UseCaseInteractor는 Entities로부터 데이터를 모아 POJO인 OutputData를 구성
5. OutputData는 OutputBoundary 인터페이스를 통해 Presenter로 전달
6. Presenter의 역할은 OutputData를 ViewModel과 같이 화면에 출력할 수 있는 형식으로 재구성
7. ViewModel은 주로 문자열과 플래그로 구성되며, View에서는 이 데이터를 화면에 출력
8. OutputData는 Date 객체를 포함할 수 있지만, Presenter는 ViewModel을 로드할 때 Date 객체를 사용자가 보기 적절한 형식의 문자열로 포함
9. **의존성의 방향에 주목하라. 모든 의존성은 경계선을 안쪽으로 가로지며, 따라서 의존성 규칙을 준수한다**

