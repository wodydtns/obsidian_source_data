# 경계 횡단하기
- 런타임에 경계를 횡단한다
	- 경계 한쪽에 있는 기능에서 반대편 기능을 호출해 데이터를 전달하는 일
- 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있음
	- 소스 코드 모듈 하나가 변경되면, 이에 의존하는 다른 소스 코드 모듈도 변경하거나, 다시 컴파일해서 새로 배포해야할 지도 모르기 때문
- 경계는 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단

# 두려운 단일체
- 아키텍처 경계 중에서 가장 단순하며 가장 흔한 형태는 물리적으로 엄격하게 구분되지 않은 형테
	- 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 나름의 규칙에 따라 분리되어 있는 형태
	- 배포 관점에서 이는 단일체(monolith)라고 불리는 단일 실행 파일 형태 => 단일체는 경계가 드러나지 않는다
- 단일체 아키텍처는 거의 모든 경우 특정한 동적 다형성에 의존해 내부 의존성을 관리
	- 객체 지향 개발이 중요한 패러다임이 된 이유 => 만약 객체지향이 아니었다면 아키텍처의 결합도 분리를 위해 함수 포인터를 과도하게 사용하는 위험한 방식을 해야했을 것이고, 컴포넌트를 분리하려는 어떤 시도도 포기했을 것이다
- 가장 단순한 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출
	- 런타임 의존성, 컴파일타임 의존성 모두 같은 방향 -> 저수준 컴포넌트에서 고수준 컴포넌트로 향함
	- 예시
![[Pasted image 20250209192053.png]]
	- 제어 흐름이 왼쪽에서 오른쪽으로 경계를 횡단
- 고수준 클라이언트가 저수준 서비스를 호출해야 한다면 동적 다형성을 사용해 제어흐름과 반대 방향으로 의존성 역전
- 예시
![[Pasted image 20250209192400.png]]
- 이 방식은 정적 링크된 모노리틱 구조의 실행 파일이라도 규칙적인 방식으로 구조를 분리하면 프로젝트를 개발, 테스트, 배포하는 작업에 도움이 된다
	- 팀들은 서로의 영역에 침범하지 않은 채 자신만의 컴포넌트를 독립적으로 작업 가능
	- 고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지

# 배포형 컴퍼넌트
- 동적 링크 라이브러리는 아키텍처 경계가 물리적으로 드러나는 가장 단순한 형태
	- .NET DLL, 자바 jar 파일, 루비 gem, 유닉스 공유 라이브러리 등
	- 컴포넌트를 이 형태로 배포하면 따로 컴퍼일하지 않고 곧바로 사용 가능
	- 컴포넌트는 배포 가능한 형태로 전달
	- 이는 배포 수준 결합 분리 모드에 해당
	- 배포 수준의 컴포넌트는 단일체와 동일
	- 일반적으로 모든 함수가 동일한 프로세서와 주소 공간에 위치하며, 컴포넌트를 분리하거나 컴포넌트 간 의존성을 관리하는 전략도 단일체와 동일
- 단일체와 마찬가지로 배포형 컴포넌트의 경계를 가로지르는 통신은 함수 호출이라 매우 값싸다
- 동적 링크와 런타임 로딩으로 인해 최초의 함수 호출은 오래 걸릴 수 있지만, 대체로 이들 경계를 가로지르는 통신은 매우 빈번
# 스레드
- 단일체와 배포형 컴포넌트는 모두 스레드 활용 가능
- 스레드는 아키텍처 경계도 아니며 배포 단위가 아니고 실행 계획과 순서를 체계화하는 방법에 가까움
- 모든 스레드가 단 하나의 컴포넌트에 포함될 수도 있고, 많은 컴포넌트에 걸쳐 분산될 수도 있다

# 로컬 프로세스
- 로컬 프로세스
	- 주로 명령행이나 그와 유사한 시스템 호출을 통해 생성
	- 동일한 프로세서 또는 하나의멀티코어 시스템에 속한 여러 프로세서들에서 실행되지만, 각각이 독립된 주소 공간에서 실행
	- 종종 공유 메모리 파티션을 사용하기도 하지만, 일반적으로는 메모리 보호를 통해 프로세스들이 메모리를 공유하지 못하게 함
	- 소켓, 메일박스, 메시지 큐와 같이 OS에서 제공하는 통신 기능을 이용해 서로 텅신
	- 정적으로 링크된 단일체이거나 동적으로 링크된 여러 개의 컴포넌트로 구성
		- 정적으로 링크된 단일체 - 여러 모노리틱 프로세스가 같은 컴포넌트들을 가지고 있을 수 있다
		- 동적으로 링크된 여러 개의 컴포넌트 - 링크된 배포형 컴포넌트들을 서로 공유
- 로컬 프로세스 간 분리 전략
	- 단일체나 바이너리 컴포넌트의 경우 동일
	- 항상 고수준 컴포넌트를 향한다 => 로컬 프로세스에서 고수준 프로세스의 소스 코드가 저수준 프로세스의 이름, 물리 주소, 레지스트리 조회 키를 절대로 포함해서는 안 된다
- 로컬 프로세스 경계를 지나는 통신에는 운영체제 호출, 데이터 마샬링 및 언마샬링, 프로세스 간 문맥 교환 등
	- 비싼 작업 => 통신이 빈번하지 않게 제한해야 한다
# 서비스
- 서비스
	- 물리적 형태를 띠는 가장 강력한 경계
	- 프로세스, 일반적으로 명령행, 그와 동등한 시스템 호출을 통해 구동
	- 자신의 물리적 위치에 구애받지 않음
	- 서로 통신하는 두 서비스는 물리적으로 동일한 프로세서나 멀티코어에서 동작할 수도, 아닐 수도 있다
- 서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리므로, 주의를 기울여 가능하면 빈번하게 통신하는 일을 피해야한다
- 저수분 서비스는 반드시 고수준 서비스에 '플러그인'되어야 한다
- 고수준 서비스의 소스 코드에는 저수준 서비스를 특정 짓는 어떤 물리적인 정보(예를 들면, URI)도 절대 포함해서는 안 된다