>[!important]
>좋은 아키텍처라면 각 컴포넌트를 연격ㄹ할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 한다
>저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다


- 대다수의 주요 시스템에서 하나의 정책은 이 정책을 서술하는 여러 개의 조그만 정책들로 쪼갤 수 있다
- 소프트웨어 아키텍처를 개발하는 기술에는 정책을 신중하게 분리하고, 정책이 변경되는 야상에 따라 정책을 재편성하는 일도 포함
	- 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다
	- 서로 다른 이유로 혹은 다른 시점에 변경되는 정책은 다른 수준에 위치하며 반드시 다른 컴포넌트로 분리해야한다
- 아키텍처 개발은 재편성된 컴포넌트들을 비순환 방향 그래프로 구성하는 기술을 포함

# 수준
- 수준(level)
	- 입력과 출력까지의 거리
	- 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다
	- 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치![[Pasted image 20250209195058.png]]
	- 번역 컴포넌트는 이 시스템에서 최고 수준의 컴포넌트
	- 데이터 흐름과 소스코드 의존성이 항상 같은 방향을 바라보고 있는 것은 아님
- 좋은 아키텍처의 클래스 다이어그램![[Pasted image 20250209195547.png]]
	- 점선 안 경계는 최고 수준의 구성요소
	- ConsoleReader, ConsoleWriter 는 입출력 요소에 가까운 저수준
	- **고수준의 암호화 정책을 저수준의 입출력 정책으로부터 분리시킴**
		- 이런 격리를 통해 암호화 정책을 더 넓은 맥락에서 사용 가능
		- 입출력에 변화가 생겨도 암호화 정책이 거의 영향을 받지 않기 때문
- 고수준 정책은 저수준 정책에 비해 덜 빈번하게 변경되고, 보다 중요한 이유로 변경되는 경향이 있다
	- 예시 - 암호화 알고리즘 변경
- 저수준 정책은 더 빈번하게 변경되고, 보다 긴급성을 요하며, 덜 중요한 이유로 변경되는 경향
	- 예시 - 입출력 장치 로직 변경
	- 