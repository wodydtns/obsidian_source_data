# 서비스 아키텍처?
- 시스템 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의
	- 서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하는 것은 아님
	- 기능이 프로세스나 플랫폼에 독립적이 되게끔 서비스들을 생성하면 의존성 규칙 준수 여부와 상관없이 큰 도움이 되기도 하지만, 서비스 그 자체로는 아키텍처를 정의하지 않음

# 서비스의 이점?
## 결합 분리의 오류
- 시스템을 서비스들로 분리함으로써 얻게 되리라 예상되는 큰 이점 하나는 서비스 사이의 결합이 확실히 분리되는 것
	- 각 서비스들이 서로 다른 프로세스, 프로세서에서 실행 -> 서비스가 다른 서비스의 변수에 직접 접근할 수 없음
	- 하지만 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재
	- 서비스 사이를 오가는 데이터 레코드에 새로운 필드를 추가하면, 이 필드를 사용해 동작하는 모든 서비스는 반드시 변경이 필요함

## 개발 및 배포 독립성의 오류
- 서비스를 사용함에 따라 예측되는 또 다른 이점은 전담팀이 서비스를 소유하고 운영하는 것
	- 데브옵스 팀이 각 서비스를 작성하고, 유지보수하며 운영하는 책임을 질 수 있음
	- 이를 통해 개발 및 배포 독립성이 확장 가능한 것으로 간주
	- 하지만 극히 일부의 경우만 가능함
		- 대규모 엔터프라이즈 시스템은 서비스 기반 시스템 외에도, 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있음
		- '결합 분리의 오류'에 따르면 서비스라고 해서 항상 독립적으로 개발하고, 배포하며, 운영할 수 있는것은 아님 -> 데이터나 행위에서 어느 정도 결합되어 있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야함

# 야옹이 문제
- 횡단 관심사가 지닌 문제
	- 서비스들 자체가 결합되어 있어 독립적으로 개발하고, 배포하거나, 유지될 수 없다

# 객체가 구출하다
![[Pasted image 20250301140659.png]]
- 다형적으로 확장할 수 있는 클래스 집합을 생성해 새로운 기능을 처리하도록 함
	- **Rides, Kittens 컴포넌트에 신규 기능을 추가하고, 이 두 멈포넌트는 기존 컴포넌트들에 있는 추상 기반 클래스를 템플릿 메서드나 전략 패턴 등을 이용해 오버라이드**
	- Rides, Kittens 컴포넌트는 의죈성 규칙을 준수하며, 이 기능들을 구현하는 클래스들은 UI의 제어하에 Factories를 생성
	- Taxi UI는 변경이 불가피하지만, 그 이외의 것들은 변경할 필요가 없음

# 컴포넌트 기반 서비스
- 서비스는 SOLID 원칙대로 설계할 수 있으며 컴포넌트 구조를 갖출 수도 있다. 이를 통해 서비스 내의 기존 컴포넌트들을 변경하지 않고도 새로운 컴포넌트를 추가할 수 있다
- 자바의 경우 서비스를 하나 이상의 jar 파일에 포함된 추상 클래스들의 집합이라고 생각
	- 새로운 jar 파일을 구성하는 클래스들은 기존 jar 파일에 정의된 추상 클래스들을 확장해서 생성하게 되면, 새로운 기능 배포는 서비스를 재배포하는 문제가 아니라, 서비스를 로드하는 경로에 단순히 새로운 jar 파일을 추가하는 문제로 변함

# 횡단 관심사
- 아키텍처 경계가 서비스 사이에 있지 않으며, 오히려 서비스를 관통하고, 서비스를 컴포넌트 단위로 분할한다
- 모든 주요 시스템이 직면하는 횡단 관심사를 처리하려면, 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야한다![[Pasted image 20250301141358.png]]
