>[!important]
>여기에서 필요한 것은 다음과 같은 치환 원칙이다. S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램에서 p에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다


  ## 상속하도록 가이드하기

- Class
	- Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 대해 의존하지 않는다
	- 이들 하위 타입은 모두 License 타입을 치환할 수 있다
## 정사각형/직사각형 문제

- 그림
	- Square는 Rectangel의 하위 타입으로 적합하지 않음
	- Rectangle의 높이와 너비는 독립적으로 변경될 수 있음
	- Square의 높이와 너비는 반드시 함께 변경
	- User는 대화하고 있는 상대가 Rectangle이라고 생각하므로 혼동이 생길 수 있음
		- 이 위반을 막기 위해선 Rectangle이 실제로 Square인지 검사하는 메커니즘을 User에 추가하는 것이지만, User의 행위가 사용하는 타입에 의존이 발생함=
	- 즉 타입 치환 불가
![[Pasted image 20250112201328.png]]

## LSP와 아키텍처
- 객체 지향이 초창기에는 LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주
- 시간이 지나 LSP는 인터피에스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모
- 아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것

