## 1.1 성공한 인터넷 기업들과 비즈니스 민첩성

### 1.1.1 성공 사례: 아마존의 배포 속도

- 11.6초마다 배포된 아마존 쇼핑몰의 소스코드
- 빠른 배포 주기는 비즈니스의 민첩성을 간접적으로 보여주는 지표
### 1.1.2 클라우드 인프라의 등장
- 일반적인 인프라 구축 절차
    
    ![[Untitled 17 2.png|Untitled 17 2.png]]
    
- 최근 이런 문제는 클라우드 인프라의 등장으로 해결되어, 서비스 개발에 필요한 시스템 인프라를 준비하는 데 오랜 시간이 걸리지 않음

### 1.1.3 클라우드 인프라에 어울리는 애플리케이션의 조건

- 클라우드 인프라로 인해 필요할 시점에 필요한 만큼만 쉽고 빠르게 시스템 인프라 환경 준비가 가능함
- 스케일 업과 스케일 아웃
    - 스케일 업(Scale-up)
        - 기존 시스템 자체의 물리적 용량을 증가시켜 성능을 높이는 방법
    - 스케일 아웃(Scale-out)
        - 기존 시스템과 용량이 같은 다수의 장비를 병행 추가해 가용성을 높이는 방법
        - 사용량을 분산시켜 전체적으로 장애 없이 운영되게 함
    - 클라우드 친화 어플리케이션(Cloud Friendly Application)
        - 클라우드 환경에 올라갈 수 있게만 한 애플리케이션
    - 클라우드 네이티브 애플리케이션(Cloud native Application)
        - 독립적으로 분리되어 배포될 수 있는 조각으로 구성된 애플리케이션

## 1.2 마이크로서비스란 무엇인가?

### 1.2.1 모노리스와 마이크로서비스 비교
- 모노리스
    
    ![[Untitled 1 2.png|Untitled 1 2.png]]
    
    - 보통 3-Tier 구조인 사용자 인터페이스, 데이터베이스, 서버 쪽 애플리케이션 3개 부분으로 구성
    - 확장이 필요할 경우 반드시 전체 애플리케이션을 동시에 확장해야함
    - 시스템에 변경 발생 시 어래 개의 모노리스 시스템을 모두 전부 다시 빌드하고 배포해야함
    - 성능 감당을 위해 스케일 업을 통해 용량 증설 필요
- 마이크로서비스 기반 시스템
    
    ![[Untitled 2 2.png|Untitled 2 2.png]]
    
    - 서버가 여러 개의 조각으로 구성돼 각 서비스가 별개의 인스턴스로 로딩 ⇒ 여러 서비스 인스턴스가 모여 하나의 비지니스 애플리케이션을 구성
    - 각기 다른 저장소를 사용해 업무 단위로 모듈 경계가 명확하게 구분
    - 확장 시 특정 기능별로 독립적으로 확장할 수 있고, 특정 서비스를 변경할 필요가 있다면 해당 서비스만 빌드해서 배포하면 됨
    - 각 서비스가 독립적이라 서로 다른 언어로 개발하는 것도 가능하고, 각 서비스의 소유권을 분리해 서로 다른 팀이 개발 및 운영 가능

### 1.2.2 SOA와 마이크로서비스

- 모듈화 개념의 발전사
    - 구조적 방법론(structured) ⇒ 객체 단위로 모듈화하는 객체지향(object-oriented) 방법론 ⇒ 모듈화의 단위가 기능별로 재사용할 수 있는 좀 더 큰 컴포넌트가 되는 CBD(Component Based Development) ⇒ 컴포넌트를 모아 비즈니스적으로 의미 있고 완결적인 서비스 단위로 모듈화하는 SOA(Serivce Oriented Architecture)
    - MSA(Microserivce Artictecture)와 SOA와의 차이
        - 넓게 보면 여러 개의 응집된 비즈니스 서비스 집합으로 시스템을 개발하는 점에서 개념적으로 큰 차이가 없음
        - SOA는 구체적이지 않고 이론적이며 성공 사례가 많지 않은 반면 MSA는 클라우드 인프라 기술의 발전과 접목되 비즈니스 성공 사례가 있음
        - CBD/SOA 접근법에서는 애플리케이션은 모듈별로 분리했으나 데이터 저장소까지 분리하지 못해 데이터의 강한 결합으로 애플리케이션도 독립적으로 사용하기 힘들었음
        - MSA에는 있고 SOA에는 없는 두 가지 모듈화 방식
            1. 서비스별 저장소를 분리해 다른 서비스가 저장소를 직접 호출하지 못하도록 캡슐화한다. 즉, 다른 서비스의 저장소에 접근하는 수단은 API밖에 없다
            2. REST API 같은 가벼운 개방형 표준을 사용해 각 서비스가 느슨하게 연계되고 누구나 쉽게 사용할 수 있다
    - 마이크로서비스 개념도(마틴 파울러)
        
        ![[Untitled 3 2.png|Untitled 3 2.png]]
        
        - 각 서비스와 저장소는 다른 서비스 및 저장소와 격리돼 있으며, API를 통해서만 느슨하게 연계되어 독립적으로 확장 가능하고 하나의 서비스만 독립적으로 배포 가능
        - 특정 서비스를 구축하는 데 사용되는 언어나 저장소를 자율적으로 선택할 수 있는 방식 ⇒ PolyGlot

## 1.3 마이크로서비스를 위한 조건은 무엇인가?

### 1.3.1 조직의 변화 : 업무 기능 중심 팀

- Conway’s Law
    - 시스템을 개발할 때 항상 시스템의 모양이 팀의 의사소통 구조를 반영한다
- 마이크로서비스를 마드는 팀은 업무 기능 중심의 팀 ⇒ 업무 기능 중심 팀은 역할 또는 기술별로 팀이 분리되는 것이 아니라 업무 기능을 중심으로 기술이 다양한 사람들이 하나의 팀이 되어 서비스를 개발하는 것 ⇒ 여러 기능이 모여있다는 의미로 다기능 팀(Cross-Function Team)이라고도 부른다
- 이 팀은 자율적으로 담당 비즈니스에 관련된 서비스를 만들 뿐만 아니라 개발 이후에 운영할 책임도 진다
    
    ![[Untitled 4 1.png|Untitled 4 1.png]]
    

### 1.3.2 관리체계의 변화: 자율적인 분권 거버넌스, 폴리글랏

- 각 마이크로서비스팀은 빠르게 서비스를 만드는 것을 최우선 목적으로 두고 스스로 효률적인 방법론과 도구, 기술을 찾아 적용
    - 각 서비스 팀이 팀에 맞게 개발 언어 및 저장소를 선택하는 것을 각각 Polyglot programming, Polyglot Repository 라고 한다
        ![[Untitled 5 1.png|Untitled 5 1.png]]
### 1.3.3 개발 생명주기의 변화: 프로젝트가 아니라 제품 중심으로

- 기본 애플리케이션 개발 모델
    - 필요한 기술을 사용하는 인력들이 한시적으로 며어 장기간의 프로젝트를 통해 개발을 완료
    - 이후 운영 조직에 넘기는 방식 ⇒ 개발 조직과 운영 조직의 분리
    - 초기에 모든 일정을 계획
        - 요구사항 정의를 통해 개발 기능을 나열하고, 이에 따라 설계하고, 설계 완료 후 개발
        - 각 단계는 완료 데드라인이 있어 그 일정을 완료함으로써 최종 기능 제공
        - 프로젝트 기간 중 발생한 변경이나 새로운 아이디어 포용 불가
- 마이크로서비스 개발 모델
    - 비즈니스의 갑작스런 트렌드 변화에 유연하게 대처해야 하고 개발뿐만 아니라 운영을 포함한 소프트웨어의 전체 생명주기를 책임져야함
    - 소프트웨어를 완성해야 할 기능들의 집합으로 보는 것이 아니라 비즈니스를 제공하는 제품으로 바라보고, 우선 개발 뒤 반응을 보고 개선하는 방식으로 소프트웨어를 개발 ⇒ 애자일 개발 방식 채용
    - 요건에 변화에 따라 지속적으로 개선되고 발전시킬 제품으로 바라봄

### 1.3.4 개발 환경의 변화: 인프라 자동화

- 마이크로서비스팀의 단기간에 제품 개발 후 피드백을 받기 위한 배포에는 자동화가 반드시 갖춰져야한다 ⇒ 개발과 운영을 동시에 수행하는 DevOps를 궁극적으로 가능하게 하므로, 데브옵스 개발 환경이라 속칭
- 이를 인프라 자동화라 한다
- 빌드/배포 파이프라인
    
    ![[Untitled 6 1.png|Untitled 6 1.png]]
    
    - 소스코드 빌드 → 개발 환경 배포 → Staging 환경 배포 → 운영 환경 배포
    
> [!important]  
> 스테이징 배포 - 운영환경과 거의 동일한 환경으로 구성해 최종 운영환경으로 이관하기 전 여러 가지 비기능 요건(성능, 가용성, 보안, 유지보수성, 확장성 등)을 점검하는 환경  
- Infrastructure as Code
	- 코드를 이용해 인프라 구성부터 애플리케이션 빌드, 배포를 정의하는 것
	- 이것이 가능하면 수많은 하드웨어 리소스 설정을 동일하게 통제 가능하고, 상황에 따른 검증되고 적절한 설정을 쉽게 복제해 누구에게나 공유 가능해져 인프라를 매우 효율적으로 관리할 수 있음

### 1.3.5 저장소의 변화: 통합 저장소가 아닌 분권 데이터 관리

- Polyglot persistence 접근법
    
    - 서비스별로 데이터베이스를 갖도록 설계
    - 각 저장소가 서비스별로 분산돼 있어야 하며, 다른 서비스의 저장소를 직접 호출할 수 없고 API를 통해서만 접근해야한다는 의미
    - 비즈니스 처리를 위해 일부 데이터의 복제와 중복 허용이 필요 ⇒ **데이터의 비즈니스 정합성을 맞춰야 하는 데이터 일관성 문제 발생**
    - 데이터 일관성 처리를 위해 보통 two-phase commit 같은 분산 트랜잭션 기법 사용/ 
> [!important]
> [[two-phase commit Two-Phase Commit ]] 
>   
> 
- 각각 다른 서비스를 하나의 트랜잭션으로 묶으면 각 서비스의 독립성 침해, NoSQL 같은 2단계 커밋을 지원하지 않는 경우도 있음
- 그러므로 마이크로서비스는 데이터 일관성 문제를 해결하기 위해 두 서비스를 단일 트랜잭션으로 묶는 방법이 아닌 비동기 이벤트 처리를 통한 협업
- 비동기 이벤트 처리를 통한 협업
- 결과적 일관성(Eventual consisency)
- 두 서비스의 데이터가 일시적으로 불일치하는 시점에 있고 일관성이 없는 상태지만 결국에는 두 데이터가 같아진다는 개념
- 여러 트랜잭션을 하나로 묶지 않고 별도의 로컬 트랜잭션을 각각 수행하고 일관성이 달라진 부분은 체크해 보상 트랜잭션으로 일관성을 맞추는 개념
- 협업을 통한 비즈니스 일관성 확보 예시
![[Untitled 7 1.png|Untitled 7 1.png]]

1. 주문 서비스가 주문 처리 트랜잭션을 수행
	1. 동시에 주문 이벤트 발행
	2. 주문 이벤트가 메시지 큐로 전송
	3. 배송 서비스가 주문 이벤트를 인식
2. 배송 서비스가 주문 처리에 맞는 배송 처리 트랜잭션을 수행(비즈니스 일관성 만족)
3. 배송 처리 트랜잭션 중 오류로 트랜잭션 실패
	1. 배송 처리 실패 이벤트 발행
	2. 배송 처리 실패 이벤트가 메시지 큐로 전송
	3. 주문 서비스가 배송 처리 실패 이벤트를 인식
4. 주문 서비스는 주문 취소(보상 트랜잭션)을 수행(비즈니스 일관성 만족)

### 1.3.6 위기 대응 방식의 변화: 실패를 고려한 설계
- 내결함성(fault tolerance)
	- 시스템은 언제든 실패할 수 있으며, 실패해서 더는 진행할 수 없을 때도 자연스럽게 대응할 수 있도록 설계해야 한다
    - 댜양한 실패에 대비해 완벽히 테스트할 수 있는 환경을 마련하고, 시스템의 실패를 감지하고 대응하기 위해 실시간 모니터링 체계도 갖춰야한다
    - 예시 - 서킷 브레이커 패턴
        - 각 서비스를 모니터링하고 있다가 한 서비스가 다운되거나 실패하면 이를 호출하는 서비스의 연계를 차단하고 적절히 대응ㅇ하는 것
        - 넷플릭스의 chaos monky

  