## 3.1 비즈니스 로직은 어디에? - 관심사의 분리

- 비지니스 로직
    - 소프트웨어의 핵심
    - 보통 시스템의 목적인 비지니스 영역의 업무 규칙, 흐름, 개념을 표현하는 용어
    - 개발자의 역할은 문제 영역의 비즈니스 로직을 분석 및 이해하고 프로그래밍 언어라는 도구로 잘 표현하는 일
- 관심사 분리
    - 시스템의 각 영역이 처리하는 관심사가 분리되어 잘 관리되어야 한다는 의미
    - 이 원칙은 시스템을 이해하고 변경하기 쉽게 만들어줌
    - 모듈화와 계층화도 이 원칙에 기인
    - 비지니스 로직 영역과 기술 영역은 철저히 분리하는 것이 좋다
        - 기술과 비지니스 로직을 분리했을 때 복잡성이 낮고 유지보수성이 높아진다
- 애플리케이션의 유지보수성이 높다는 의미는 특정 개인에 의존하기보다 어느 누구라도 손쉽게 애플리케이션을 이해하고 유지보수할 수 있음을 의미한다

### 3.1.1 데이터베이스 중심 아키텍처의 문제점
- 데이터베이스 중심 아키텍처   
    - 특정 관계형 데이터베이스에 의존한 데이터 모델링을 수행한 다음 이 물리 테이블 모델을 중심에 두고 애플리케이션을 구현하기 위한 사고를 하는 방식
        
        ![[Untitled 38.png]]
        
    - 예시 - 스프링 프레임워크
        - Controller, Service, DB I.O, DTO 로 구성
        - Mybatis 사용
    - 문제점
        - 이 예시에서 비지니스 로직은 서비스에 존재해야 한다고 말하지만 서비스에 존재하게 될 로직은 흐름 제어 로직밖에 없음
        - 비지니스 개념과 규칙도 테이블과 SQL 질의에 존재
        - DTO는 질의를 통해 가져오는 정보 묶음(information holer)의 역할밖에 할 수 없다
        - 업무가 복잡해지면 복잡성을 제어하기 어려워짐
        - 업무 개념이 특정 저장 기술인 관계형 데이터베이스 테이블로 표현되고 업무가 복잡해질수록 업무 규칙이 SQL과 섞여 표현
        - 이 구조에선 대부분의 성능을 데이터베이스에 의존
        - 애플리케이션에서는 별로 할 일이 없어, 데이터가 늘어남에 따라 데이터베이스의 성능이 지속적으로 저하되고, 최적화를 위해 스케일 업과 질의문 튜닝에 몰두할 수 밖에 없음
        - 스케일 아웃해봐야 데이터베이스만 바쁘기 때문에 효과가 미비
    - 클라우드의 풍부한 자원 환경에서 애플리케이션 자체의 성능보다 애플리케이션의 확장성과 유연함이 더 중요 ⇒ 관심사 분리 원칙에 따라 결합돼있던 비지니스 로직 처리와 데이터 처리를 철저히 분리하는 것이 반드시 필요
    
## 3.2 헥사코날 아키텍처와 클린 아키텍처
### 3.2.1 레이어드 아키텍처

- 티어는 물리적 장비나 서버 컴퓨터 등의 물리층 , 레이어는 티어 내부의 논리적인 분할을 의미
	
	![[Untitled 39.png]]
	
- 전통적인 3계층 아키텍처
	- 프레젠테이션, 비지니스 로직, 데이터 액세스의 3계층
		
		![[Untitled 40.png]]
		
		- 각 레이어의 관심사
			- 프레젠테이션 : 화면 표현 및 전환 처리
			- 비지니스 로직 : 비지니스 개념 및 규칙, 흐름 제어
			- 데이터액세스 : 데이터 처린
- 레이어드 아키텍처 규칙
	- 상위 계층이 하위 계층을 호출하는 단방향성을 유지
	- 상위 계층은 하위의 여러 계층을 모두 알 필요 없이 바로 밑의 근접 게층만 활용
	- 상위 계층이 하위 계층에 영향을 받지 않게 구성해야 한다
	- 하위 계층은 자신을 사용하는 상위 계층을 알지 못하게 구성해야 한다
	- 계층 간의 호출은 인터페이스를 통해 호출하는 것이 바람직하다(구현 클래스에 직접 의존하지 않음으로써 약한 결합을 유지해야 한다)
- 인터페이스 호출을 통한 다형성 추구
	
	![[Untitled 41.png]]
	
	- 의존성 역전 원칙(DI)- 유연성이 극대화된 시스템에서 소스코드 의존성이 추상에 의존하며, 구체에는 의존하지 않아야 한다 - 만족
	- 개방 폐쇄 원칙 - 확장에는 열려 있어야 하고 변경에는 닫혀 있어야한다 → 개체의 행위는 확장할 수 있지만, 개체 변경은 불가하다 ⇒ 이 원칙을 위배
		- 모든 계층이 각기 자신이 제공하는 기능에 대한 추상적인 인터페이스를 직접 정의하고 소유하고 있는 구조 ⇒ 이 구조에선 제어 흐름이 상위 계층에서 하위 계층으로 흐르고, 소스코드의 의존서이 제어 흐름의 방향대로 따를 수 밖에 없다
	- **하위 계층의 유형이 추가되어 확장될 때 닫혀 있어야할 상위 계층이 하위 계층에서 정의한 특성에 영향을 받는다**
		- 데이터 액세스 계층의 인터페이스가 변경되면 비지니스 로직 계층의 클래스가 데이터 액세스 계층의 인터페이스에 의존해 변경의 영향을 받게 된다 ⇒ 상위 계층이 하위 계층에 의존하게 되는 상황
		- 이를 해결하기 위해 DI를 적용해 데이터 액세스 계층에서 정의한 인터페이스의 경계를 넘어 비지니스 로직 계층으로 옮김

### 3.2.2 헥사고날 아키텍처

![[Untitled 42.png]]

- 애플리케이션을 호출하는 다양한 시스템의 유형과 애플리케이션과 상호작용하는 다양한 저장소가 있어, 단방향 계층구조인 레이어드 아키텍처는 이를 지원하기 어려움
- 헥사고날 아키텍처
	- 앨리스테어 콕번이 제시한 아키텍처
	- ports and adapters architecture
	- 고수준의 비지니스 로직을 표현하는 내부 영역과 인터페이스 처리를 담당하는 저수준의 외부 영역으로 구분
	- 내부 영역
		- 순수한 비즈니스 로직을 표현하는 기술 독립적인 영역
		- 외부 영역과 연계되는 포트를 소유
	- 외부 영역
		- 외부에서 들어오는 요청을 처리하는 인바운트 어댑터
		- 비지니스 로직에 의해 호출되어 외부와 연계되는 아웃바운드 어댑터로 구성
	- 특징
		- 고수준의 내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않는다 ⇒ 내부 영역에 구성되는 포트를 통해서 가능하게 함
	- 포트
		- 인바운드
			- 내부 영역의 사용을 위해 표출된 API
			- 외부 영역의 인바운드 어댑터가 호출
			- 예시
				- REST API를 발행하는 컨트롤러
				- 웹 페이지를 구성하는 스프링 MVC 컨트롤러
				- 커맨드 핸들러
				- 이벤트 메시지 구독 핸들러 등
		- 아웃바운드 포트
			- 내부 영역이 외부를 호출하는 방법을 정의
			- 아웃바운드 어댑터가 아웃바운드 포트에 의존해 구현
			- 예시
				
				- DAO, 이벤트 메시지를 발행하는 클래스, \
				- 외부 서비스를 호출하는 프록시

### 3.2.3 클린 아키텍처

![[Untitled 43.png]]
- 엔티티 객체
	- 핵심 업무 규칙 & 데이터
	- 핵심 업무 규칙
		- 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차
		- 예시
			- 쇼핑몰의 물건을 사고 파는 규칙
			- 은행의 이자 계산 규칙
- 유즈케이스
	- 엔티티를 감싸는 객체
	- 자동화된 시스템을 사용하는 처리 절차를 기술
	- 애플리케이션에 특화된 업무 규칙을 표현
	- 엔티티 내부의 핵심 업무 규칙을 호출해 시스템을 사용하는 흐름을 담음
	- 엔티티같은 고수준의 영역이 저수준의 유스케이스 영역을 알게 해서는 안된다 ⇒ 엔티티는 간단한 객체여야하며, 프레임워크 데이터베이스 또는 기타 복잡한 것에 의존해서는 안되고, 유스케이스 객체를 통해서만 조작해야한다
- 세부사항
	- 입출력 장치, 저장소, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등
	- 세부 사항과 유스케이스의 관계를 의존 관계 역전의 원칙을 이용해 플러그인처럼 유연하게 처리해야한다
- **결합의 분리를 통해 테스트 용이성 및 개발 독립성, 배포 독립성을 강화 가능**

## 3.3 마이크로서비스의 내부 구조 정의
### 3.3.1 바람직한 마이크로서비스의 내부 아키텍처: 클린 마이크로서비스

- **마이크로서비스의 내부 구조를 정의할 때 반드시 고려해야하는 것은 마이크로서비스 시스템에서 정의해야 할 마이크로서비스의 내부 구조가 다양할 수 있다는 것 ⇒ 폴리글랏한 내부 구조를 가질 수 있기 때문**
- 다양한 아키텍처 패턴의 폴리글랏 마이크로서비스
    
    ![[Untitled 44.png]]
    
- 마이크로서비스 아키텍처에서 각 서비스는 각기 목표와 활용도에 따라 명확하게 분리되어야하고, 각 서비스 목적에 따라 적절한 개발 언어 및 저장소, 내부 아키텍처를 정의하는 것이 바람직하다
- 아키텍처가 지향하는 원칙
    - 지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮추게 해야 한다.
    - 업무 규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리하기 위해 노력한다
    - 세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 구분한다
    - 고수준 영역은 저수준 영역에 의존하지 않게 해야 하며, 저수준 영역이 고수준 영역에 의존하게 해야한다
    - 저수준 영역은 언제든지 교체, 확장 가능해야 하며, 이 같은 변화가 고수준 영역에 영향을 주어서는 안된다
    - 자바처럼 인터페이스 및 추상 클래스를 지원하는 언어의 경우 저수준 영역의 구체 클래스가 고수준 영역의 추상 인터페이스에 의존하게 하는 의존성 역전의 원칙을 적용한다
    - 인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수준의 어댑터가 이를 구현한다
- 마이크로서비스의 내부 구조 예시
    
    ![[Untitled 45.png]]
    

### 3.3.2 내부 영역 - 업무 규칙
- 서비스 인터페이스, 서비스 구현체, 도메인, 리포지터리 인터페이스, 도메인 이벤트 인터페이스, API 프락시 인터페이스가 존재ㅣ
- 서비스 인터페이스
> [!important]
> 추이 종속성 - 관계 속성 간에 성립되는 종속성예시 ) A가 B에 의존하고, B가 C에 의존하고, C가 A에 의존하는 상황  
- 외부 영역이 내부 영역에 대해 너무 많이 알지 못하게 하는 역할
- 서비스 인터페이스가 없다면 추이 종속성이 발생할 수 있다
- 리포지터리 인터페이스, 도메인 이벤트 인터페이스, API 프락시 인터페이스는 DI 원칙을 지원

- 트랜잭션 스크립트 패턴(Transaction Scripts)
    
    ![[Untitled 46.png]]
    
    - 비지니스 개념을 표현하는 도메인 객체가 행위를 갖고 있지 않아, 모든 비지니스 행위를 수행하는 책임은 서비스에 있다
    - 서비스가 비지니스 절차에 따라 절차적으로 도메인 객체를 이용해 모든 처리를 수행
    - 점점 도메인 객체는 정보 묶음의 역할만 수행하게 되고, 서비스는 비슷한 유스케이스의 경우 서비스에 중복되는 코드가 생겨날 수 있다 ⇒ 유지보수성이 떨어짐
- 도메인 모델 패턴(Domain Model)
    
    ![[Untitled 47.png]]
    
    - 도메인 객체가 데이터뿐만 아니라 비지니스 행위를 가지고 있으며, 도메인 객체가 소유한 데이터는 도메인 객체가 제공하는 행위에 의해 은닉
    - 도메인 객체는 각 비지니스 개념 및 행위에 대한 책임을 수행하고, 서비스는 비지니스 유스케이스를 구현하기 위해 서비스의 행위를 도메인 객체에 일부분 위임해 처리
    - 서비스의 책임들이 도메인에 분산되어 서비스가 비대해지지 않고, 서비스 메서드가 단순해짐
    - 도메인 주도 설계의 Aggregate 패턴을 적용할 수 있는 구조
    - 도메인 모델이 핵심이기 때문에 객체지향 지식에 대한 경험과 역량이 필요
    - 잘 만들어진 도메인 모델은 복잡한 비즈니스 로직을 처리하는 데 유용하며, 잘 정의된 도메인 모델은 코드의 양을 줄이고 재사용성도 높힌다

- 도메인 주도 설계의 애그리거트 패턴(Aggregate pattern)
    - 도메인 모델링의 문제
        - 도메인 모델리은 객체 간의 관계를 참조로 표현하는데, 참조로 정의할 경우 일대다 관계의 관계의 객체를 쉽게 사용할 수 있음
        - 업무가 복잡해지면 참조로 인한 다단계 계층 구조가 생기고 점점 참조 관계가 복잡해지고 무거워짐
        - 모델 내부의 경계가 불명확함
            - 예시
                - Many측에 있는 클래스의 총 개수를 One 측에 있는 클래스에서 집계하는 규칙
                - Many측에 클래스가 추가되면 One 측의 클래스에서 집계한 값을 수정해야함
                - Many측에 클래스만 추가하고 집계한 값을 수정하지 않는다면 비지니스 일관성이 깨짐
                - **도메인 모델이 커짐에 따라 이런 문제가 복잡해지고 꼬일 수 있다**
    - 애그리거트
        - [애그리거트 패턴 예시](https://www.notion.so/a8afe7b263af4ff2849eeb6547a3de69?pvs=21)
        - 1개 이상의 엔티티와 값 객체로 구성하고, 개념적으로 묶인 엔티티의 모음 전체
            
            ![[Untitled 48.png]]
            
        - 애그리거트의 규칙
            - 애그리거트 루트만 참조
            - 애그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해 참조해야 한다. 수정도 마찬가지다
            - 애그리거트 간 참조는 객체를 직접 참조하는 대신 기본 키를 사용한다
            - 기본 키를 사용하면 느슨하게 연관되고 수정이 필요하지 않은 애그리거트를 함께 수정하는 실수를 방지한다
            - 하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정한다

### 3.3.3 외부 영역 - 세부사항

- 외부 영역은 내부 영역의 서비스 인터페이스를 사용하는 인바운드 어댑터와 내부 영역에서 선언한 아웃바운드 인터페이스를 구현한 다양한 어댑터로 구성
- 어댑터는 플러그인처럼 언제든지 교체되거나 확장될 수 있어야한다 ⇒ **내부 영역이 먼저 정의된 후 외부 영역의 세부사항은 늦게 정의돼도 상관없도록 해야한다**
- 어댑터 예시
    
    ![[Untitled 49.png]]
    
- API 퍼블리싱 어댑터
    - REST API를 발행하는 인바운드 어댑터
    - 내부 영역의 서비스 인터페이스를 호출해서 REST 형식의 API를 제공
    - 명시적인 REST 리소스 명칭을 정의하고, 각 REST 메서드가 의도에 맞게 서비스 인터페이스를 호출
    - 엔티티를 직접 제공하지 않고, API 필요에 맞는 DTO를 생성해 엔티티를 변환 및 매핑해서 전달하는 것이 바람직
- API 프락시 어댑터
    - 다른 서비스의 API를 호출하는 아웃바운드 어댑터
    - 내부 영역에 정의된 프락시 인터페이스를 구현하며, 다른 서비스의 API는 REST API가 될 수도 있고 소켓이나 SOAP 프로토콜을 사용하는 API일 수 있음
- 저장소 처리 어댑터
    - ORM 또는 SQL 매핑 방식 사용
    - 일반적으로 트랜잭션 스크립트 패턴을 사용할 경우 SQL 매핑 방식 사용하고, 도메인 모델 패턴을 사용할 경우 ORM 방식을 많이 선택
- 도메인 이벤트 발행 어댑터
    - 도메인 이벤트는 어떤 사건에 따른 상태의 변경 사항
    - ‘주문됨’, ‘주문 취소됨’ 등의 명칭을 갖는 클래스로 구현
    - consumer에게 전달되기 때문에 도메인 이벤트 발행 어댑터를 통해 발행
    - 애그리거트 패턴을 적용할 경우 도메인 이벤트는 애그리거트에서 발생한 사건
    - 도메인 이벤트가 생성되는 위치는 내부 영역이며, 도메인 이벤트 발행 어댑터는 내부 영역의 이벤트 인터페이스를 구현해서 아웃바운드로 특정 메시지 큐나 스트림 저장소에 발행하는 역할을 수행
- 도메인 이벤트 핸들러
    - 외부에서 발행된 도메인 이벤트를 구독해서 내부 영역으로 전달하는 일을 수행
    - 이벤트 상태에 따라 적절한 서비스 인터페이스를 호출해서 내부 영역에 이벤트를 전달
