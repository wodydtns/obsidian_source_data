## 5.1.1 마이크로서비스를 도출하는 방법
- 각 도메인에서 비지니스가 규정하는 일하는 방식과 조직, 부서 체계가 이미 정의 돼 있고, 이런 부서는 이미 업무 처리에서의 응집성을 가지고 있고 타 부서와의 의존도는 낮을 것
- 업무 기능 분해
    - 비지니스 부서가 가진 역할, 처리 능력을 체계적으로 분해하는 것
    - 업무 흐름에 따라 업무를 최상위에서 하위까지 대, 중, 소의 크기로 분리하고 수행하는 일들을 체계적으로 정렬
- 이런 방식은 전체적인 대략의 비지니스를 이해할 때 유용하지만 서비스 간의 관계를 파악하거나 서비스의 구체 기능과 연관된 서비스가 관리할 독립적인 데이털르 식별하기에는 미흡

## 5.1.2 DDD의 바운디드 컨텍스트 기반 도출

- 마이크로서비스는 각 저장소를 독립적으로 보유하고, 각 데이터는 다른 서비스에서 직접 참조해서는 안 되는 특성이 있어, **마이크로서비스를 도출할 때 서비스가 소유권을 가진 데이터를 독립적으로 식별하는 것이 중요**
    - 서비스가 보유한 기능에 의해서만 접근 가능한(캡슐화) 데이터를 파악할 필요가 있다
- DDD에서는 데이터를 기능과 분리해 식별하지 않고, 문제 영역인 하위 도메인마다 별도의 도메인 모델로 정의
- 도메인 모델은 각 업무에 특화된 유비쿼터스 언어로 정의되고, 그 업무에 특화된 개념으로 구성
- 그럼 5.3 추가 필요

## 5.2 DDD에서의 설계
> [!important]  
> DDD의 전략적 설계는 비지니스 응집성이 있는 컨텍스트를 구분하고(바운디드 컨텍스트), 이 단위로 마이크로서비스를 식별하기 위한 단위로 삼는다면 매우 훌륭한 단위로 구성할 수 있다  

## 5.3 DDD의 전략적 설계
### 5.3.1 도메인과 서브도메인

- 서브도메인
    - 시스템 개발을 통해 해결하고자 하는 비지니스 도메인을 논리적으로 구분하는 개념
    - 많은 개념들이 하나로 엮인 복잡한 비지니스 도메인을 논리적으로 구분되는 분리된 하위 도메인
- 핵심 서브도메인
    - 다른 경쟁자와 차별화를 만들 비지니스 영역
    - 기업의 프로젝트 목록에서 높은 우선순위를 가진 영역이자 소프트웨어 개발에서 전략적으로 가장 큰 투자가 필요한 영역
- 지원 서브도메인
    - 비지니스에는 필수적이지만 핵심은 아닌 부분
    - 핵심 도메인을 성공시키기 위해 반드시 필요한 영역
- 일반 서브도메인
    - 비지니스적으로 특화된 부분은 아니지만 전체 비지니스 솔루션에는 필요한 부분
    - 기존 제품을 구매해서 대체할 수 있음
- 예시 - 예시 작성 필요(gpt)
    - 아마존 쇼핑몰
        - 핵심 서브 도메인
            - 상품 추천

### 5.3.2 유비쿼터스 언어와 도메인 모델, 바운디드 컨텍스트
- 그림 5.4 도메인 모델과 바운디드 컨텍스트 이미지 추가필요
- 유비쿼터스 언어
    - 세부 도메인에 특정 업무와 관련된 사람들 간에 자율적으로 정의되고 통용되는 개념
    - 특정 도메인 업무 개념을 표현하는 언어
    - 예시
        - 결제 도메인과 배송 도메인에서 ”고객“에 대한 의미 차이
            - 결제 도메인 - 고객은 결제자
            - 배송 도메인 - 구매 상품을 배송 받는 역할
- 도메인 모델
    - 도메인에 특화된 개념이 유비쿼터스 언어로 정의되었을 때, 이 개념들 간의 관계를 표현한 모델
    - 특정 비지니스 맥락에서 통용되는 개념들의 관계를 정의한 모형
    - 도메인과 관련된 업무를 수행하는 제품 책임자, 도메인 전문가, 개발자를 비롯한 모든 구성원들이 업무를 이해하는 기본 모형
    - 같은 컨텍스트를 다루는 이해관계자들은 도메인 모델에 정의된 언어로 업무 협의를 진행하고 개념을 발전시킴
    - 이 모델의 언어를 그대로 사용해 설계 산출물을 표현하고 소스코드에도 사용
- 바운디드 컨텍스트
    - 각 도메인 모델 간의 경계
- 바운디드 컨텍스트와 유비쿼터스 언어의 관계
    
    ![[Untitled 53.png]]

### 5.3.3 컨텍스트 매핑
- 컨텍스트 매핑
    - 컨텍스트 간의 의존 관계
    - 연관관계가 있는 두 컨텍스트 사이에 선을 그려 표시
        
        ![[Untitled 54.png]]
        
    - 컨텍스트 맵
        - 시스템을 구성하는 컨텍스트 간의 매핑 관계를 표시한 다이어그램
- 주요 컨텍스트 매핑 관계
    - 공유 커널(Shared Kernel)
        - 바운디드 컨텍스트 사이에 공통적인 모델을 공유하는 관계
        - 각 팀은 공유하는 모델에 서로 합의해야함
        - 공유하는 모델의 코드 빌드를 관리하고 테스트하는 것은 한 팀이 맡아 수행해야 한다
    - 소비자와 공급자(Customer-Supplier)
        
        ![[Untitled 55.png]]
        
        - 공급하는 컨텍스트를 상류(upstream), 소비하는 컨텍스트를 하류(downstream)으로 표시
        - 데이터의 흐름은 상류에서 하류로 이동
        - 공급자가 소비자가 원하는 기능을 제공해야한다
    - 준수자(Confirmist)
        - 소비자와 공급자와 유사하지만 상류 팀이 하류 팀의 요구를 지원하지 않거나 못하는 경우 사용
    - 충돌 방지 계층(ACL; Anti-Corruption Layer)
        - 하류 팀이 상류 팀의 모델에 영향을 받을 때 하류 팀의 고유 모델을 지키기 위해 번역 계층을 만드는 것
        - 이 계층은 둘 사이의 차이를 번역하고, 하류 모델의 독립성을 유지
        - 상류 모델의 변경 없이 하위 모델과 통합하기 위해 데이터를 변환하는 메커니즘을 구현한 것
        - 충돌 방지 계층
            
            ![[Untitled 56.png]]
            
        - 주로 레거시 시스템과 마이크로서비스를 통합하기 위해 사용
        - 충돌 방지 계층을 활용한 레거시 시스템 연동
            
            ![[Untitled 57.png]]
            
    - 공개 호스트 서비스(OHS : Open Host Service)
        - 바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의
        - 이 프로토콜은 하류의 컨텍스트가 상위 컨텍스트에서 제공하는 기능을 용이하게 사용할 수 있도록 공개
        - 보통 다른 컨텍스트에서 사용할 수 있는 공유된 API가 여기에 해당
        - 공개 호스트 서비스
            
            ![[Untitled 58.png]]
            
    - 발행된 언어(PL: Published Language)
        - 하류의 컨텍스트가 상류 컨텍스트가 제공하는 기능을 사용하기 위한 간단한 사용과 번역을 가능케 하는 문서화된 정보 교환 언어
        - XML, JSON 스키마로 표현될 수 있으며, 주로 공개 호스트 서비스와 짝을 이뤄 사용
    - 컨텍스트 맵
        - 하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하고 이들 간의 관계를 표현한 그림
        - 중요도에 따른 컨텍스트 매핑 관계
            
            ![[Untitled 59.png]]
            
        - 컨텍스트 맵 사례
            
            ![[Untitled 60.png]]
## 5.4 이벤트 스토밍을 통한 마이크로서비스 도출
- 이벤트 스토밍
    - 이벤트 중심으로 이해관계자들이 모여 브레인 스토밍하는 워크숍
    - 모든 이해관계자가 모여 서로가 가지고 있는 관점을 논의하며, 그 차이점을 이해하고 공유
    - 쉽고 간편한 도구를 사용해 빠른 시간 내에 지식 공유를 통한 협업
    - 이벤트 스토밍 개념
        
        ![[Untitled 61.png]]
### 5.4.1 이벤트 스토밍 워크숍 준비
- 워크숍 준비
    - 공간 - 깨끗한 벽이 있는 넓은 워크숍 공간
    - 참가자 - 고객, 도메인 전문가, 설계자, 개발자, 테스트 등 모든 이해관계자
    - 준비물 : A0 전지, 마커, 스티커, 스카치 테이프, 라인 테이프
    - 열린 분위기로 활동을 촉진하고 리딩할 수 있는 퍼실리테이터
- 워크숍 방식
    1. 넓은 공간에 여러 장의 흰색 전지를 이어 붙여 설계 공간을 마련
    2. 쉽게 접근 가능한 별도 공간에 다양한 색의 포스트잇과 기타 준비물을 올려놓는다
    3. 모든 참가자가 마커펜을 하나씩 들고 설계 공간을 바라보게 한다
    4. 퍼실리테이터의 지시에 따라 워크숍을 진행한다. 모든 활동은 타임박싱으로 집중해서 몰입하도록 유도한다
- 스티커 유형별 의미
    ![[Untitled 62.png]]![[Untitled 63.png]]

### 5.4.2 이벤트 스토밍 워크숍 진행
- 이벤트 스토밍 순서
    1. 도메인 이벤트 찾기
    2. 외부 시스템/외부 프로세스 찾기
    3. 커맨드 찾기
    4. 핫스폿 찾기
    5. 액터(사용자/역할) 찾기
    6. 애그리거트 정의하기
    7. 바운디드 컨텍스트 정의하기
    8. 컨텍스트 매핑하기
- 예시 - 쇼핑몰
    
    ![[Untitled 64.png]]
    
    - 판매자의 상품 등록 → 구매자가 상품 주문 → 판매자가 상품 발송
    
    1. 도메인 이벤트 찾기
        1. 시간의 흐름에 따라 시스템의 동작을 의미하는 도메인 이벤트를 도출
        2. 데이터나 데이터의 구조가 아닌 비지니스 흐름에서 발생한 **이벤트**에 초점을 두는 것이 중요
        3. 이벤트를 왼쪽에서 오른쪽으로 시간 흐름순으로 붙이되 이벤트가 연쇄적으로 발생하는 경우 바로 옆에 붙임
        4. 같은 시점에 비지니스 조건에 따라 대체적으로 발생할 수 있는 이벤트는 세로로 아래쪽에 같은 선상에 붙임
        5. 도메인 이벤트는 비지니스의 어떤 상태를 생성, 변경, 삭제하는 요소
        6. [회원 가입], [회원 정보 수정], [회원정보 삭제] - 도메인 이벤트 도출
    2. 외부 시스템 도출
        1. 레거시 시스템이나 외부 시스템과의 연계를 통해 업무의 흐름이 진행될 때는 이 프로세스의 이름을 핑크색 스티커에 작성해서 이벤트의 오른쪽 상단에 붙이고 화살표를 그려 이 외부 시스템을 호출한다는 것을 표시
            
            ![[Untitled 65.png]]
            
    3. 커맨드 도출
        1. 도메인 이벤트를 동작하게 하는 커맨드 찾기
        2. 커맨드명은 명령형으로 동사형으로 작성
        
        ![[Untitled 66.png]]
        
    4. 핫스폿 도출
        
        1. 의문 사항, 참여자들이 직접 결정하기 어려운 사항, 다른 부서나 외부에 문의가 필요한 내용을 보라색 스티커에 가정, 경고, 질문, 미결정 사항 등을 작성해서 문제가 되는 위치에 붙인다(핫스폿)
        
        ![[Untitled 67.png]]
        
    5. 액터 도출
        1. 커맨드를 실행하는 액터(Actor) 도출
        2. 액터는 사용자, 조직, 역할잘를 의미
        3. 액터는 추상적으로 식별하지 않고 비지니스를 수행하는 구체적인 역할을 고려해 도출
        4. [판매자] [ 구매자] [ 주문자 ] 가 예시
            
            ![[Untitled 68.png]]
            
        5. 액터 도출 후 식별한 커맨드와 이벤트 검토
            1. 판매자가 상품을 등록하면 [상품등록됨]이라는 이벤트가 발생함으로써 시스템이 동작
            2. 구매자가 상품 주문을 취소하면 [상품주문취소됨] 이벤트가 발생하고, 이어서 주문 취소된 상품의 재고를 변경하는 [재고변경됨] 이벤트가 발생함으로써 시스템이 동작
        6. 문장이 자연스럽지 않다면 자연스럽게 커맨드와 도메인 이벤트를 변경하거나 새로 도출
    6. 애그리거트 정의
        1. 커맨드와 도메인 이벤트 사이의 상단에 겹쳐서 붙임
            
            ![[Untitled 69.png]]
            
    7. 바운디드 컨텍스트 그리기
        
        1. 이름이 같거나 유사한 애그리거트를 완전히 다른 애그리거트와 구분해서 경계를 그리면 그것이 바운디드 컨텍스트
        2. 각 바운디드 컨텍스트에 이름을 부여하고, 이름은 각 바운디드 컨텍스트 내의 애그리거트 이름으로 정의
        3. 만약 컨텍스트 내 여러 개의 애그리거트 이름이 있는 경우 전체를 아우를 수 있는 대표 이름으로 결정
        
        ![[Untitled 70.png]]
        
        1. 정책 도출 및 연관관계 생각하기
            1. 정책은 이벤트 뒤에 따라오는 반응적인 비지니스 로직으로, 어딘가에 존재하는 커맨드를 동작하게 한다
            2. 정책 정의 방법 - [도메인 이벤트]할 때는 항상 [커맨드] 한다 ⇒ 정책은 도메인 이벤트와 커맨드 사이에 존재
            3. 예시
                1. 구매가 완료된 경우나 취소되는 경우 상품의 재고 수량이 변경되야 한다 ⇒ 정책
                2. 구매 바운디드 컨텍스트에서 [구입완료],[결제취소] 이벤트 후 [재고변경]이라는 정책으로 인해 [상품재고수정됨] 이벤트 발생을 위해 상품 바운디드 컨텍스트의 [상품재고수정] 커맨드가 호출
    8. 컨텍스트 매핑
        
        1. 컨텍스트 관계 작성 시 호출 관계 방향을 고려해야함
        2. 호출 시 호출 방식, 비동기 or 동기 호출을 판단해 작성
        3. 호출 방식은 데이터의 일관성 측면과 컨텍스트의 가용성 측면을 고려해 선택
        4. 반드시 실시간 정합성이 필요한 경우가 아니라면 비동기 방식의 연계를 고려하는 것이 좋음
        
        ![[Untitled 71.png]]
        
        1. 마이크로서비스 식별 질문
            1. 비지니스 측면 : 비지니스 프로세스를 수행하기 위한 하나의 맥락의 단위로 구분될 수 있는가
            2. 데이터 관점 : 마이크로서비스별로 분리된 데이터를 정의할 수 있는가
            3. 운영 조직 측면 : 하나의 팀이 독립적으로 운영 가능한 단위인가
            4. 배포 측면 : 독립적으로 배포 가능한 단위인가
            5. 변경 영향도 : 변경 시 영향을 받는 마이크로서비스가 존재하는가
            6. 클라우드/MSA 도입 목적 측면 : 도입을 통한 기대효과를 충분히 활용할 수 있는가\
        2. 마이크로서비스 상세 설계를 위한 입력물
            1. 커맨드, 도메인 이벤트, 애그리거트, 서비스 연계 및 정책, 핫스팟, API, 도메인 이벤트, 데이터, 리스크 등

## 5.5 마이크로서비스 상세설계

### 5.5.1 프런트엔드 모델링
- 프런트 아키텍처 정의
    - 사용자 요건에 적절한 아키텍처를 정의해야 한다.
    - 사용자 경험에 민감하게 반응하는 반응형 UI 지향 경향이 높아지고 있어, 이를 지원하는 프론트엔드 프레임워크가 다수 등장
    - 프론트엔드 아키텍처를 수립할 때 프론트엔드 프로그램의 패키지 구조도 정의해야 하는데, 이 때 마이크로서비스팀이 책임지고 있는 업무를 고려해 결정해야 한다.
- 표준 레이아웃 정의
    - 시스템의 목적과 기능을 고려해 화면의 표준 레이아웃을 정의해야한다,
    - 화면 유형을 정의할 때 웹, 앱, 모바일, 리포트 등 각 채널 특성에 고유한 화면 유형을 별도로 정의할 수 있다
- UI레이아웃 설계
    - 표준 유형을 기반으로 개별 UI 레이아웃을 정의한다. 각 기능을 만족할 UI를 정의하는 과정으로서, 화면에 입출력될 속성 정보를 식별하고 기능을 수행할 버튼 등을 정의
    - 보통 UI 레이아웃을 정의할 때 업무 흐름에 맞게 UI 흐름이 도출되고 흐름을 보여주는 문서를 작성하기도 하는데, 이를 UI 스토리보드라고 한다
- UI 디자인 및 UI 레이아웃 반영
    - 표준 화면 유형에 맞는 UI 디자인을 정의
    - 프론트엔드 엔지니어는 디자이너의 디자인 의도를 반영해 디자인 적용
- 이벤트 설계
    - 화면의 이벤트에 변화에 따라 백엔드 API를 호출하는 방식을 정의
### 5.5.2 백엔드 모델링
- 이벤트 스토밍의 커맨드 ⇒ 헥사고날의 인바인드 어댑터의 하나인 REST API
- 애그리거트 ⇒ 헥사고날의 내부 영역인 도메인 모델
- 도메인 이벤트 ⇒ 헥사고날 외부 영역의 아웃바운드 메시지 처리 어댑터의 처리 대상
- 외부 시스템 ⇒ 아웃바운드 어댑터가 호출해야 할 외부 연계 시스템으로 매핑
- API 설계
    - 헥사고날의 외부 영역
    - HTTP 프로토콜과 JSON 포맷을 사용하는 REST API가 표준처럼 사용되고 있음
- REST API의 개념
    - Representational State Transfer API
    - HTTP 프로토콜을 사용하는 대중적으로 광범위한 지지를 얻은 네트워크 기반 아키텍처 스타일
    - 아키텍처를 표현하는 구성요소
        - 자원(resource), 행위(verb), 표현(representations)
        - 예시 - “A라는 사용자를 생성한다”
            
            ```Plain
            HTTP POST https://example.com/users/
            {
            	"users": {
            			"name" : "홍길동"
            	}
            }
            ```
            
            ![[Untitled 72.png]]
            
            - 자원 - 사용자
            - 행위 - 생성한다
            - 표현 - A
- REST API 성숙도
    - 레오나르도 리처드슨의 REST API 성숙도 모델
        
        ![[Untitled 73.png]]
        
        - 레벨 0
            - REST API 의 메커니즘을 전혀 사용하지 않고 전통적인 원격 프로시저 호출 방식으로 HTTP 프로토콜만 사용
            - “/ProductService?Flag=create” 로 호출하는 방식
        - 레벨 1
            - URI에 개별적인 자원을 표현하는 것. 여러 기능을 사용하기 위해 하나의 URI에 요청하지 않고 요청이 필요한 대상을 특정
            - 상품 중 사과 정보를 제공하는 URI는 “products/apple”로서 사용자는 이처럼 특정 리스가 어떠한 정보를 제공하는지 인지할 수 있다
        - 레벨 2
            - 서비스의 기능을 처리하기 위해 약속된 HTTP 메서드를 사용하는 것
            - 가능한 한 약속된 HTTP 사용법에 가깝게 사용
            - 조회(GET), 추가(POST), 수정(PUT), 삭제(DELETE)로 각각 처리
        - 레벨 3
            - HATEOAS(Hypertext As The Engine Of Application State)
            - 특정 요청을 하게 되면 반환값에 기대했던 결과에 덧붙여 추가로 사용자가 그다음에 무엇을 할 수 있는지와 그것을 하기 위해 다룰 수 있는 URI 값을 보내준다. 즉, 사용자에게 좀 더 리소스를 탐색해서 활용할 수 있는 가능성을 제공
        - 추가
            
- API 설계 문서화
    
    ![[Untitled 74.png]]
    
    - 공식 문서 형식에 들어가야할 항목
        - 서비스명, API명, 리소스(URI)
        - 요청 매개변수, 요청 샘플
        - 응답 매개변수, 응답 샘플
    
      
    

## 5.6 도메인 모델링

- 도메인 모델 형태의 헥사고날 구조
    
    ![[Untitled 75.png]]
    
    - 비지니스가 복잡해질수록 비지니스 개념들을 잘 구조화할 수 있는 도메인 모델 구조가 효과적
- 트랜잭션 스크립트 형태의 헥사고날 구조
    
    ![[Untitled 76.png]]
    

### 5.6.1 DDD의 전술적 설계(도메인 모델링 구성요소)

- 도메인 모델을 구성하는 객체 구성 요소
    - 엔티티
        - 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체
        - 식별자는 고유하되 엔티티의 속성 및 상태는 계속 변할 수 있다
        - 도메인에서 개별성(individuality)이 있는 개념을 엔티티로 식별
        - 고유 식별자와 변화 가능성(mutability)이 엔티티와 값 객체를 구분하는 차이점
        - 예시
            
            ![[Untitled 77.png]]
            
    - 값 객체
        - 각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링함
        - 속성과 속성의 합에 의해 전체 개념이 부여
        - 개별 속성이 별개로 수정되지 않고 전체 객체가 한 번에 생성되거나 삭제되는 객체
        - 값 객체의 특성
            - 도메인 내의 어떤 대상을 측정하고, 수량화하고, 설명한다
            - 관련 특징을 모은 필수 단위로 개념적 전체를 모델링한다
            - 측정이나 설명이 변경될 때 완벽히 대체 가능하다
            - 다른 값과 등가성을 사용해 비교할 수 있다
            - 값 객체는 일단 생성되면 변경할 수 없다
    - 표준 타입
        - 대상의 타입을 나타내는 서술적 객체
        - 엔티티나 값 객체의 속성을 구분하는 용도로 사용
        - 만약 전화번호를 값 객체로 모델링 시 → 집 전화인지 핸드폰 전화, 회사 전화번호인지 구분 필요
        - 컨텍스트에 맞는 이해 가능한 유비쿼터스 용어로 정의하는 것이 바람직
        - 예시
            - 멤버십 등급 유형 - “VIP”,”GOLD”, “SILVER”
    - 애그리거트
        - 연관된 엔티티와 값 객체들의 묶음
        - 애그리거트 단위 == 트랜잭션의 기본 단위
        - 애그리거트 내에 있는 엔티티 중 가장 상위의 엔티티를 애그리거트 루트로 정하고, 애그리거트 루트를 통해서만 애그리거트 내의 엔티티나 값 객체를 변경
        - 보통 하나의 컨텍스트에 하나의 애그리거트가 식별되나 하나의 컨텍스트 안에 여러 개의 애그리거트가 존재할 수 있다
        - 이 경우 다른 애그리거트를 참조해야할 필요가 있다면 직접 참조하지 않고 참조할 애그리거트 루트의 식별자를 통해 참조 ⇒ 직접 참조할 경우 애그리거트 단위의 트랜잭션 처리도 힘들고 의존관계가 점점 복잡해질 것
        - 일반적으로 바운디드 컨텍스트를 마이크로서비스로 식별하게 되는데, 애그리거트 또한 별도의 마이크로서비스 후보가 될 수 있다
        - 식별자를 통한 애그리거트 간 참조
            
            ![[Untitled 78.png]]
            
        - 결과적 일관성을 통한 애그리거트 간 갱신
            
            ![[Untitled 79.png]]
            
    - 도메인 서비스
        - 도메인의 비지니스 로직 처리가 특정 엔티티나 값 객체에 속하지 않을 때 단독 객체를 만들어 처리하는 것
        - 도메인 서비스에서 상태를 관리하지 않고 행위만 존재
        - 도메인 로직을 처리할 때 엔티티나 값 객체와 함께 특정 작업을 처리하고 상태를 본인이 가지고 있지 않고 엔티티나 값 객체에 전달
    - 도메인 이벤트
        - 도메인 이벤트는 DDD 및 이벤트 스토밍에서 말하는 도메인 이벤트의 구현 객체
        - 서비스 간 정합성을 일치시키리 위해 단위 애그리거트의 주요 상태 값을 담아 전달되도록 모델링한다
        - 도메인 이벤트 발행 예시
            
            ![[Untitled 80.png]]
            
