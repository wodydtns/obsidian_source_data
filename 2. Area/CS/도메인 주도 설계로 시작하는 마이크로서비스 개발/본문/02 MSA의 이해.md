## 2.1 리액티브 선언: 현대 애플리케이션이 갖춰야 할 바람직한 속성들

- 리액티브 선언문 - 리액티브 선언의 4요소
    
    ![[Untitled 8 1.png|Untitled 8 1.png]]
    
    - 응답성(Responsive), 탄력성(Resilient), 유연성(Elastic), 메시지 기반(Message Driven)을 만족 시키는 시스템
    - 아키텍처 유연성이 공통적인 특성
    - 응답성(Responsive)
        - 사용자에게 신뢰성 있는 응답을 빠르고 적절하게 제공하는 것
    - 탄력성(Resilient)
        - 장애가 발생하거나 부분적으로 고장 나더라도 시스템 전체가 고장 나지 않고 빠르게 복구하는 능력
    - 유연성(Elastic)
        - 시스템의 사용량에 변화가 있더라도 균일한 응답성을 제공하는 것
        - 시스템 사용량에 비례해서 자원을 늘리거나 줄이는 능력
    - 메시지 기반(Message Driven)
        - 비동기 메시지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향하는 하는 것

## 2.2 강 결합에서 느슨한 결합의 아키텍처로의 변화

- 이전에는 아키텍처의 구성요소들을 벤더 제품에 의존하는 경우가 많았으나, 클라우드 환경하에 사용되는 오픈소스 또는 오픈소스 기반의 상용 제품들의 품질 및 기능 지원으로 높은 호환성을 제공해 자유도가 높아짐

## 2.3 마이크로서비스의 외부 아키텍처와 내부 아키텍처

- 마이크로서비스 아키텍처의 예시
    
    ![[Untitled 9 1.png|Untitled 9 1.png]]
    
    - 인프라 영역, 플랫폼 영역, 애플리케이션 영역에 있는 구성 요소 및 그것들의 관계를 정의하는 것을 MSA 외부 아키텍처라 한다
    - 외부 아키텍처는 마이크로서비스가 운영되는 환경을 정의
        - 인프라, 플랫폼, 마이크로서비스가 운영되는 애플리케이션 환경 포함
    - MSA 내부 아키텍처
        - 실제로 비지니스가 실행되는 비지니스 애플리케이션
        - 마이크로서비스가 제공하는 API, 비지니스 로직, 이벤트 발행, 데이터 저장 처리 등을 어떻게 구조화해야 하는가에 관한 내용

## 2.4 MSA 구성요소 및 MSA 패턴

- 아키텍처 패턴 - 크리스 리처드슨
    - MSA 구성요소 및 패턴의 유형

|패턴 유형|설명|
|---|---|
|인프라 구성요소|마이크로서비스를 지탱하는 하부구조 인프라를 구축하는 데 필요한 구성요소|
|플랫폼 패턴|인프라 위에서 마이크로서비스의 운영과 관리를 지원하는 플랫폼 차원의 패턴|
|애플리케이션 패턴|마이크로서비스 애플리케이션을 구성하는 데 필요한 패턴|

### 2.4.1 인프라 구성요소

- 퍼블릭 클라우드와 베어 메탈, 프라이빗 클라우드 환경
    - IaaS(Infrastructure as a Service), PaaS(Platform as a Service) 서비스를 통해 쉽고 편하게 이용할 수 있도록 제공
    - 마이크로서비스는 어떤 장비(VM, 베어 메탈)를 구분하지 않지만, 베어 메탈 장비로 마이크로서비스 애플리케이션을 구동한다면 마이크로서비스마다 베어메탈 장비를 구축해야하므로, 인프라의 유연한 확장/축소가 어려움
- VM과 컨테이너
    - VM과 컨테이너
        
        ![[Untitled 10 1.png|Untitled 10 1.png]]
        
    - 가상 머신의 경우 게스트 OS에서 운영체제 패치 설치나 관련 라이브러리 설치 같은 오버헤드가 지속적으로 발생하므로, 컨테이너 환경이 더 적합
    - 도커 컨테이너의 이점
        - 이식성
            - 어떤 호스트 커널이나 플랫폼 버전에 상관없이 도커만 실행할 수 있으면 사용 가능하며 동일하게 동작
        - 신속성
            - 크기가 작고 가볍기 때문에 빠르게 배포 가능하고, 문제 발생 시 수정할 필요 없이 새로 기동하면 됨
        - 재사용성
            - 동일한 환경을 재사용하기 쉽게 설정가능 해, 개발, 테스트, 스테이징, 프로덕트 환경을 동일한 환경으로 구축 가능
- 컨테이너 오케스트레이션
    - 정의 : 컨테이너의 자동 배치 및 복제, 장애 복구, 확장 및 축소, 컨테이너 간 통신, 로드 밸런싱 등의 컨테이너 관리 기술
    - Docker Swarm, Apache Mesos, kubernetes가 대표적
    - 쿠퍼네티스의 주요 기능
        - 자동화된 자원 배정(automatic binpacking) : 각 컨테이너가 필요로 하는 CPU와 메모리를 쿠버네티스에 요청하면 컨테이너를 노드에 맞춰 자동으로 배치
        - 셀프 치유(self-healing) : 컨테이너의 이상 유무를 Health Check해 실패 시 자동으로 교체하고 재스케줄링
        - 수평 확장(Horizontal scaling) : 일정 CPU 및 메모리 사용량을 초과하면 자동으로 확장
- 그 밖의 다양한 클라우드 인프라 서비스
    - 서비스 유형별 대표적인 클라우드 서비스
        - IaaS(Infrastructur as a Service)
            - 가상 머신, 스토리지, 네트워크 같은 인프라를 필요한 만큼 적시에 제공하는 서비스로서 사용자는 이러한 인프라를 이용해 개발 환경을 구성한 후 애플리케이션을 배포
            - AWS EC2(Elastic Compute Cloud), GCP, Azure VM
        - CaaS(Container as a Service)
            - 컨테이너 기반 가상화를 사용해 컨테이너를 업로드, 구성, 실행, 확장, 중지할 수 있는 서비스다. 애플리케이션을 바로 구동할 수 있는 환경을 제공한다는 점에서 PaaS와 유사하지만 다른 환경에도 이식 가능한 컨테이너 기반 가상화를 제공
            - Azure Kubernetes Service, Elastic Kubernates Service, Google Kubernate Engine, AWS ECS
        - PaaS(Platform as a Service)
            - 애플리케이션을 곧바로 개발, 실행, 관리할 수 있는 플랫폼 환경을 서비스 형태로 제공. IaaS 위에 실제로 애플리케이션이 실행될 수 있는 미들웨어나 런타임까지 탑재된 환경
            - Azure Web App, Google App Engine, Cloud Foundry, Heroku, AWS Elastic Beanstalk

### 2.4.2 마이크로서비스 운영과 관리를 위한 플랫폼 패턴

- 개발 지원 환경: 데브옵스 인프라 구성
    - 데브옵스(DevOps) : 개발과 운영이 분리되지 않은 개발 및 운영을 병행할 수 있는 조직 또는 그 문화
    - 수동 배포 절차
        
        ![[Untitled 11 1.png|Untitled 11 1.png]]
        
    - 자동 배포 절차
        
        ![[Untitled 12 1.png|Untitled 12 1.png]]
        
        - CI/CD
            - 지속적 통합(Continuous Integration)
                - 자동으로 통합 및 테스트하고 그 결과를 리포트로 기록하는 활동
            - 지속적 제공(Continuous Delivery, Deployment)
                - 실행 환경에 내보내는 활동
- 빌드/배포 파이프라인 설계
    - 정의
        - 빌드/배포되는 과정 동안 수행해야 할 태스크가 정의된 것
        - 통합 및 배포까지 이어지는 일련의 프로세스를 하나로 연계해서 자동화하고 시각화된 절차로 구축하는 것
    - 배포 파이프라인 절차
        
        ![[Untitled 13 1.png|Untitled 13 1.png]]
        
    - Infrastructure as Code
        - 인프라 구성을 프로그래밍 하는 것처럼 처리하는 것
        - Infrastructure as Code를 이용하면 배포 파이프라인 절차를 완벽하게 자동화할 수 있고, 대규모 인프라 관리를 수행할 수 있고, 코드이기 때문에 쉽게 공유 및 재사용이 가능
- 마이크로서비스 생태계와 운영 관리 요소의 탄생
    
    ![[Untitled 14 1.png|Untitled 14 1.png]]
    
- 경험으로 획득한 지혜: 마이크로서비스 관리/운영 패턴
    - 마이크로서비스 구축 시 발생하는 문제는 주로 시스템을 여러 개의 서비스로 구성하기 때문에 발생하는 문제
    - 넷플릭스 OSS, Spring Cloud
- 스프링 클라우드: 스프링 부터 + 넷플릭스 OSS
    - 넷플릭스가 공개한 오픈 소스인 줄, 유레카, 히스트릭스, 리본 등 + 스프링 부트
    - 아키텍처
        
        ![[Untitled 15 1.png|Untitled 15 1.png]]
        
        - 아키텍처 흐름
            1. 모든 마이크로서비스는 인프라에 종속되지 않도록 데이터베이스, 파일 등에 저장된 환경 설정 정보를 형상관리 시스템에 연계된 Config 서비스에서 가져와 설정 정보를 주입한 후 클라우드 인프라의 개별 인스턴스로 로딩
            2. 로딩과 동시에 ‘서비스 레지스트리’에 자신의 서비스명과 클라우드 인프라로부터 할당받은 물리 주소를 매핑해서 등록
            3. 클라이언트가 ‘API 게이트웨이’를 통해 마이크로서비스에 접근하고, 이때 API 게이트웨이는 적절한 라우팅 및 부하 관리를 위한 로드 밸런싱을 수행
            4. API 게이트웨이에서 클라이언트가 마이크로서비스에 접근하기 위한 주소를 알기 위해 ‘서비스 레지스트리’ 검색을 통해 서비스의 위치를 가져옴
            5. 동시에 API 게이트웨이는 클라이언트가 각 서비스에 접근할 수 있는 권한이 있는지 ‘권한 서비스’와 연계해 인증/인가 처리를 수행
            6. 이런 모든 마이크로서비스 간의 호출 흐름은 ‘모니터링 서비스’와 ‘추적 서비스’에 의해 모니터링 되고 추적
- 다양한 서비스의 등록 및 탐색을 위한 서비스 레지스트리, 서비스 디스커버리 패턴
    - **“프론트엔드 클라이언트가 여러 개의 백엔드 마이크로서비스를 어떻게 호출하는가 And 스케일 아웃을 통해 인스턴스가 여러 개로 복제됐다면 어떻게 부하를 분산할 것인가**”를 해결하기 위한 패턴
    - 클라이언트가 여러 개의 마이크로서비스를 호출하기 위해 최적 경로를 찾아주는 라우팅 기능과 적절한 부하 분산을 위한 로드밸런싱 제공
    - 넷플릭스 OSS의 Zuul(라우팅 기능), Ribbon(로드 밸런싱)
    - 라우터가 최적 경로를 탐색하기 위해 서비스 명칭에 해당하는 IP주소가 필요한데, 클라우드 환경 상 동적으로 변경되는 백엔드의 유동 IP를 알고 있어야한다 ⇒ 이 정보를 제3의 공간에서 관리하는 저장소가 있다 ⇒ 넷플릭스 OSS의 **Eureka**
    - 서비스 레지스트리, 디스커버리 흐름도
        
        ![[Untitled 16 1.png|Untitled 16 1.png]]
        
    - 서비스 레지스트리에는 업무 처리를 위한 마이크로서비스 & 관리 운영을 위한 기반 서비스의 주소도 함께 보관(Config 서비스, 모니터링 서비스, 추적 서비스)
    - 쿠버네티스의 경우 서비스 레지스트리, 디스커버리 기능을 자체 기능인 쿠버네티스 DNS 및 서비스로 제공
- 서비스 단일 진입을 위한 API 게이트웨이 패턴
    - 다양한 클라이언트가 다양한 서비스에 접근하기 위해 단일 진입점을 제공
    - API 게이트웨이 개념도
        
        ![[Untitled 17 1.png]]
        
        - 로드 밸런싱, 라우팅 시 필터를 두어 라우팅 전후에 각각 수행되는 선행 & 후행 처리, 에러 처리 등을 쉽게 구현 가능
    - API 게이트웨이가 제공하는 기능
        - 레지스트리 서비스와 연계한 동적 라우팅, 로드 밸런싱
        - 보안 : 권한 서비스와 연계한 인증/인가
        - 로그 집계 서비스와 연계한 로깅 : 예-API 소비자 정보, 요청/응답 데이터
        - Metic : 예 - 에러율, 평균/최고 지연시간, 호출 빈도 등
        - 트레이싱 서비스와 연계한 서비스 추적. 예 - 트래킹 ID 기록
        - 모니터링 서비스와 연계한 장애 격리(서킷 브레이커 때문)
    - API 게이트웨이 패턴은 Spring API Gateway Service로 구현 가능
    - 쿠버네티스 서비스, 인그레스 리소스로도 가능
- BFF 패턴(Backend for Frontend)
    - 정의 : 다양한 클라이언트를 위해 특화된 처리를 위한 API 조합이나 처리를 해결하는 방법
    - API 게이트웨이와 같은 진입점을 하나로 두지 않고 프론트엔드의 유형에 따라 각각 두는 패턴
    - 예시
        
        ![[Untitled 18 1.png]]
        
- 외부 구성 저장소 패턴
    - 외부 저장소
        - 각 마이크로서비스의 외부 활동 정보를 공동으로 저장하는 백업 저장소
        - config 원칙
            - 애플리케이션이 배포되는 환경이 매번 달라지기 때문에, 코드에서 사용하는 환경 설정 정보는 코드와 완전히 분리되어 관리해야 한다는 원칙
                - 클라우드에서 운영되는 애플리케이션은 특정한 배포 환경에 종속된 정보를 코드에 두면 안 된다
                    - 배포 환경 변깅 시 애플리케이션 또한 변경해야하기 때문
        - 데이터베이스 연결 정보, 배포 시 변경해야 할 호스트명, 백엔드 서비스의 연결을 위한 리소스 정보 등이 해당 환경 정보
    - Spring cloud config, 쿠버네티스 ConfigMap이 예시
        
        ![[Untitled 19 1.png]]
        
- 인증/인가 패턴
    - 중앙 집중식 세션 관리
        - 기존 모노리스 방식에서 가장 많이 사용했던 방식
        - 서버 세션에 사용자의 로그인 정보 및 권한 정보를 저장하고, 이를 통해 애플리케이션의 인증/인가를 판단
        - 마이크로서비스에서는 사용량에 따라 수평 확장 및 로드 밸런싱 처리 되기 때문에 세션 데이터가 소실될 수 있음
        - 마이크로서비스는 각자의 서비스에 세션을 저장하지 않고 공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자 데이터를 얻게 함
        - Redis, Memcached 사용
    - 클라이언트 토큰
        - JWT 토큰과 같은 토큰을 통해 사용자의 신원 정보를 서버로 전송해 서버에서 인가 처리
        - 클라이언트 토큰 흐름도
            
            ![[Untitled 20 1.png]]
            
            1. 브라우저가 서버에 사용자명과 패스워드로 인증 요청
            2. 서버는 인증 후 토큰을 생성하고 브라우저에 토큰의 사용자 정보인 인증/인가 정보를 포함해 전송
            3. 브라우저는 서버 리소스를 요청할 때 토큰을 함께 보낸다. 서버의 서비스는 토큰 정보를 확인 후 지원 접근을 허가
    - API 게이트웨이를 사요한 클라이언트 토큰
        - 사용자 인증 프로세스는 토큰 인증 프로세스와 유사
        - API 게이트웨이가 외부 요청의 입구로 추가
        - 인증/인가 처리를 위한 별도의 전담 서비스를 만들어 다른 서비스의 인증/인가 처리를 위임할 수 있다
        - API 게이트웨이와 인증 서비스를 활용한 클라이언트 토큰 흐름도
            
            ![[Untitled 21 1.png]]
            
            1. 클라이언트가 리소스 서비스에 접근 요청하면 API 게이트웨이는 인증 서비스에 전달
            2. 인증 서비스는 해당 요청이 인증된 사용자가 보낸 것인지(인증), 해당 리소스에 대한 접근 권한이 있는지(인가) 확인하고, 모두 확인하면 리소스에 접근 가능한 증명서인 액세스 토큰을 발급
            3. 클라이언트는 다시 액세스 토큰을 활용해 접근을 요청
            4. 각 리소스 서비스는 요청이 액세스 토큰을 포함하고 있는지 판단해서 리소스에 대한 접근 허용
- 장애 및 실패 처리를 위한 서킷 브레이커 패턴
    - 여러 서비스로 구성된 시스템에서 한 서비스가 장애 발생 시 장애가 발생한 서비스를 격리해서 유연하게 처리하는 방법
    - 서킷 브레이커 패턴의 흐름도
        
        ![[Untitled 22 1.png]]
        
        - 서비스 호출에 대한 연속 실패 횟수가 임계값을 초과하면 회로 차단기를 작동해 이후 서비스를 호출하려는 모든 시도를 실패하게 만듦
        - 폴백(fallback) 메서드를 지정해두면 장애 발생 시 폴백 메서드가 자연스럽게 처리 진행
- 모니터링과 추적 패턴
    - 스프링 클라우드에서는 히스트릭스 라이브러리 제공(Hystrix Dashboard)
        
        ![[Untitled 23 1.png]]
        
    - 분산 트레이싱 - 트위터의 Zipkin’
        
        ![[Untitled 24 1.png]]
        
- 중앙화된 로그 집계 패턴
    - ELK 스택
        
        ![[Untitled 25.png]]
        
        - Elasticsearch - 분석 엔진
        - Logstash - 서버 측 로그 집합기
        - Kibana - 로그 내역 시각화
    - 로그 집계 아키텍처
        
        ![[Untitled 26.png]]
        
- MSA 기술 변화 흐름
    
    ![[Untitled 27.png]]
    
    - 최초에는 넷플릭스 OSS, 스프링 클라우드를 이용해 각각의 서비스를 별도로 만들어 해결
    - 이후 여러 문제의 해결책을 한번에 해결해주는 쿠버네티스, OpenShift 등장
- 서비스 메시 패턴
    - 서비스 메시 개념도
        
        ![[Untitled 28.png]]
        
        - 서비스 메시는 인프라 레이어로 서비스 간의 통신을 처리
        - 구글의 Istio
            - 애플리케이션이 배포되는 컨테이너에 완전히 격리되어 별도의 컨테이너로 배포되는 Sidecar 패턴을 적용해 서비스 디스커버리, 라우팅, 로드 밸런싱, 로깅, 모니터링, 보안, 트레이싱 등의 기능 제공
            - 쿠버네티스에 탑재되어 서비스 메시 기능 지원
        - 서비스 메시의 통신
            
            ![[Untitled 29.png]]
            
            - 컨트롤 플레인 기능으로 중앙에서 통제
            - 쿠버네티스의 컨테이너 단위인 Pod에 서비스 컨테이너와 사이드카 구현체인 Enovy 컨테이너가 함께 배포
            - 주요 기능
                - 트래픽 관리 - 동적 라우팅, 로드 밸런싱
                - 보안 - 보안 통신 채널(TLS), 인증/인가/암호화
                - 관측성 - 메트릭, 분산 트레이싱, 로깅
            - 스프링 클라우드 및 넷플릭스 OSS와의 차별점
                - 애플리케이션 코드의 변경이 거의 없다. 스프링 클라우드나 넷플릭스 OSS 기반은 비지니스 로직과 함께 코드로 표현돼야 하지만, Istio는 완전히 사이드카로 격리되며, yaml 파일과 같은 설정 파일에 의해 정의
                - Polyglot 애플리케이션도 지원한다. 자바 외의 언어도 지원
                - Istio는 쿠버네티스와 완벽하게 통합된 환경 지원

### 2.4.3 애플리케이션 패턴
- UI 컴포지트 패턴 또는 마이크로 프론트엔드
    - 모노리식 UI로 구현할 경우 백엔드가 경험했던 문제(독립적인 기능 변경 및 배포 불가, 독립적인 기능 확장 불가)를 동일하게 겪을 수 있다
    - UI 컴포지트 패턴 또는 마이크로 프론트엔드는 백엔드 마이크로서비스처럼 기능별로 분리하고 이를 조합하기 위한 frame 형태의 부모 창을 통해 각 프론트엔드를 조합해서 동작하게 한다
    - 이 부모 서비스는 틀만 가지고 있고, 실제 각 기능 표현은 마이크로 프론트엔드 조각이 구현하게 한다
    - 아마존 쇼핑몰의 컴포지트 UI 사례
        
        ![[Untitled 30.png]]
        
- 마이크로서비스 통신 패턴
    - 동기 통신 방식
        - 다양한 클라이언트 채널 연계나 라우팅 및 로드 밸런싱을 원활하게 하기 위한 방법으로 API 게이트웨이 설정
        - 예시
            
            ![[Untitled 31.png]]
            
        - 이 방식으로 사용 시 백엔드에서 서비스에 문제가 생기면 요청을 보낸 서비스가 반응이 올 때까지 기다리게 되고, 반응이 오지 않으면 계속 기다리면서 재호출 하는 문제 발생
    - 비동기 통신 방식
        - 메시지 기반의 비동기 호출
            - 완결성을 보장할 수 없어 이를 위한 메커니즘이 필요
            - Apache Kafka, RebbitMQ, ActiveMQ 같은 메시지 브로커 활용
            - 이 방식에선 메시지를 보내는 producer와 메시지를 가져다 처리하는 consumer가 서로 직접 접속하지 않고 메시지 브로커에 연결
            - 여러 서비스에서 전달한 메시지를 처리하는 메시지 브로커 자체에 부하가 생길 수 있어, 메시지 브로커는 메시지 처리 규모에 따라 확장이 가능
        - 이 방식은 메시지 브로커에 의해 중계되기 때문에, 서로 통신하는 서비스들이 물리적으로 동일한 시스템에 위치할 필요가 없고, 서로 프로세스를 공유할 필요도 없으며, 동일한 시간대에 동작하지 않아도 무관 ⇒ 서비스 요구에 따라 늘어나거나 줄어들 수 있는 탄력성이 높은 클라우드 플랫폼 환경에서 서비스가 다운됐을 때 또는 시스템을 더 확장해야 할 때 사용할 수 있는 효과적인 방법
    - 비동기 방식의 이벤트 기반 아키텍처
        
        - 비동기 방식을 이용해 느슨한 연계를 지향하는 아키텍처
        - Event Driver architecture
        - 분산 시스템 간 발신자가 이벤트를 생성 및 발행(publish)하고, 해당 이벤트를 필요로 하는 수신자에게 전송하면 이벤트를 subscribe 하고 수신자가 이벤트를 받아 처리하는 형태의 시스템 아키텍처
        - **이벤트 == ‘상태 변화’ ⇒ 어떤 사앹의 변경에 따른 반응으로 동작**

- 저장소 분리 패턴
    - 각 마이크로서비스는 각자의 비지니스 처리를 위해 데이터를 직접 소유해야 한다는 개념
    - 자신이 소유한 데이터는 다른 서비스에 직접 노출하지 않고 각자가 공개한 API를 통해서만 접근 가능(정보 은닉)
    - 저장소가 격리되어 있어 각 저장소를 자율적으로 선택 가능(폴리글랏 저장소)
    - 이런 제약이 데이터를 통한 변경의 파급 효과를 줄여 서비스를 독립적으로 만듦
- 분산 트랜잭션 처리 패턴
    
    - Saga 패턴
        - 각 서비스의 로컬 트랜잭션을 순차적으로 처리하는 패턴
        - 여러 개의 분산된 서비스를 하나의 트랜잭션으로 묶지 않고 각 로컬 트랜잭션과 보상 태랜잭션을 이용해 비지니스 및 데이터의 정합성을 맞춘다
        - 예시
            
            ![[Untitled 32.png]]
            
        - 보상 트랜잭션
            - 다른 트랜잭션의 결과에 따라 롤백이 필요한 경우 그 서비스의 앞선 다른 서비스에서 처리된 트랜잭션을 되돌리는 트랜잭션
    - 사례 - 사가 패턴 사례
        
        ![[Untitled 33.png]]
        
        1. 주문 처리가 시작되면 주문 서비스는 가주문(가짜 주문)을 생성하고 주문자 정보가 담긴 ‘주문 생성’ 이벤트를 발행하고 트랜잭션 종료
        2. 고객 서비스가 ‘주문 생성’ 이벤트를 확인한 뒤 다음 처리를 수행
            1. 이벤트에 존재하는 주문자 정보로 고객의 신용한도를 조회해 신용한도가 충족되면 ‘신용 승인됨’ 이벤트 발행
            2. 신용한도가 충족되지 않는다면 ‘신용한도 초과됨’ 이벤트 발행
        3. 주문 서비스는 고객 서비스가 발행한 이벤트를 확인해 다음 처리를 수행
            1. 고객 서비스가 발행한 이벤트가 ‘신용 승인됨’인 경우 주문 승인 처리
            2. ‘신용한도 초과됨’ 이벤트인 경우 보상 트랜잭션인 주문 처리 취소를 수행
    
    - 데이터 일관성에 대한 생각의 전환: 결과적 일관성
        - 모든 비지니스 규칙들이 실시간으로 데이터의 일관성을 보장해야하는가?
            - 대규모 이벤트가 발생하면, 처리 지연에 따라 대기하는 상태가 발생할 수 있다
            - 비지니스 관점에서 보면 대기하는 이벤트를 fail 처리하는 것보다 대기 상태로 유지시키는 것이 더 나을 수 있다 ⇒ **반드시 실시간성을 요구하는 것은 아니다**
        - 결과적 일관성(eventual consistency)
            - 고가용성 극대화
        - 비동기 통신과 사가 패턴을 적용한 예시
            
            ![[Untitled 34.png]]
            
            1. 가주문이 생성되고 ‘가주문됨’ 이벤트를 발행. 주문은 독립적 로컬 트랜잭션이기 때문에 끊임없이 받을 수 있음. 주문이 몰릴 경우 주문 서비스만 확장해서 가용성을 높일 수 있다
            2. ‘가주문됨’ 이벤트는 메시지 브로커에 비동기로 전송
            3. 결제 서비스는 발행된 ‘가주문됨’ 이벤트를 확인하고 대금 결제 트랜잭션을 수행하고 ‘결제 처리됨’ 이벤트를 발행
            4. 이메일 서비스는 ‘결제 처리됨’ 이벤트를 확인하고 주문 결제 완료 이메일을 사용자에게 발송
            5. 주문 서비스는 ‘결제 처리됨’ 이벤트를 확인하고 가주문으로 처리됐던 주문을 최종 승인. ‘최종 주문 완료됨’ 이벤트 발행.
            6. 이메일 서비스는 주문 서비스가 발행한 ‘최종 주문 완료됨’ 이벤트를 확인해 최종적으로 주문이 완료됐다는 이메일을 사용자에게 발송
            7. 각 서비스는 각기 작업을 수행하다 오류가 발생하면 ‘실패 이벤트’를 발행해 다른 서비스가 비지니스 정합성을 맞추게 함
            8. 이때 별도로 메시지 큐에 쌓이는 이벤트들을 모니터링 서비스와 연계해 모니터링하고 추적해 전체적인 비지니스 정합성 여부를 관리자가 확인할 수도 있다
- 읽기와 쓰기 분리: CQRS 패턴
    - 서비스 인스턴스를 스케일 아웃해 여러 개로 실행한 경우 데이터 읽기/수정 작업으로 인한 리소스 교착상태가 발생할 수 있다
    - CQRS - Command Query Responsibility Segregation
        - 명령 조회 책임 분리
        - 일반적인 비지니스 모델에서 조회 요청 > 입력,수정,삭제 요청 ⇒ 서비스 내 모든 기능을 넣어두면 요청 빈도 증가에 따라 다른 명령 기능도 확장해야하므로 비효율적
        - 이를 해결하기 위해 하나의 저장소에 쓰기 모델과 읽기 모델을 분리하는 방식
        - 쓰기와 읽기를 분리하는 과정
            
            ![[Untitled 35.png]]
            
        - CQRS 패턴의 개념도
            
            ![[Untitled 36.png]]
            
            - CUD(create,update, delete)에는 RDB, R(Read)에는 Nosql 사용
            - 이럴 경우 데이터 일관성이 깨지게 되는데 이를 유지하기 위해 필요한 것이 이벤트 주도 아키텍처
            - 저장소에 데이터를 쓰면서 저장한 내역이 담긴 이벤트를 발생시켜 메시지 브로커에 전달하고 조회 서비스는 메시지 브로커의 이벤트를 구독하고 있다가 이벤트 데이터를 가져와 데이터를 최신 상태로 동기화
            - 실시간으로 일치하지 않을 수 있지만, 결과적으로 일치 ⇒ 결과적 일관성 추구
- API 조합과 CQRS
    - 마이크로서비스의 저장소끼리 격리되어 있고, 각 마이크로서비스마다 각기 다른 기능을 구현했을 때 여러 개의 마이크로서비스를 연계해서 서비스로 제공하는 경우
    - 해결방법
        - API composition(API 조합)
            - 각 기능을 제공하는 마이크로서비스를 조합하는 상위 마이크로서비스를 만들어 조합된 기능을 제공
            - 하위 서비스는 각자 독립적인 API를 제공하면서 연계 API를 위해 상위 서비스에 정보 제공
            - 이럴 경우 하위 서비스에 상위 서비스가 의존 ⇒ 하위 서비스 중 하나라도 API가 변경되면 상위 서비스도 그에 따라 변경 필요 & 하위 서비스 실패가 상위 서비스에 영향을 준다
        - CQRS 적용
            - 여러 마이크로서비스가 자신의 서비스에 정보가 변경되는 시점에 변경 내역을 각자의 변경 이벤트로 발행
            - 다른 마이크로서비스가 이 이벤트를 구독하고 있다가 이벤트를 가져와 자신의 서비스의 저장소에 기록을 통해 다른 서비스와의 데이터 & 데이터 일관성 유지
            - 이 경우 다른 원천 서비스가 순간적인 장애가 발생해고 다른 서비스에 영향을 미치지 않는다
- 쓰기 최적화 : 이벤트 소싱 패턴
    - 사가 패턴, CQRS 패턴에서 비지니스 불일치를 피해가 위해선 저장소에 저장하는 것과 메시지를 보내는 것이 원자성을 지녀야한다 ⇒ 저장소에 저장하는 일과 메시지를 보내는 작업이 언제나 완전하게 진행되어 함께 실행되어야 한다
    - **객체 상태를 데이터 모델에 맞춰 변환하고 저장**(Ex. RDB, spring을 통한 데이터 CRUD)은 변환 과정이 복잡하고 변환 처리가 느리다
    - 이벤트 소싱(event sourcing)
        - 상태 트랜잭션 자체를 저장
        - 트랜잭션 자체를 저장하는 전략 ⇒ 상태 변경 이벤트를 계산해서 데이터 모델을 변경하지 않고 바로 이벤트 저장소에 그대로 저장
        - 메시지 브로커와 데이터 저장소를 분리하지 않고 하나로 사용할 수 있고, 복잡한 과정이 없어 쓰기 속도가 빠름
        - 현재 시점의 상태가 필요할 경우 상태의 출발점부터 모든 기록된 상태 변경 트랜잭션을 순차적으로 계산
        - **명령 측면과 조회 측면의 서비스가 이벤트 저장소에 대한 CR(Create, Read)만 처리하면 된다⇒ 저장소에서 변경과 삭제가 발생하지 않기 때문 ⇒ 명령 측면의 여러 개 확장해도 동시 업데이트 및 교착상태가 발생하지 않는다**
        - **모든 트랜잭션의 상태를 바로바로 계산하지 않고 별도의 이벤트 스트림으로 이벤트 스트림 저장소에 저장하는 방식**
    - 예시
        
        ![[Untitled 37.png]]
        
        - Entity 타입의 어떤 객체의 이벤트인지, 변경 내용이 json 형태로 그대로 저장
        - Axon Framework, Eventuate 주로 사용

## 2.5 정리

- 현대 애플리케이션 아키텍처에 대해 요구하는 특성을 알아보기 위해 리액티브 선언을 살펴보면 주요 특성 으로 응답성, 유연성, 탄력성, 메시지 기반 등이 요구된다는 것을 알 수 있다. 특히 이러한 요소들은 애플리케이션의 유연성을 강하게 요구한다.
- MSA 아키텍처는 기존의 벤더 중심의 강 결합 아키텍처에서 오픈소스 중심의 느슨한 결합의 아키텍처로 변화할 것을 요구한다.
- MSA 아키텍처는 마이크로서비스 외부의 구성을 위한 외부 아키텍처와 마이크로서비스 내부 정의를 위한 내부 아키텍처로 구성된다.
- MSA 아키텍처 영역의 문제 해결 방식이 다양한 MSA 패턴으로 정리되고 있고, 인프라 구성요소, 플랫폼 운영관리 패턴, 애플리케이션 연계와 관련된 패턴 등이 존재한다.
- 클라우드 인프라 구성요소로 가상 머신, 컨테이너, 컨테이너 오케스트레이션 등이 고려된다.
- 마이크로서비스의 생태계 발전과 함께 마이크로서비스 운영 관리를 위한 플랫폼 패턴들이 탄생했다.
- 플랫폼 패턴으로 넷플릭스 OSS 기반의 애플리케이션을 활용한 패턴이 최초로 등장했고, 이를 발전시킨 패 턴이 쿠버네티스, 이스티오 등의 기술로 발전해 오고 있다.
- 마이크로서비스 애플리케이션을 구성하고 연계하기 위해 UI 컴포지트, 통신 패턴, 이벤트 기반 아키텍처 등이 고려된다.
- 저장소 분리 등으로 인한 분산 트랜잭션의 근본적인 문제 등을 해결하기 위해 사가 패턴, CQRS, 이벤트 소싱 패턴 등이 고려된다.  
      
    
