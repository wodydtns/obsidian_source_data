# 1장 소프트웨어 구현으로의 초대
## 1.1 소프트웨어 구현이란 무엇인가?
- 소프트웨어 구현 시 활동
    - 문제 정의
    - 요구사항 개발
    - 구현 계획 수립
    - 소프트웨어 아키텍처 또는 고급 수준 설계
    - 상세 설계
    - 코드 작성 및 디버깅
    - 단위 테스트
    - 통합 테스트
    - 통합
    - 시스템 테스트
    - 유지보수
- 구현 활동에 속하는 구체적인 작업
    - 성공적인 구현 활동을 위한 기초 작업 검증
    - 코드에 대한 테스트 방법 결정
    - 클래스 및 루틴 설계와 작성
    - 변수와 이름 상수 생성 및 이름 부여
    - 제어 구조 선택과 명령문 블록 구조화
    - 코드에 대한 단위 테스트, 통합 테스트, 디버깅
    - 저수준 설계와 코드를 다른 팀원과 교차 검토
    - 조심스럽게 코드의 포맷을 맞추고 주석을 달아 코드를 정리
    - 개별적으로 작성한 소프트웨어 컴포넌트의 통합
    - 코드가 더 빨리 실행되고 더 적은 자원을 사용하도록 최적화
## 1.2 소프트웨어 구현이 중요한 이유는 무엇인가
- 소프트웨어 구현이 중요한 이유
	- 구현은 소프트웨어 개발에서 큰 비중을 차지한다(70~80%)
	- 구현은 소프트웨어 개발 과정에서 중심적인 활동이다
        - 요구 사항 분석과 설계는 효과적인 구현을 위해 구현 보다 앞서서 이뤄진다
        - 시스템 테스트는 구현을 검증하기 위해 구현 후에 수행
        - **구현은 소프트웨어 개발 과정의 중심에 있다**
- 구현에 집중함으로써 프로그래머의 생산성을 크게 향상할 수 있다
	- 프로그래머 개인의 생산성은 구현하는 동안 10~20배 차이가 있다
	- 구현의 결과물인 소스코드만이 소프트웨어를 정확하게 설명하는 경우가 많다
        - 프로젝트에서 개발에게 허용된 유일한 문서는 코드 자체
        - 요구사항과 문서는 최신 정보를 반영하지 못하지만 소스코드는 항상 최신 내용 ⇒ 소스코드는 항상 최고의 품질을 유지해야한다
        - 구현은 반드시 해야 하는 유일한 활동이다
        - **계획이 엉망인 프로젝트라도 구현 단계를 생략할 수 없다**  
# 2장 소프트웨어 개발의 이해를 돕기 위한 비유
## 2.1 비유의 중요성
- 비유의 중요성
    - 비유를 얼마나 잘 이해하느냐가 소프트웨어 개발을 얼마나 잘 이해하느냐를 결정한다
## 2.2 소프트웨어 비유 사용법
- 소프트웨어 비유
    - 소프트웨어 비유는 탐조등 → **답을 어떻게 찾을지 알려준다**
    - 비유는 알고리즘보다 발견적인 학습으로서 더 많은 역할을 담당
    - 알고리즘은 직접 방법을 알려주고, 발견적 학습은 그 방법을 스스로 찾는 방법을 알려주거나, 어디서 찾을 수 있는지를 말해준다
    - 프로그래밍에서 가장 어려운 분야는 문제를 개념화 하는것이며 가장 많은 오류가 개념적 오류다
    - **소프트웨어 비유는 프로그래밍 문제와 프로세스를 이해하는 데 활용하라**
    - **프로그래밍 활동에 대해 생각하고 더 나은 작업 수행 방법을 생각해내는 데 도움을 받아라**
## 2.3 일반적인 소프트웨어 비유
- 소프트웨어 글쓰기: 코드 작성
    - 코드 작성하기를 글쓰기 작업으로 비유
    - 이는 프로그램 가독성에 대해 이야기한다
    - 다만 글쓰기는 홀로하고, 독창적이지만 , 소프트웨어는 변경이 수월하고 완전히 완료되지 않으며, 대부분 다른 역할을 맡은 여러 사람이 수행한다. 그리고 소프트웨어는 이전 프로젝트의 설계 아이디어와 코드, 테스트 사례를 재사용하는 데 초점을 맞추는게 더 효과적일 경우가 많다
    - 글쓰기와 코드 작성을 비유하기는 조금 어렵다
- 소프트웨어 농사: 시스템 키우기
    - 농사와 프로그래밍이 한 번에 조금씩 수행한다는 개념에선 유사하지만 둘 간의 관련성이 너무 적고 많은 정보를 제공하지 못한다
- 소프트웨어 조개 양식 : 시스템 증대
    - 시스템은 점증적 개발 → 프로토타입에서 시스템으로
    - 조개가 자기 껍질을 점증적으로 두껍게 만드는 것과 유사
- 소프트웨어 건설 : 소프트웨어 구축
    - 건축과 소프트웨어 증대라는 개념과 맞아떨어지고 더 상세한 지침을 제공
    - 소프트웨어 구축에 무엇을 구축하느냐에 따라 종류와 정도가 다른 여러 단계의 계획 수립과 준비, 실행이 수반
    - 건축에서 복잡한 건물을 짓기 위해 설계 완성도가 떨어지고 더 복잡해지는 것과 유사하게 소프트웨어의 아키텍처 설계와 유사
- 소프트웨어 기법의 적용: 지적 도구 상자
    - 도구 상자 비유는 모든 방법과 기법, 팁을 언제든지 사용할 수 있도록 균형 잡힌 시각을 유지하는 데 도움을 준다
- 비유 결합
    - 비유는 알고리즘적이기보다 발견적 → 상호 배타적이지 않음
    - 증대 & 건축 비유를 동시에 사용 가능
    - 비유를 통해 발견적 학습에 근간을 둔 통찰력을 얻기 위해서는 개념을 확장해야 한다
    - 비유를 지나치게 확장하거나 잘못된 방향으로 확장하면 엉뚱하게 판단할 수 있다
    - 그럼에도 비유는 알아둘 가치가 충분히 있다
# 3장 준비는 철저하게: 선행 조건
## 3.1 선행 조건의 중요성
- 품질이 좋은 소프트웨어를 개발하는 실천법
    - 프로젝트 마지막 단계 - 시스템 테스트 수행
    - 프로젝트 중간 단계 
	    - 구현 방법에 중점
	    - 현재 상황을 판단하고 실패 먹구름이 있다면 되돌려야한다
    - 프로젝트 시작 단계
	    - 고급 제품을 계획하고 요구사항을 수집하고 설계
- 선행 조건이 최신 소프트웨어 프로젝트에도 적용되는가?
	- 아키텍처, 설계, 프로젝트 계획은 매우 중요하다
	- 준비 작업의 가장 중요한 목표는 위험 축소
	- 주요 위험 요소 제거
- 불완전한 준비의 원인
	- 선행 작업에 투입되는 개발자가 자신의 작업을 수행할 수 있을 정도의 전문가적 지식을 갖고 있지 않다 ⇒ 프로젝트를 계획, 포괄적이고 정확한 요구사항 개발, 훌륭한 아키텍처 설계를 대부분의 개발자는 배운적이 없다
	- 선행 작업을 수행하는 방법은 알고 있지만, 코드 작성에 급급해 준비 작업을 하지 않는 개발자
	- 관리자들이 구현에 필요한 선행조건을 수행하기 위해 시간을 투자하는 개발자들을 못마땅하게 본다
- 구현 전에 선행 조건을 수행하기 위한 필수적인 논의
	- 논리적 설득
        - 관리적 측면에서의 계획 수립 : 프로젝트에 필요한 시간과 인력, 장비의 수 결정
        - 기술적인 측면에서의 계획 수립 : 잘못된 작업으로 인해 돈을 낭비하는 일이 없도록 자신이 만들고자 하는 것이 무엇인지 정확하게 이해하는 것
- 비유적 설득
	- 개발자들은 소프트웨어 먹이 사슬의 최종 소비자다. 아키텍트는 요구사항을 먹고 설계자는 아키텍처를 먹고 코더는 설계를 먹는다
        - 프로그래밍에서 요구사항이 오염되면 아키텍처가 오염되고 결과적으로 구현도 오염된다
        - 반복적인 프로젝트를 계획한다면 구현을 시작하기 전에 구현해야 하는 각 부분에 적용할 핵심 요구사항과 아키텍처 요소를 규명해야한다
-  데이터에 근거한 설득
	- 처음부터 작업을 제대로 수행해야 한다

| 발생시기 | 요구사항 | 아키텍처 | 구현   | 시스템 테스트 | 출시 후   |
| ---- | ---- | ---- | ---- | ------- | ------ |
| 요구사항 | 1    | 3    | 5-10 | 10      | 10-100 |
| 아키텍처 | -    | 1    | 10   | 15      | 25-100 |
| 구현   | -    | -    | 1    | 10      | 10-25  |
-  상사의 준비성 테스트
	- 디버깅할 것이 많기 때문에 당장 코드를 작성하는 것이 낫다
        - 결함이 많이 발견되지 않을 것이므로 테스트에 많은 시간을 할애하지 않았다
        - **요구사항과 설계에 충분히 신중을 기했으니 코딩과 디버깅을 수행할 때 중요한 문제점이 발견되지 않을 것이다 ⇒ 이 문장을 목표로 하라**
## 3.2 작업 중인 소프트웨어의 종류 결정
- 세 가지 종류의 프로젝트에 적합한 방법
>![[codeComplete1.png]]
>
- 선행 조건에서 반복적인 접근 방법이 갖는 효과
	- 순차적 프로젝트와 반복적 프로젝트에서 선행 조건을 무시했을 때의 효과
>![[codeComplete2.png]]
- 선행 조건을 줄이거나 없앤 반복적 프로젝트와 순차적 프로젝트의 차이
	- 결함 발생 후 상대적으로 빨리 발견됨 → 평균 결함 수정 비용이 더 적음(전자)
	- 반복적인 접근 방법에서의 비용은 마지막에 한꺼번에 들지 않고 전체 프로젝트 과정에 조금씩 흡수 → 총 비용은 비슷하지만, 프로젝트 진행함에 따라 할부 형식으로 나눠서 지불
- 순차적 프로젝트와 반복적 프로젝트에서 선행 조건 다룰 때의 효과
>![[codeComplete3.png]]
- 저자 추천
	- 요구사항 중 80%정도를 미리 명시, 추가적으로 기술할 시간을 할당 후 프로젝트를 진행하면서 가장 중요하다고 생각되는 새로운 요구사항들만 수용 할 수 있도록 실제 구조 변화를 꾀하는 것
>![[codeComplete4.png]]
 - 요구사항의 20% 정도만 명시한 다음 프로젝트를 진행해 나가면서 추가적인 요구사항과 설계 기술
>![[codeComplete5.png]]
- 반복적인 방법과 순차적인 방법의 선택
	- 구현 시 가장 먼저 할 일은 프로젝트에 가장 적합한 선행 조건이 무엇인가를 결정하는 것
	- 순차적인 접근 방법 선호 조건(선행)
		- 요구사항이 상당히 안정적일 때
		- 설계가 직관적이며 이해하기 쉬울 때
		- 개발 팀이 해당 응용 분야에 익숙할 때
		- 프로젝트의 위험 부담이 적을 때
		- 장기적인 계획이 중요할 때
		- 요구사항, 설계, 코드 변경 비용이 높을 것 같을 때
	- 반복적인 접근 방법 선호 조건
		- 요구사항을 제대로 이해할 수 없거나 다른 여러 가지 이유 때문에 변경될 가능성이 많을 때
	        - 설계가 복잡하거나 어려울 때
	        - 개발 팀이 해당 응용 분야에 대해 잘 모를 때
	        - 프로젝트의 위험 부담이 높을 때
	        - 장기적인 계획이 중요하지 않을 때
	        - 요구사항, 설계, 코드 변경 비용이 높지 않을 때
## 3.3 문제-정의 선행 조건
- 문제-정의
	- 시스템이 해결해야 하는 문제를 명확하게 기술하는 것
	- 구현 전 가장 첫 번째 선행 조건
	- 문제 정의는 반드시 사용자의 언어로 작성해야 하고, 문제는 사용자 관점에서 기술해야한다
	- 예외 : 문제가 컴퓨터에 있는 경우 ex) 컴파일 성능 이슈
	- 문제 정의에 실패하면 잘못된 문제를 해결하느라 많은 시간이 낭비된다

## 3.4 요구사항 선행 조건
- 요구사항
	- 소프트웨어 시스템이 무엇을 수행해야 하는지에 대해 상세하게 기술하고 해결책을 구현하는 첫 번째 과정
	- 요구사항을 수집하는 작업 - “요구사항 개발”, “요구 사항분석”, “분석”, “요구사항 정의”, “ 소프트웨어 요구사항”, “ 명세화”, “기능 명세”, “명세”
- 왜 명시적인 요구사항이 필요한가
	- 개발자 대신 사용자가 시스템의 기능을 주도하게 하는 데 도움이 됨 ⇒ 요구사항을 명시적으로 정의함으로써 사용자가 원하는 것이 무엇인지를 알 수 있다
	- 논쟁을 피하게 해준다 ⇒ 프로그래밍 시작 전 시스템의 기능을 결정하고, 프로그램의 기능에 다른 개발자가 동의하지 않으면 작성된 요구사항을 살펴보면 문제를 해결할 수 있음
	- 요구사항에 집중하면 개발을 시작하고 난 후 변경 사항을 최소화하는 데 도움이 된다
        - 요구사항 변경은 설계를 변경해야하기 때문
        -  **요구사항을 제대로 명시하는 것은 프로젝트 성공에 있어 효과적인 구현 기술보다 더 중요하다**
- 견고한 요구사항에 대한 미신
	-  고객이 요구사항 문서를 받아들이고 나면 더 이상 변경할 필요가 없다고 기대할 수 있음
	- 일반적으로 고객은 코드가 작성되기 전까지 자기에게 필요한 사항을 확실하게 설명하지 못함 → 프로젝트가 진행될 수록 고객도 프로젝트를 더 잘 이해하게 된다 ⇒ **요구사항 변경의 주요한 요인**
- 구현 중에 요구사항 변경 다루기
	- ***요구사항의 품질을 평가한다***
>![[codeComplete7.png]]
>![[codeComplete6.png]]
	- ***모든 사람이 요구사항 변경 비용에 대해서 알게 한다***
	- 변경 사항을 관리하기 위한 절차를 구축해라
		- ***변경 사항들을 수용하는 개발 접근 방법을 사용한다***
        - 진화적 프로토타이핑 접근 방법
	        - 시스템을 작게 구축해 사용자로부터 피드백을 받고 설계를 약간 수정 후 약간의 변경을 거쳐 추가 개발
	        - **사용자가 빠르게 응답할 수 있도록 개발 주기를 짧게 가져가는 것**
- ***프로젝트를 취소한다***
	- 요구사항이 매우 형편없거나, 변하기 쉽고 앞에서 제안한 어떤 사항도 사용할 수 없다면 그 프로젝트는 **취소해야한다**
- ***프로젝트의 사업성을 주시한다***
	- 요구사항 문제의 상당수는 프로젝트를 수행하는 사업상 목적을 고려하면 무의미해진다
        - 좋은 생각처럼 보였던 요구사항도 “기능”으로서 “점진적인 사업 가치”를 평가해 보면 터무니없는 아이디어로 보일 수 있다
## 3.5 아키텍처 선행 조건
- 아키텍처 선행 조건
	- 소프트웨어 아키텍처 :소프트웨어 설계의 상위 부분에 속하고, 설계 중에서 더 상세한 부분을 담은 틀
	- 아키텍처 : “시스템 아키텍처”, “ 최상위 설계”, “상위 수준 설계”
	- 아키텍처의 품질이 시스템의 개념적인 무결성을 결정하기 때문에 아키텍처가 선행 조건에 포함된다 ⇒ **시스템의 궁극적인 품질을 결정한다**
	- 좋은 아키텍처는 구현을 쉽게 하고, 나쁜 아키텍처는 구현을 거의 불가능하게 만든다
- 전형적인 아키텍처의 구성 요소
	- 프로그램 구조
        - 시스템 아키텍처는 시스템을 일반적인 말로 기술할 개요가 필요하다 ⇒ 수 많은 세부 사항과 수십 개의 클래스로부터 전체적인 그림을 그리기 어려움
        - 아키텍처에서 최종 구조에 대한 대안을 고려했던 근거와 다른 대안들 대신 지금의 구조를 선택한 이유를 찾아야한다 ⇒ 구조적인 대안들을 기술함으로써 아키텍처가 현재의 시스템 구조에 대한 논리적 근거를 제공하고 각 클래스가 신중하게 고려되었음을 보여준다
        - 아키텍처는 프로그램 내의 중요한 빌딩 블록을 정의해야 한다
	        - 빌딩 블록에 적어도 요구사항에서 명시한 기능이 하나는 들어가야 한다
        - 각 빌딩 블록이 책임져야 하는 내용은 반드시 명확하게 정의해야 한다
	        - 하나의 빌딩 블록은 반드시 한 분야를 책임져야 하며 다른 빌딩 블록에 대해 가능한 한 조금 알아야한다.
	        - 한 빌딩 블록이 다른 빌딩 블록에 대해 아는 내용을 최소화함으로써 설계에 관한 정보를 단일 빌딩 블록으로 제한할 수 있다
        - 각 빌딩 블록에 대한 커뮤니케이션 규칙도 명확하게 정의해야 한다
	        - 아키텍처는 직접적으로 사용할 수 있는 빌딩 블록, 간접적으로 사용할 수 있는 빌딩 블록, 절대로 사용해서는 안되는 블록이 무엇인지 기술
	- 주요 클래스
		- 각각의 중요한 클래스가 맡은 역할과 클래스 사이의 상호작용을 어떻게 할 것인지를 규명해야한다
	        - 클래스 계층 구조와 상태 전이, 객체 지속성에 대한 설명도 포함
	- 데이터 설계
		- 아키텍처는 중요한 파일과 테이블 설계를 기술해야 한다
		- 고려했던 다른 대안들에 대해 기술하고 현재의 방법을 선택한 이유를 설명해야 한다 ⇒ 이런 정보들은 개발자가 설계자를 이해하는 데 도움을 준다
        - 데이터는 일반적으로 하나의 서브시스템이나 클래스에서만 직접 접근해야 한다
        - 모든 데이터베이스의 고수준 구조와 내용에 대해 명시해야 한다
        - **단일 DB가 다중 DB보다 좋은지 설명하고(그 반대도 마찬가지), 왜 DB가 일반 파일보다 좋은지 설명해야하고, 동일한 데이터에 접근하는 다른 프로그램과의 상호 연동이 가능한지 규명하고 데이터에 대해 생성한 뷰를 설명해야 한다**
- 비지니스 규칙
	- 아키텍처가 특정한 비지니스 규칙을 따른다면 반드시 이를 규명하고 그러한 규칙들이 시스템 설계에 미친 영향을 기술해야한다
	- 사용자 인터페이스 설계
	        - 사용자 인터페이스는 종종 요구사항 작성 시 명시되며 그렇지 않으면 소프트웨어 아키텍처 작성 시 명시되어야 한다
        - 웹 페이지 형식, GUI, 명령줄 인터페이스 등 주요 요소를 명시해야 한다
        - 아키텍처는 비지니스 규칙이나 프로그램의 결과에 영향을 미치지 않고 새로운 사용자 인터페이스로 대체할 수 있도록 모듈화되어야 한다
- 자원 관리
	- DB 연결, 스레드, 핸들과 같은 부족한 자원을 관리하기 위한 계획을 기술해야 한다
        - 아키텍처는 일반적인, 최악의 상황에서 사용되는 자원을 측정해야 한다
- 보안
	- 아키텍처는 설계 , 코드 단계의 보안에 대해 접근 방법을 기술해야 한다
        - 위협 모델을 이전에 구성하지 않았다면 아키텍처 작성 시 구성해야 한다
        - 버퍼 처리 방법, 신뢰할 수 없는 데이터(사용자, 쿠키, 환경 설정 데이터, 외부 인터페이스로부터의 데이터 입력) 처리 규칙, 암호화 , 오류 메시지에 포함될 내용의 상세함 정도, 메모리에 있는 중요 데이터 보호와 같은 보안 관련 사항을 염두하고 작성
- 성능
	- 성능을 염려한다면 요구사항에 원하는 성능을 명시해야 한다
        - 아키텍처는 추정치를 제공해야 하며 설계자가 그런 목표에 도달할 수 있다고 믿는 이유를 설명해야 한다
        - 어떤 영역이 목표를 달성하지 못할 위험에 처해 있다면 그러한 내용에 대해서도 언급해야 한다
        - 어떤 영역이 성능 목표를 달성하기 위해 특정 알고리즘이나 데이터 형식을 사용해야 한다면 그러한 내용에 대해서도 언급해야 한다
- 확장성
	- 추후의 요구를 충족시켜기 위해 시스템이 확장할 수 있는 능력
        - 아키텍처는 사용자 수, 서버 수, 네트워크 노드의 수, DB 레코드의 수, DB레코드 크기, 트랜잭션 용량 등의 증가를 시스템이 어떻게 처리할 것인지를 기술해야 한다
- 상호운용성
	- 시스템이 다른 소프트웨어나 하드웨어와 함께 데이터나 자원을 공유할 거라고 예상된다면 아키텍처는 그러한 기능을 어떻게 구현할 것인지 기술해야 한다
	- 국제화와 지역화
		- 국제화는 프로그램이 여러 나라를 지원하기 위한 기술적인 준비 작업(**I18n)**
	        - 지역화는 특정한 언어를 지원하기 위한 번역 작업
	        - 국제화 이슈는 대화식 시스템을 위한 아키텍처 작성 시 주의해야 하는 부분
	- 입력/출력
		- 아키텍처는 입력 체계가 선행인지 후행인지, 상황에 따라 선택되는지 명시해야 한다
		- 필드나 레코드, 스트림, 파일 수준에서 어떤 입출력 오류가 검출되는지를 명시해야한다
	- 오류 처리
		- 오류 처리를 위한 일관된 방법을 아키텍처에 명시되어야 한다
	        - 오류 처리 시 고려 사항
	        - 오류 처리가 오류 수정을 하는가, 단순히 검출만 하는가? 수정을 한다면 프로그램은 오류로부터 복구하기 위한 시도를 할 수 있다. 검출만 한다면 프로그램은 아무 일도 없던 것처럼 처리를 진행하거나 중단할 수 있다. 어느 경우든 오류를 검출했다는 사실을 사용자에게 알려줘야 한다
	        - 오류 검출이 능동적인가, 수동적인가? 시스템은 가령 사용자 입력 값의 유효성 검사를 통해 오류를 능동적으로 예상하거나 사용자 입력 값에 오버플로가 발생했을 때처럼 오류를 피할 수 없을 때 오류에 수동적으로 대응할 수 있다. 시스템은 입력 방법을 명확하게 하거나 오류가 발생한 상황을 정리할 수 있다. 이번에도 마 찬가지로 어느 경우를 선택하든 사용자 인터페이스와 밀접하게 관련되어 있다.
	        - 프로그램이 오류를 어떻게 전달하는가? 일단 오류를 검출하면 오류를 발생시킨 데이터를 곧바로 버리거나 오류를 처리하기 위해서 오류 처리 과정으로 넘어갈 수 있다. 그게 아니라면 프로그램의 모든 처리가 완료될 때까지 기다렸다가 어디에선가 오류가 검출되었다는 것을 사용자에게 알릴 수 있다
	        - 오류 처리 메시지에 관한 규약이 있는가? 아키텍처가 하나의 일관된 방법을 명시하지 않는다면 사용자 인터페이스는 여러 부분에서 서로 다른 인터페이스가 뒤섞인 것처럼 보일 것이다. 이렇게 보이지 않도록 아키텍 처는 오류 메시지에 대한 규약을 수립해야 한다.
	        - 예외를 어떻게 처리할 것인가? 아키텍처는 코드가 언제 예외를 던지고 어디서 처리되며 어떻게 기록되고 어 떻게 문서화될 것인지에 대한 내용을 설명해야 한다.
	        - 프로그램 내부에서 어떤 수준에서 오류가 처리될 것인가? 오류는 검출 당시에 처리하거나 오류 처리 클래스 로 전달하거나 호출 체인으로 전달할 수 있다.
	        - 입력 데이터를 검증하기 위해서 각 클래스가 어느 수준까지 책임져야 하는가? 각 클래스가 자신의 데이터를 검증해야 하는가, 아니면 시스템의 데이터를 검증하는 특정 클래스 집합이 있는가? 모든 수준의 클래스가 받은 데이터에 문제가 없다고 가정할 수 있는가?
	        - 사용자의 환경에서 기존에 제공하고 있던 오류 처리 방법을 사용할 것인가, 아니면 새로 만들 것인가? 사용 자의 환경에 특정 오류 처리 방법이 있다고 해도 그것이 요구사항에 가장 적합한 방법은 아닐 수도 있다.
    - 장애 허용
	    - 장애 허용의 방법
		    - 오류를 발견했을 때 시스템이 자료를 백업하거나 다시 시도할 수 있다. 처음 구한 답이 틀렸다면 잘 된 부분 까지 백업하고 그 부분부터 계속한다.
	            - 시스템은 주 코드에서 오류가 발견되었을 경우 보조 코드를 사용할 수 있다. 이 경우에는 첫 번째 답이 틀리 면 시스템이 또 다른 제곱근 공식을 사용한다
	            - 시스템은 투표 알고리즘을 사용할 수 있다. 시스템이 서로 다른 방법을 사용하는 세 가지 제곱근 클래스를 가지고 있다고 하면 각 클래스가 제곱근을 계산한 후 시스템이 결과를 비교한다. 시스템에 구축된 장애 허용 정도에 따라 시스템이 평균값이나 중간 값, 또는 세 값에서 가장 많이 나타난 값(최빈수)을 사용한다.
	            - 시스템은 잘못된 값을 시스템의 나머지 부분에 악영향을 끼치지 않는 가짜 값으로 대체할 수 있다.
 - 구조적인 실행 가능성
	 - 시스템이 기술적으로 실행 가능함을 보여줘야 한다.
	 - 특정 분야에서의 실행 불가능 때문에 프로젝트 전체가 실행 불가능해 보인다면 아키텍처는 기술 검증 프로토타입이나 조사, 기타 다른 방법을 통해 그러한 문제점을 어떻게 조사했는지 설명해야한다
	 - 위험 요소는 전체 구현 작업을 시작 전 해결되어야 한다
    - 과도한 엔지니어링
	    - 아키텍처는 개발자의 잘못이 지나치게 엔지니어링을 수행한 것인지, 아니면 지나치게 일을 간소화한 것인지를 명확하게 지적해야 한다
	    - 아키텍처에서 명쾌하게 예측해놓으면 일부 클래스는 유난히 견고하고 다른 클래스는 거의 적정 수준도 못 미치는 현상을 피할 수 있다
- 구입과 구현 결정
	- 가장 급진적인 해결책은 소프트웨어 구매 & 오픈소스 사용
	- 아키텍처는 시장에서 판매하는 컴포넌트를 사용하지 않는다면 맞춤 제작하는 컴포넌트가 판매 중인 라이브러리와 컴포넌트의 기능을 어떤 부분에서 능가할 것인지 설명해야한다
- 재사용 결정
	- 변경은 바꾸기 쉬운 데이터 유형, 파일 형식, 변경된 기능, 새로운 기능 등에서 발생
	- 계획된 기능 향상이나 시스템의 첫 번째 버전에서 구현하지 못했던 기능 보완을 위해 변경 ⇒ **소프트웨어 설계자는 변경 사항을 수용할 수 있을 정도로 유연한 아키텍처를 만드는 것**
        - 아키텍처는 변경을 처리하기 위한 전략을 명확하게 기술해야 한다
        - 아키텍처는 작업을 지연하는 데 사용할 전략을 설명해야 한다
	        - 테스트를 위해 코드를 직접 입력하는 대신 테이블 기반의 기법을 사용해야 한다는 것을 명시
- 일반적인 아키텍처 품질
	- 좋은 아키텍처 명세서는 시스템에 있는 클래스와 각 클래스에 숨어있는 정보, 가능한 모든 설계 대안을 포함하거나 제외한 근거를 다루고 있다
        - 아키텍처는 임의로 추가할 사항 없이 깔끔하고 개념적으로 완전해야 한다
        - 각 변경 사항은 전체적인 개념과 명확하게 일치해야 한다
        - 아키텍처의 목표는 명확하게 기술되어야 한다
        - 아키텍처는 모든 주요 결정사항에 대한 동기를 기술해야 한다
        - 훌륭한 소프트웨어 아키텍처는 대부분 기계와 언어에 독립적
        - 아키텍처의 어느 부분도 지나치게 주의를 끌거나 과도하게 설계되어서는 안된다
        - 아키텍처는 명시적으로 위험 영역을 규명해야 한다
        - 아키텍처에는 여러 가지 관점이 들어가야 한다
        - 아키텍처에 대한 확신이 있어야 한다
- 체크리스트 : 아키텍처
	- 구체적인 아키텍처 주제
        - 좋은 아키텍처의 개요와 설명을 포함한 전체적인 프로그램 구조가 명확한가?
        - 주요 빌딩 블록을 그 책임 영역과 다른 빌딩 블록에 대한 인터페이스를 포함해 잘 정의했는가?
        - 요구사항에 있는 모든 기능을 적절한 수의 빌딩 블록으로 다루었는가?
        - 가장 중요한 클래스를 기술하고 정당성을 증명했는가?
        - 데이터베이스 구조와 내용을 명시했는가?
        - 핵심 비즈니스 규칙을 모두 명시하고 그 규칙이 시스템에 미치는 영향을 기술했는가?
        - 사용자 인터페이스 설계 전략을 기술했는가?
        - 사용자 인터페이스를 일부 변경해도 프로그램의 나머지 부분에 영향을 미치지 않도록 모듈화했는가?
        - I/O 처리 방법을 기술하고 정당성을 증명했는가?
        - 스레드와 데이터베이스 연결, 핸들, 네트워크 대역폭 등과 같이 부족한 자원에 대해서 자원 사용 예측 및 자원 관리 방법을 기술했는가?
        - 아키텍처의 보안 요구사항을 기술했는가?
        - 아키텍처가 각 클래스나 서브시스템, 기능 영역에 대한 공간과 속도를 설정했는가?
        - 아키텍처가 확장성을 어떻게 구현할지 기술했는가?
        - 아키텍처가 상호운용성을 다루는가?
        - 국제화와 지역화를 위한 방법을 기술했는가?
        - 일관된 오류 처리 방법을 제공했는가?
        - 장애 허용에 대한 접근 방법을 정의했는가?(장애 허용이 필요한 경우)
        - 시스템의 모든 부분에 대해서 기술적인 구현 가능성을 확인했는가?
        - 과도한 엔지니어링에 대한 해결책을 명시했는가?
        - 구입할 것인지 구현할 것인지에 대한 결정을 포함했는가?
        - 재사용된 코드가 아키텍처의 다른 목표와 어떻게 부합할 것인지 기술했는가?
        - 아키텍처가 가능성 있는 변경 사항을 수용할 수 있도록 설계했는가?
- 일반적인 아키텍처 품질
	- 아키텍처가 모든 요구사항을 설명하고 있는가?
        - 지나치거나 부족한 부분은 없는가? 이 부분에 대한 기대치를 명확하게 설정하고 있는가?
        - 전체적인 아키텍처가 개념적으로 일관성을 갖는가?
        - 최상위 설계가 구현에 사용될 기계와 언어에 독립적인가?
        - 모든 중요한 결정에 대한 근거를 제공하는가?
        - 시스템을 구현할 당사자로서 아키텍처에 만족하는가?
## 3.6 선행 조건에 소요되는 시간
- 소요 시간
	- 일반적으로 제대로 진행되는 프로젝트는 요구사항과 아키텍처, 사전 계획 수립을 위해 전체 노력의 10~20% 정도 & 전체 시간의 20~30% 정도 투자
	- 프로젝트가 형식, 비형식적이든 상관없이 요구사항이 불완전하다면 요구사항 수집 작업 자체를 하나의 프로젝트로 다루고 요구사항 작업을 마친 다음 프로젝트의 나머지 시간을 추정
	- 소프트웨어 아키텍처에 시간을 할당할 때도 요구사항 개발과 유사한 방법을 사용
	- 한 번도 다루지 않은 소프트웨어라면 새로운 분야에서의 불확실한 설계에 대비해 더 많은 시간을 할애한다
# 4장 구현 시 결정해야 할 핵심 사항
## 4.1 프로그래밍 언어 선택

<aside>

💡 훌륭한 표기법은 불필요한 작업에 신경 쓰지 않게 함으로써 더 어려운 문제에 집중하게 해주고 결과적으로 정신력을 강하게 해준다. 아라비아 표기법이 알려지기 전에는 곱셉이 어려웠으며 나눗셈을 가장 어려운 수학으로 여겼다. 그리스 시대의 수학자들이 오늘날 서유럽에 있는 대부분의 사람이 큰 수로 나눗셈을 할 수 있다는 것을 알게 된다면 엄청난 충격을 받았을 것이다. 이러한 사실을 그리스 수학자들은 도저히 불가능하다고 여겼으니까… 현대에서 십진수로 된 분수를 쉽게 계산하는 능력은 거의 기적적으로 완벽한 기수법을 점진적으로 발견한 결과다

- 알프레드 노스 화이트헤드(Alfred North Whitehead)

</aside>

- 구현을 시작할때부터 끝날때까지 언어가 상당한 영향을 준다
- 3년 이상 사용해온 언어로 개발하는 경우 그렇지 않은 경우보다 생산성이 30% 더 높다
- 고수준 언어를 사용하는 개발자가 저수준 언어를 사용하는 개발자보다 생산성과 품질이 높다
- 개발자의 사고에 프로그래밍 언어가 미치는 영향이 크다
## 4.2 프로그래밍 규약
- 품질이 우수한 소프트웨어
	- 아키텍처의 개념적 무결성과 저수준 구현 사이의 관계가 명확
	- 구현은 반드시 아키텍처와 일관성을 유지해야 하며 내부적으로도 일관성을 유지
	- **변수 이름, 클래스 이름, 루틴 이름, 형식 규약, 주석 규약이 구현 가이드라인의 핵심**
- 아키텍처 가이드라인을 통해 프로그램의 구조적 균형 유지
- 구현 가이드라인을 통한 프로그래밍 수준 통일성 유지
- 구현 시작 전 사용할 프로그래밍 규약을 작성한다
## 4.3 기술 흐름 파악
- **어떻게 프로그래밍할 것인지가 기술적인 흐름에 좌우된다**
- 기술적으로 성숙 단계에 있다면 새로운 기능을 작성하는 데 대부분 시간을 보내도록 계획을 수립 가능
- 기술적으로 초기 단계 → 프로그래밍 언어의 문서화되지 않은 기능을 알아내고, 라이브러리 코드의 결함으로 생긴 오류를 디버깅하고, 다른 벤더들이 만든 라이브러리를 사용하기 위해 코드 수정에 많은 시간을 할애할 것이다
## 4.4 구현 실천법 선택
- 구현 준비 단계에서는 여러 훌륭한 방법 중 어느 것을 집중적으로 사용할 지를 결정
- **프로젝트에 따라 여러 방법론들을 섞어서 사용**
- 체크리스트: 주요 구현 방법  
	- 코드 작성
		- 설계를 몇 퍼센트 미리 해놓고 몇 퍼센트를 개발 중에 할 것인가?
		- 이름과 주석, 배치에 대한 코드 작성 규약을 정의했는가?
		- 오류 조건을 처리하는 방법이나 보안 문제를 해결하는 방법, 클래스 인터페이스에 사용될 규약, 재사용된 코드에 적용될 기준, 코드를 작성하면서 성능을 얼마나 고려할 것인지 등 구체적인 코드 작성 방법을 정의했는가?
		- 현재 기술적으로 어느 단계에 있는지 파악하고 그에 따라 접근 방법을 적절하게 조절했는가? 필요한 경우, 언어에 의한 프로그래밍 때문에 제약을 받기보다 어떻게 하면 언어를 활용하여 프로그래밍할 것인지 를 살펴봤는가?
	- 협동 작업
		- 통합 절차를 정의했는가? 즉, 코드를 마스터 소스에 체크인(check-in)하기 전에 개발자가 거쳐야 하는 구체적인 단계를 정의했는가?
		- 개발자가 프로그램 작업을 할 때 짝을 지어서 할 것인가, 혼자서 할 것인가? 아니면 두 가지 방법을 어느 정도 결합해서 할 것인가?
	- 품질보증
		- 개발자가 코드를 작성하기 전에 코드에 대한 테스트 케이스를 작성할 것인가?
		- 처음에 하든 나중에 하든 상관없이 개발자가 코드에 대한 단위 테스트를 작성할 것인가?
		- 개발자가 코드를 체크인하기 전에 디버거로 코드를 살펴볼 것인가?
		- 개발자가 코드를 체크인하기 전에 통합 테스트를 할 것인가?
		- 개발자끼리 서로 코드를 리뷰할 것인가?
	- 도구
		- 버전 관리 도구를 선택했는가?
		- 사용할 프로그래밍 언어와 버전 또는 컴파일러 버전을 선택했는가?
		- J2EE나 마이크로소프트 .NET과 같은 프레임워크를 선택했든지 프레임워크를 사용하지 않기로 확실하게 결정했는가?
		- 표준에 맞지 않는 언어의 기능을 사용할지 결정했는가?
		- 편집기, 리팩터링툴, 디버거, 테스트 프레임워크, 문법 검사기와 같이 앞으로 사용할 툴을 정하고 갖췄 는가?
