# 10장 변수 사용 시 고려할 사항

## 10.1 데이터 사용 능력
  
- 데이터 사용 능력 테스트
    - 추상 데이터형
    - 배열
    - 비트맵
    - 불린 변수
    - B-트리
    - 문자 변수
    - 컨테이너 클래스
    - 배정도
    - 열거형
    - 부동 소수점
    - 힙
    - 인덱스
    - 정수
    - 링크드 리스트
    - 이름 상수(named constant)
    - 리터럴
    - 지역 변수
    - 참조 테이블
    - 멤버 데이터
    - 포인터
    - private
    - 참조 무결성
    - 스택
    - 문자열
    - 구조적 변수
    - 트리
    - typedef
    - 공용체
    - variant  
## 10.2 변수 선언을 쉽게 만드는 방법

   - 암시적 선언
	   - 어떤 언어는 암시적인 변수 선언을 지원한다(ex. visual basic)
   - **암시적 선언 기능을 사용하지 않는다.**
	   - 어떤 컴파일러에서는 암시적 선언을 비활성화할 수 있다
   - **모든 변수를 선언한다**
	   - 새로운 변수를 입력할 때 컴파일러가 요구하지 않더라도 변수를 선언한다.
	   - 모든 오류를 잡을 수는 없겠지만, 일부는 잡을 수 있을 것이다
   - **이름 규칙을 정한다**
   - **변수의 이름을 검사한다****
   - 컴파일러나 다른 유틸리티 프로그램으로 생성한 상호 참조 목록을 사용한다
   - 많은 컴파일러가 루틴에 있는 모든 변수를 나열해 변수의 위치를 확인할 수 있도록 한다
   - 선언은 했지만 사용하지 않은 변수도 지적해준다
## 10.3 변수 초기화 가이드라인
- 가이드 라인
	-  부적절한 데이터 초기화는 컴퓨터 프로그래밍에서 오류를 발생시키는 가장 빈도 높은 원인
	- 문제 발생 원인
		- 변수에 값을 할당한 적이 없다. 이 값은 프로그램을 시작했을 때 해당 메모리 공간에 원래 있던 비트 값이 반영 된 것이다
		- 변수에 있는 값이 더는 유효하지 않다. 어떤 위치에서 변수에 값을 할당했지만, 그 변수가 더 이상 유효하지 않다
		- 변수의 일부에는 값을 할당하고 나머지 부분은 값을 할당하지 않았다
	 - 문제를 피하기 위한 가이드 라인
		- **변수를 선언할 때 초기화한다**
        ```java

        float studentGrades[MAX_STUDENTS ] ={0.0};

        ```
		- ***변수가 처음 사용되는 곳 근처에서 초기화한다 → 근접성 원칙***
		- ***이상적으로 각 변수가 처음 사용되는 곳 가까이에 변수를 초기화하고 정의한다***
            ```java

            int accountIndex = 0;

            // accountIndex가 사용되는 코드
            ```

		- ***가능하다면 final이나 const를 사용한다***
		- ***카운터와 누산기를 특히 주의한다***
			- ***카운터와 누산기를 사용한 후 초기화를 잊는 경우가 종종 있다***
		- **클래스의 멤버 데이터를 생성자에서 초기화한다**
			- 클래스의 데이터도 생성자에서 초기화해야한다
			- 메모리가 생성자에서 할당된다면 소멸자에서 해제되어야한다
		- **다시 초기화해야 할 필요가 있는지 검사한다**
		- **이름 상수를 한 번 초기화하고 실행 코드도 변수를 초기화한다**
			- 이름 상수를 모방하기 위한 변수를 사용하고 있다면 해당 변수를 프로그램의 시작 부분에서 초기화한 다음 사용하는 것이 좋다
		- **모든 변수를 자동으로 초기화하는 컴파일러 설정을 사용한다**
			- 컴파일러 설정 후 설정 사용 여부를 확실히 기록한다
		- **컴파일러의 경고 메시지를 활용한다**
		- **입력 매개변수의 유효성을 검사한다**
		- **메모리 접근 도구를 사용해 부적절한 포인터를 검사한다**
		- **프로그램을 시작할 때 메모리를 초기화한다**

	- 접근 방법
		- 메모리 채우기 프로그램을 사용해 메모리를 예상 가능한 값으로 채운다. 0은 초기화되지 않은 포인터가 가장 낮은 메모리를 가리키게 해 해당 포인터가 사용되었을 때 상대적으로 감지하기 쉽게 만들어줌
		- 인텔 프로세서는 0xCC가 breakpoint 인터럽트를 나타내는 기계 코드이므로 사용하기 좋음. 디버거에서 코드를 실행 중일 때 코드가 아니라 0xCC로 초기화되어 있는 데이터를 실행하려고 하면 중단점에서 멈추고, 메모리 덤프에 알아고시 쉬우며 일반적인 목적으로 자주 사용되지 않는다
		- 메모리 채우기를 사용하고 있다면 메모리를 채우는 데 사용하는 값을 임의로 변경할 수 있다. 이를 통해 프로그램을 변경하면 잠재적으로 있었던 문제가 노출되기도 한다
		- 프로그램 시작 시 작업 메모리를 초기화할 수 있다.이것의 목적은 결함을 감추는 데 있다. 작업 메모리를 항상 같은 값으로 채움으로써 프로그램이 초기 메모리에 있는 임의의 값으로부터 영향을 받지 않게 할 수 있다
## 10.4 범위
- 변수에 대한 참조를 지역화하라
	- 변수 참조 사이에 있는 코드는 “취약한 구간”이다. 그러므로 변수에 대한 참조를 가까운 곳에 함께 두어 지역화하는 것이 좋다
- 변수의 “수명”을 가능한 한 짧게 유지한다
	- 변수의 수명은 변수가 참조되는 첫 번째 명령문에서 시작하고 변수가 참조되는 마지막 명령문에서 끝난다
	- 범위와 달리 수명은 벼수가 처음 참조되고 마지막으로 참조되는 사이에 얼마나 많이 참조되었는지에 영향을 받지 않는다
	- 범위와 마찬가지로 수명에 관한 목표도 변수의 수명을 가능한 한 짧게 유지하는 것이고, 수명을 낮추면 취약 구간을 줄일 수 있다
	- 변수의 수명이 짧으면 코드를 이해하기 수월하다 & 코드 가독성이 높아진다
	- 변수의 짧은 수명은 초기화 오류가 발생할 가능성을 줄여준다
	- 짧은 수명은 큰 루틴을 작은 루틴으로 나눌 때 유용하다
- 범위를 최소화하기 위한 일반적인 가이드라인
	
	- **루프에서 사용되는 변수는 루프를 포함하고 있는 루틴의 시작이 안쪽 루프 바로 앞에서 초기화한다**
		- ***변수를 사용하기 바로 전까지 변수에 값을 할당하지 않는다***

        ```java
        int receiptIndex = 0;
        float dailyReceipts = TodaysReceipts();
        double dailyReceipts = TodaysReceipts(dailyReceipts);
        ```
	- ***연관된 명령문을 그룹화한다***
	- ***연관된 명령문 그룹을 별도의 루틴으로 나눈다***
	- ***처음에는 범위를 최대한 제한하고 필요한 경우에만 변수의 범위를 늘린다***

- 범위 최소화에 대한 조언
	- 실제로 범위를 최대화하면 프로그램을 작성하기는 쉽지만, 모든 루틴에서 언제든지 모든 변수를 사용할 수 있는 프로그램은 잘 나뉜 루틴을 사용하는 프로그램보다 이해가 어렵다
	- 전역 데이터를 공유하는 루틴과 함께 다른 루틴을 이해해야만 한다	
	- 그러므로 각 변수의 범위를 되도록 좁게 유지해야한다

## 10.5. 지속성
- 지속성
	- 지속성의 형태
		- 특정한 코드 블록이나 루틴에서만 살아있는 경우
		- 특정 기간만 살아있는 경우
		- 자바에서 new로 생성한 변수는 GC가 발생할때까지 살아있다
		- 프로그램이 종료할 때까지 살아있는 경우. 대부분의 프로그래밍 언어에서 전역 변수, java의 static이 여기에 속한다
		- 영원히 살아 있는 경우
			- 지속성의 가장 큰 문제는 변수가 실제보다 더 오랫동안 지속된다고 가정할 때 발생한다.
- 이를 피하는 방법
	- 중요한 변수가 적절한 값을 갖는지 검사하기 위해서 프로그램에 디버그 코드나 어설션을 사용한다. 값이 적절하지 않다면 부적절한 초기화 코드를 찾도록 경고 메시지를 출력한다
	- 변수를 사용하고 나면 그 변수를 “부적절한 값”으로 설정한다. 예를 들어 포인터를 삭제한 다음 null 값으로 설정할 수 있다
	- 데이터가 지속적이지 않다고 가정하는 코드를 작성한다. 가령 루틴을 빠져날 때 변수가 특정한 값을 갖고 있다면 그다음 루틴에 들어올 때 값은 값을 갖고 있을 거라고 가정하지 않는다. 자바의 static 같은 값이 계속해서 남아있다는 것을 보장하는 언어의 특화된 기능을 사용하고 있는 경우는 예외다
	- 모든 데이터를 사용하기 바로 직전에 초기화하는 습관을 들인다.사용된 곳 근처에서 초기화하지 않은 데이터가 있다면 의심한다
## 10.6 결합 시점

- 결합 시점(binding time)
	- 정의 : 변수와 그 값이 서로 연결된 시간
	- 프로그램의 유지 관리와 변경 용이성 면에서 광범위하게 관련된 초기화에 대한 주제
	- 결합 시점을 가능한 한 늦추는 것이 이로움

    ```java

    // titleBar.color를 변경하기 위해 프로그램을 변경 필요 X , ReadTitleBarColor

    // ReadTitleBarColor의 데이터만 변경하면 됨

    titleBar.color = ReadTitleBarColor();

    ```

- 변수가 값에 결합될 수 있는 시간
	- 코드 작성 시간(매직 넘버 사용)
	- 컴파일 시간(이름 상수 사용)
	- 로드 시간(윈도우 레지스트리 파일이나 자바 속성 파일과 같은 외부의 소스로부터 값을 읽어들임)
	- 객체 생성 시간(윈도우가 생성될 때마다 값을 읽어 들임)
	- 적시에(윈도우가 그려질 때마다 값을 읽어들임)

## 10.7 데이터형과 제어 구조 사이의 관계

  - Jackson의 세 가지 데이터와 그에 따른 제어 구조 관계
	- **순차적 데이터는 프로그램의 순차적 명령문으로 변환한다**
		- 특정한 순서로 사용된 데이터의 집합으로 구성
		- 서로 다른 5개의 값을 처리하는 5개의 명령문을 일렬로 작성했다면 그 명령문은 순차적인 명령문이다

            ![[codeComplete22.png]]
	- ***선택적 데이터는 프로그램에서 if와 case 명령문으로 변환한다***
		- 특정한 시간에 여러 개의 데이터 중 오직 하나만 사용되는 데이터 집합
				![[codeComplete23.png]]
    - ***반복되는 데이터는 프로그램에서 for, repeat, while 루프 구조로 변환한다***
	- 여러 번 반복되는 같은 형식의 데이터
	- 컨테이너의 요소, 파일의 레코드, 배열의 요소로 저장
		![[codeComplete24.png]]

## 10.8 변수를 한 가지 목적으로만 사용하는 방법

- 변수를 정석적으로 사용하기
	- **각 변수를 한 가지 목적만을 위해서 사용하라**
```java

        discriminant = Sqrt( b*b - 4*a*c);

        root[0] = (-b + discriminant ) / (2 * a);

        root[1] = (-b - discriminant ) / (2 * a);

        // root를 교환한다

        oldRoot = root[0];

        root[1]= root[0];

        root[1]= oldRoot;

```

- ***숨은 의미가 있는 변수를 피하라***
	- 이런 방식으로 변수를 남용하는 것을 “하이브리드 커플링”이라 한다.
	- 예시
		- pageCount 변수에 있는 값은 출력된 페이지의 수를 나타낸다. 하지만 이 값이 -1이면 오류가 발생했다는 것을 가리킨다 ⇒ **pageCount라는 정수가 boolean 값을 대신하고 있다**
	- ***선언된 모든 변수를 사용하는지 확인하라***
- 체크리스트
	![[codeComplete25.png]]
# 11장 변수 이름의 기능

## 11.1 좋은 이름을 위한 고려 사항 

- 이름을 지을 때 가장 중요한 고려 사항
	- 변수 이름을 지을 때 그 이름이 변수가 나타내는 것을 완전하고 정확하게 설명하는지를 가장 중요하게 고려해야 한다
	- 좋은 이름을 생각해내는 효과적인 기법은 변수가 표현하는 것을 단어로 서술하는 것
	- 좋은 이름의 특징
        - 해석하기 쉬움
		- 예시 - currentDate, todaysDate
	- 이름은 가능한 한 구체적이어야 한다
- 문제 지향
	- 좋은 이름은 “어떻게” 보다 “무엇”을 표현하는 경향이 있다
	- 예시
	        - 직원의 데이터에 대한 레코드 - *inputRec, employeeData*
- 최적의 이름 길이
    - 변수 이름의 길이가 평균적으로 문자 10자 ~ 16자 사이일 때 디버깅하기 위해 들이는 노력을 최소화 할 수 있다(Gorla, A. C. Benander, and B.A. Benander 1990)
    - 너무 길거나, 너무 짧거나 적당한 길이의 변수 이름
	- 너무 길다 - *numberOfPeopleInTheUsOlympicTeam*
	- 너무 짧다 - *n, np ,ntm*
	- 적당하다  - *numTeamMembers, teamMemberCount*
- 범위가 변수명에 미치는 효과
	- 긴 이름은 거의 사용하지 않은 변수나 전역 변수에 좋고 짧은 이름은 지역 변수나 반복문 변수에 좋다
	- ***전역 네임스페이스에 있는 변수에는 한정자를 사용하라***
        - 예시 - java는 package에 사용

```java
namespace UserInterfaceSubSystem {
                ...
}
```
- 변수 이름의 계산값 한정자
	- *Total, sum, Average, Max,Min,Record, String, Pointer와 같은 한정자로 변수의 이름을 만들 경우 이름 끝에 한정자를 입력*
        - 예시 - *revenueTotal, expenseTotal*
	- 장점
		- 변수 이름에서 가장 중요한 변수의 의미를 가장 잘 전달하는 부분이 앞부분이기 때문에 가장 눈에 띄고 잘 파악된다
		- 이름이 의미상 동일하지만 규약을 통해 그것들이 서로 다르게 사용되는 것을 막을 수 있다
		- 변수 이름이 정돈된 느낌을 준다

- 예외
	- **Num 한정자의 관습적 위치**
		- 변수 이름 앞의 Num → 총계
		- numCustomer → 전체 고객 수
		- 변수 끝 Num → 인덱스
			- customerNum → 현재 고객 번호
- 일반적인 변수명의 반의어
	- 반의어를 정확하게 사용하라
        - 반의어에 대한 이름 규약을 사용하면 일관성을 유지하고 가독성을 높이는데 도움이 된다
- 일반적인 반의어
	- begin/end
	- first/last
	- locked|unlocked
        - min|max
        - next|previous
        - old|new
        - opened|closed
        - visible|invisible
        - source|target
        - source|destination
        - up|down

## 11.2 특정 타입의 데이터 이름 짓기
- 반복문 인덱스 이름
	- *i, j k 와 같은 이름을 관습적으로 사용*
	- **i, j, k는 간단한 반복문의 인덱스 외의 용도로는 사용하지 않는다**
- 변수를 반복문 외부에서 사용해야 한다면 좀 더 이름있는 이름으로 작성
```java
recordCount = 0;
while (moreScores()) {
	...
	recordCount++;  
}
```
- 여러 개의 중첩된 반복문이 있다면 가독성 향상을 위해 좀 더 긴 이름으로 반복문 변수 작성
```java
for (teamIndex = 0; teamIndex < teamCount; teamIndex++) {
	for (eventIndex = 0; eventIndex< eventCount[teamIndex]; eventIndex+) {
		score[teamIndex][eventIndex] = 0;
	}
}
```
- 상태 변수 이름
	- OOFlag 보다 의미 있는 이름으로 작성하라
- 임시 변수 이름
	- ***임시 변수를 조심하라***
	- 임시 변수의 이름을 실질적인 변수로 대체하는 코드 예시
```java
discriminant = sqrt(b^2 -4*a*c);
root[0] = (-b + discriminant) / ( 2 * a);
root[1] = (-b - discriminant) / ( 2 * a);
```
- 불린 변수 이름
	- ***전형적인 불린 변수의 이름을 기억한다***
		- done
			- 무언가 수행되었다는 것을 가리키기 위해 done을 사용
			- 이 변수는 반복문이 수행되었거나 다른 연산이 수행되었음을 가리킬 수 있다
			- 무언가가 처리되기 전에 done을 false로 하고 완료 후 true로 설정
		- error
			- 오류가 발생했음을 가리키기 위해 error를 사용한다
			- 오류가 발생했을 때 이 변수를 true로 설정하고 오류가 발생하지 않았을 때 false로 설정

		- found
			- 값이 발견되었다는 것을 가리키기 위해서 found를 사용한다
			- 값이 발견되지 않았을 때 false, 값이 발견되었을 때 true로 설정		
			- success 또는 ok
			- 연산이 성공적인지 가리키기 위해서 success 또는 ok를 사용
			- 연산이 실패했을 때 false로 설정하고 성공 시 true로 설정
			- success는 성공했다는 것을 좀 더 정확하게 설명하는 구체적인 이름으로 대체한다

- ***참이나 거짓의 의미를 함축하는 불린 변수의 이름을 사용한다***
	- done, success → 좋은 변수 이름
	- status, sourceFile → 참이나 거짓이 명백하지 않아 좋지 못한 불린 이름이다

- ***긍정적인 불린 변수 이름을 사용한다***
	- notFound 보단 Found

- 열거형의 이름
	- 접두사를 사용해 해당 타입의 멤버가 모두 같은 그룹에 속한다는 것을 보장하도록 함

```java

Public Enum Color 
	Color_Red
	Color_Green
	Color_Blue
End Enum

Public Enum Planet
	Planet_Earth
	Planet_Mars
	Planet_MVenus
End Enum

```
- 상수 이름
	- 상수가 가리키는 숫자보다 상수가 표현하는 추상적인 대상을 나타내야 한다
        - ***CYCLES_NEEDED, DONUTS_MAX***
## 11.3 이름 규약의 효과 

- 왜 규약이 필요한가
	- 규약의 이점
		- 더 많은 것을 당연하게 받아들인다. 상황에 따라 달라지는 결정이 아니라 한 가지로 일관된 결정을 하면 코드의 더 중요한 특성에 집중할 수 있다	
		- 다른 프로젝트에서도 지식을 활용하는 데 도움을 준다. 유사한 이름을 사용하면 익숙하지 않은 변수가 무엇을 해야 하는지에 대해 더 쉽고 확실하게 이해하는 데 도움이 된다
		- 새로운 프로젝트에서 좀 더 빠르게 코드를 배우게 해준다. 그롤 통해 일관성이 있는 코드로 작업할 수 있다
		- 이름이 늘어나는 것을 줄여준다
		- 언어의 약점을 보완한다. 규약은 지역, 클래스, 전역 데이터를 구별할 수 있으며 컴파일러가 지원하지 않는 타입에 대한 타입 정보를 만들 수 있다
		- 관련된 항목 사이의 관계를 강조한다. 사용하는 프로그래밍 언어가 객체를 지원하지 않는다면 이름 규약으로 이를 보완할 수 있다
			- employeeAddress, employeePhone, employeeName의 관련이 되어 있다는 것을 유추할 수 있다
- 언제 이름 규약이 필요한가
	- 규약이 유용한 겨우
		- 한 프로젝트에서 여러 명의 개발자가 작업하고 있을 때
		- 변경이나 유지보수 때문에 프로그램을 다른 개발자에게 넘겨주어야 할 땨
		- 조직 내에 있는 다른 개발자가 프로그램을 검토해야 할 때
		- 프로그램이 너무 커서 한 번에 기억할 수 없기 때문에 반드시 부분적으로 나누어 생각해야 할 때
		- 프로그램의 수명이 길어서 몇 주나 몇 달 동안 프로그램을 제쳐 뒀다가 나중에 작업해야 할 때
		- 프로젝트에서 자주 쓰이는 특이한 용어가 많아서 코드 작성 시 사용할 표준 용어나 약어를 갖고자 할 때
- 형식을 따르는 정도
	- 형식화 정도는 프로그램에서 작업하는 사람들의 수와 프로그램의 크기, 프로그램의 예상 수명에 따라 달라진다
	- 작고 일시적인 프로젝트는 엄격한 규약이 불필요한 오버헤드지만, 여러 사람이 참여하는 큰 프로젝트에서는 초기 단계나 프로그램이 사용되는 내내 형식적인 규약이 코드를 이해하는 데 도움이 된다
## 11.4 비형식적인 이름 규약
- 개발 언어에 독립적인 규약을 위한 가이드라인
	- ***변수의 이름과 루틴의 이름을 구별한다***
        - 변수와 객체는 소문자로 시작하고, 루틴의 이름은 대문자로 시작하는 것
- ***클래스와 객체를 구별한다***
	- 클래스 이름과 객체의 이름, 타입과 그 타입의 변수 사이의 일치는 다루기 힘들 수 있다
	- 방법 1 - 첫 번째 문자를 대문자로 작성해 타입과 변수를 구분함
		- 일반적인 규약이고, 두 이름 사이의 외형상 차이가 작음
```java	
Widget widget;
LongerWidget longerWidget;
```
- 방법 2 - 모든 문자를 대문자로 작성해 타입과 변수를 구분함
	- 다양한 언어 환경에서는 문제가 있다
```java
WIDGET widget;
LONGERWIDGET longerWidget;
```
- 방법 3 - 타입에 대해 “t_”라는 접두사를 넣어 타입과 변수를 구분함
	- 모든 언어에 적당한 효과가 있지만, 어떤 개발자들은 접두사를 사용하는 스타일을 싫어한다
```java
t_Widget widget;
t_LongerWidget longerWidget;
```
- 방법 4 - 변수에 대해 “a”라는 접두사를 넣어 타입과 변수를 구분함
	- 클래스의 이름을 하나만 사용하는 대신 클래스의 모든 인스턴스 이름을 변경해야한다
```java
t_Widget widget;
t_LongerWidget longerWidget;
```
- 방법 5 - 좀 더 구체적인 변수의 이름을 사용해 타입과 변수를 구분함
		- 변수에 대해 더 많이 생각해야한다
```java
Widget empllyeeWidget;
LongerWidget fullEmployeeWidget;
```
- ***전역 변수를 식별한다***
	- 예시 - *g_RunningTotal*
- ***멤버 변수를 식별한다***
	- 클래스의 멤버 데이터를 구분한다
	- m_\[클래스 멤버 이름]
- ***타입 선언을 식별한다***
- ***이름 상수를 식별한다***
	- 다른 변수에 있는 값을 할당하고 있는 것인지 아니면 이름 상수에 있는 값을 할당하고 있는 것인지를 구분해야 한다
	- 상수 이름을 만드는 방법
		- c_\[상수이름]
- ***열거형의 요소를 식별한다***
	- 열거형 요소가 열거형을 위한 것이라는 점을 쉽게 보여줄 수 있게 구분해야 한다
	- 모든 문자를 대문자로 쓰거나 타입 이름 자체를 접두사 e_ 나 E_를 사용
- ***입력만 하는 매개변수를 지정할 수 없는 언어에서는 이를 식별한다***
	- 어떤 프로그래밍 언어에서는 입력 변수를 수정하면 원하는 값이 반환될 수도 있고 아닐 수도 있다
		- 자바에서는 모든 객체가 “값으로” 전달되기 때문에 루틴에 객체를 전달할 때 객체의 내용이 호출된 루틴에서 변경될 수 있다
- ***가독성을 위해 이름에 서식을 지정한다***
	- 대문자를 사용하는 것
	- 공백 문자를 사용해 단어를 구한하는 것
- 언어별 가이드라인
	- 자바 규약
        - ***i, j는 정수 인덱스***
        - ***상수는 ALL_CAPS처럼 밑줄로 구분되는 대문자로 표현된다***
        - ***클래스와 인터페이스 이름은 ClassOrInterfaceName과 같이 첫 번째 단어를 포함해 각 단어의 첫 글자를 대문자로 작성한다***
        - ***변수와 메서드의 이름은 variableOrRoutineName과 같이 첫 번째 단어를 소문자로 작성하고 다음 단어부터는 첫 번째 문자를 대문자로 작성한다***
        - ***밑줄은 대문자로만 이루어진 이름을 제외하고는 이름에서 구별자로 사용되지 않는다***
        - ***접두사 get과 set은 접근자 메서드에 사용***
- 여러 언어로 개발할 때 고려할 사항
	- 다중 언어 환경에서 프로그래밍할 때 형식화 규약과 문서화 규약, 다른 규약과 마찬가지로 이름 규약도 일관성과 가독성 면에서 최적화 할 수 있다
- 이름 규약 예제

| 요소                   | 설명                                                                                    |
| -------------------- | ------------------------------------------------------------------------------------- |
| ClassName            | 클래스 이름은 첫 번째 문자가 대문자이면서 대문자와 소문자를 섞어서 사용한다                                            |
| TypeName             | 열거형과 typedef를 포함한 타입 선언에는 첫 번째 문자가 대문자이면서 대문자와 소문자를 섞어서 사용한다                          |
| EnumeratedTypes      | 앞의 규칙과 더불어 열거형은 항상 복수형으로 기술한다                                                         |
| localVariable        | 지역 변수는 첫 번째 문자가 소문자이면서 대문자와 소문자를 섞어서 사용한다. 이름은 내부 데이터형과 독립적이어야 하며 변수가 표현하는 것을 가리켜야 한다 |
| routineParameter     | 루틴의 매개변수는 지역 변수와 같은 형식으로 작성한다                                                         |
| RoutineName()        | 루틴의 이름은 대문자와 소문자를 섞어서 사용한다                                                            |
| m_ClassVariable      | 클래스 내의 여러 루틴에서 사용 가능하지만 오직 클래스 안에서만 사용되는 변수에는 접두사 m_을 사용한다                            |
| g_GlobalVariable     | 전역 변수에는 접두사 g_를 사용한다                                                                  |
| CONSTANT             | 이름 상수는 대문자와 밑줄로 이루어진다                                                                 |
| MACRO                | 매크로는 대문자와 밑줄로 이루어진다                                                                   |
| Base_EnumberatedType | 열거형에는 Color_Red와 Color_Blue와 같이 단수형 기본 타입을 연상할 수 있는 접두사를 사용한다                         |
## 11.5 표준 접두사

- 사용자 정의형(UDT)
	- 이름이 있는 객체나 변수의 데이터형
	- 프로그래밍 언어에서 제공되는 기본 데이터형을 가리키지는 않는다
	- 예 - *ch, doc, pa, scr,sel*
- 의미적 접두사
	- 변수나 객체가 어떻게 사용되는지 설명
	- 예시
		- i ⇒ 배열에 대한 인덱스
		- last ⇒ 배열에서 다루어야 하는 마지막 요소
- 표준 접두사의 장점
	- 모호해지기 쉬운 이름 영역을 정확하게 만든다
	        - min, first, last, max 사이의 정확한 구분 특히 도움이된다
	- 이름을 더욱 간결하게 만든다
		- totalParagraphs 대신 cpa
	- 컴파일러가 검사할 수 있는 추상 데이터형을 사용할 때 타입을 정확하게 검사할 수 있다
## 11.6 읽기 쉬운 짧은 이름
- 일반적인 축약어 가이드라인
	- 표준 축약어를 사용한다(사전에 나와 있는 널리 사용되는 언어)
	- 불필요한 모음을 제거한다(computer를 cmptr, screent은 scrn)
	- 관사와 접속사를 제거한다(and,or,the,end 등)
	- 각 단어의 첫 번째 문자나 처음 문자 몇개를 사용한다
	- 첫 번째나 두 번째, 세 번째 문자(적절한 선에서) 일관성있게 단어를 자른다
	- 각 단어의 첫 번째와 마지막 문자를 유지한다
	- 이름에서 가장 중요한 단어를 최대 세 단어까지 사용한다
	- 불필요한 접미사를 제거한다
	- 각 음절에서 가장 뚜렷한 소리를 유지한다
	- 변수의 의미를 변경하지 않도록 한다
	- 각 변수 이름의 길이가 8~20자 사이거나 사용하는 언어가 변수의 이름을 제한한 문자 수학 될 때까지 이 기법을 반복적으로 사용한다
- 음성 축약
	- 소리 기반으로 한 축약어 생성
		- skating → sk8ing
- 축약어에 대한 의견
	- 함정을 피하기 위한 규칙
		- ***단어에서 한 문자를 없애는 방법으로 축약하지 않는다***
		- **June → Jun으로 하는 방식은 사용하지 않는다**
        - ***일관성 있게 축약한다***
		- 항상 같은 축약어를 사용하라
		- Num이나 No를 동시에 사용하지 말고 둘 중 하나만 사용하라
        - ***발음할 수 있는 이름을 만든다***
		- ndsCmptg대신 needsComp를 사용하라
        - ***잘못된 발음을 유발할 수 있는 조합을 피한다***
		- B의 끝을 가리키기 위해 *BEND 대신 ENDB를 사용한다*

        - ***이름 충돌을 해결하기 위해서 유의어 사전을 사용한다***
		- 같은 영역에서 fired와 full revenue disbursal을 사용하는 경우 두 단어 모두 frd로 축약할 수 있음
		- 같은 의미가 있는 다른 단어를 사용하는 것으로 회피
			- fired → dismissed로
			- full revenue disbursal → complete revenue disbursal
        - ***매우 짧은 이름은 코드 내 변환 테이블을 사용해 문서화한다***
        - ***모든 축약어를 프로젝트 수준의 “표준 축약어” 문서에 기록한다***
		- 축약어가 발생시키는 위험
			- 코드를 읽는 사람이 축약어를 이해하지 못할 수 있다
		- 다른 개발자가 같은 단어에 대해 여러 가지 다른 축약어를 사용해 쓸데없는 혼란은 초래할 수 있다
		- **이를 해결하기 위해 “표준 축약어” 문서를 작성**
	- ***이름은 코드를 작성하는 사람보다 읽는 사람에게 더 주요하다는 점을 기억한다***
## 11.7 피해야 할 변수 이름
- 피해야할 변수 이름에 대한 가이드 라인
	- ***오해의 소지가 있는 이름이나 축약어를 피한다***
	- ***유사한 의미가 있는 이름을 피한다***
		- 프로그램에 해를 주지 않고 두 변수의 이름을 교환할 수 있다면 이름을 다시 만들 필요가 있다
	        - input, inputValue, recordNum & numRecords
	- ***이름은 유사하지만 의미가 다른 변수를 피한다***
		- 이름은 유사하지만 의미가 다른 두 변수가 있다면 어느 하나의 이름을 다시 만들거나 축약 규칙을 변경하도록 한다
		- clientRecs와 ClientReps와 같은 이름은 피한다
- ***이름에 숫자를 넣는 것을 피한다***
	- ***file1, file2와 같은 변수 이름은 지양***
	- ***이름에 철자가 틀린 단어가 없도록 한다***
	- ***영어에서 일반적으로 잘못 표기되는 단어를 피한다***
	- ***대소문자만으로 변수의 이름을 구분하지 않는다***
	- ***여러 가지 자연어를 사용하지 않는다***
	- 한 가지 버전의 영어로 표준화하라
		- color, colour, check, cheque 중 어느 것을 사용할 지 미리 정하라
	- ***표준 데이터형과 변수, 루틴의 이름은 사용하지 않는다***
	- ***변수가 표현하는 것과 전혀 관련이 없는 이름을 사용하지 않는다***
	- ***읽기 어려운 문자를 포함하는 이름을 피한다***
        - 예시
            - eyeChart1,eyeChartI, eyeChartl
## 체크리스트
![[codeComplete26.png]]
![[codeComplete27.png]]
# 12장 기본 데이터형
## 12.1 숫자 일반

- 숫자를 사용할 때 오류를 유발 피하기
	- ***“매직 넘버”를 피한다***
		- 매직 넘버는 아무런 설명도 없이 프로그램 중간에 사용하는 숫자
		- 이름 상수를 지원하는 프로그래밍 언어를 사용 중이라면 이름 상수를 대신 사용하도록 한다
		- 이름 상수를 사용할 수 없는 경우 전역 변수를 사용한다
		- 매직 넘버를 사용하지 않을 때 얻는 이득
			- 더욱 안정적으로 변경할 수 있다. 이름 상수를 사용하면 프로그램에 여기저기 흩어져 있는 숫자를 살펴보거나 변경하지 않아야 할 숫자를 다른 무언가로 변경하지 않을 것이다
			- 더욱 쉽게 변경할 수 있다. 어떤 조건의 최댓값이 100에서 200으로 변할 때 매직 넘버를 사용한다면 모든 100을 찾아서 200으로 변경해야 한다
			- 코드의 가독성이 높아진다
- ***필요하다면 0과 1은 그냥 사용한다***
	- 프로그램에서 나타나도 좋은 유일한 숫자는 0과 1뿐이다
	- 그 밖의 다른 상수 값은 값이 의미하는 바를 명확하게 나타내는 다른 무언가로 대체해야한다

- ***0으로 나눔 오류를 미리 방지한다***
	- 나누기 기호를 사용할 때마다 분모가 0이 될 가능성이 있는지 생각해야한다
- ***형 변환을 명시적으로 처리한다***
	- 코드를 읽는 사람이 서로 다른 데이터형 사이에 변환이 일어나고 있음을 알아차릴 수 있도록 해야한다
```jsx
y = x + (float) i
```
- ***서로 다른 형을 비교하지 않는다***
- ***컴파일러의 경고에 주의를 기울인다***
## 12.2 정수

- 정수를 사용할 때 고려해야할 사항
	- ***정수 나눗셈을 검사한다***
		- 정수를 사용할 때 7 나누기 10은 0.7이 아니다
	- ***정수 오버플로를 검사한다***
        - 서로 다른 정수형의 범위를 검사해야한다
        - 정수 오버플로를 예방하는 가장 쉬운 방법은 수학 표현식에 있는 각 항을 살펴본 후 각 항이 만들 수 있는 최댓값을 생각해보는 것이다.
	- ***중간 결과에서의 오버플로를 검사한다***
```jsx
termA = 1000000;
termB = 1000000;
product = termA * termB / 1000000;
// ( 1000000 * 1000000 ) / 1000000 = -727
//( 1000000 * 1000000 ) 계산에서 정수 오버플로가 발생한다
```
## 12.3 부동 소수점 수
- 부동 소수점 수 사용 시 고려해야할 점
	- 많은 분수 값이 디지털 컴퓨터의 1과 0을 사용해 정확하게 표현될 수 없다
	- 부동 소수점 수를 사용할 때 참고해야할 지침
	- ***서로 크기가 매우 다른 수를 더하거나 빼지 않는다***
		- 크게 차이가 나는 숫자를 더해야 한다면 우선 숫자를 구분하고 가장 작은 값부터 더한다
		- 무한한 수를 더할 때도 가장 작은 항부터 시작한다
        - ***동치 비교를 피한다***
		- 부동 소수점은 같은 숫자에 대해 서로 다르게 계산하면 같은 결괏값이 나오지 않는다
		- 0.1을 10번 더해도 1.0이라는 답을 얻기 어렵다
		- 효과적인 접근 방법은 적당한 정확도의 범위를 결정해 값이 충분히 근사한지 결정하기 위한 불린 함수를 사용하는 것
	- ***라운딩 오류를 예측한다***
		- 더 큰 정밀도를 갖는 변수형으로 변경한다. 단정도(single-precision) 부동 소수점을 사용하고 있다면 배정도(double-precision) 부동 소수점으로 변경한다
		- 이진화 십진 표기법 변수로 저장한다. BCD(binary coded decimal) 스키마는 전형적으로 느리고 많은 공간을 차지하지만, 많은 라운딩 오류를 막아준다
		- 부동 소수점을 정수형 변수로 변경한다.

	- 특정한 데이터형을 지원하는 언어와 라이브러리가 있는지
```java
final double ACCEPTABLE_DELTA = 0.0001;
boolean Equals( double Term1, double Term2) {
	if (Math.abs( Term1 - Term2) < ACCEPTABLE_DELTA) {
		return true;
	}else{
		return false;
	}
}
```
## 12.4 문자와 문자열

- 문자열을 사용하는 팁
	- ***매직 문자와 문자열을 사용하지 않는다***
		- 매직 문자는 리터럴 문자(ex. ‘A’)고 매직 문자열은 프로그램 전체에 나타나는 리터럴 문자열(”기가매틱 회계 프로그램”) 이다
	        - 이름 상수를 지원하는 언어라면 이름 상수를 대신 사용.그렇지 않다면 전역 변수를 사용한다
        - 리터럴 문자열 사용을 피해야하는 이유
		- 프로그램의 이름, 명령 이름, 보고서 제목과 같이 자주 나타나는 문자열은 어느 시점에서 해당 문자열의 내용을 변경할 필요가 있다
		- 프로그램 전체에 걸쳐 문자열을 해당 언어로 변환하는 것보다 문자열 리소스 파일에 모아 놓은 문자열을 변환하는 것이 더 쉽다
		- 문자열 리터럴은 많은 공간을 차지한다. 너무 많아지면 제어할 수 없어지고 메모리 문제도 유발한다.
		- 문자와 문자열 리터럴은 의미가 분명하지 않다. 주석이나 이름 상수는 의도를 이해하기 쉽게 만든다
	- ***하나 차이로 인한 오류를 주의한다***
		- 부분 문자열은 배열처럼 인덱스로 나타낼 수 있기 때문에 문자열의 범위를 지나서 읽거나 쓰는 하나 차이로 인한 오류에 주의한다
	- ***자신이 사용하고 있는 언어와 환경에서 유니코드를 어떻게 지원하는 알아둔다***
	- ***국제화/지역화 전략을 초기에 결정한다***
	- 외부 리소스에 모든 문자열을 저장해야 할지, 각 언어에 대한 개별적인 빌드를 생성할 지 아니면 실행 시 특정 언어를 결정할지를 결정해야한다
	- ***알파벳 기반의 단일 언어를 지원할 필요가 있다는 사실을 안다면 ISO 8859 문자 집합 사용을 고려한다***
	- ***다중 언어를 지원해야 한다면 유니코드를 사용한다***
	- ***문자열 형 사이에 일관된 변환 전략을 결정한다***
```jsx
if (input_char == 0x18) ... --> 나쁘다
if (input_char == ESCAPE) ... --> 더 낫다
```

## 12.5 불린 변수
- 불린 변수 잘 사용하기
	- ***프로그램을 문서화하기 위해서 불린 변수를 사용한다***
        - 불린 표현식을 테스트하는 대신 표현식의 의미가 더욱 명확해지게 변수에 할당한 후 테스트를 수행해도 된다
        - 예시 - 불린 테스트의 목적이 명확하지 않은 자바 예제
```jsx
if ( ( elementIndex < 0 ) || (MAX_ELEMENTS < elementIndex) || (elementIndex == lastElementIndex) ){
}
```

- 예시 - 불린 테스트의 목적이 명확한 자바 예제

```jsx
finished = (( elementIndex < 0 ) || (MAX_ELEMENTS < elementIndex));
repeatedEntry =  (elementIndex == lastElementIndex) ;
if (finished || repeatedEntry) {

}
```

- ***복잡한 테스트를 단순화하기 위해 불린 변수를 사용한다***
	- 테스트를 단순하게
- **필요하다면 사용자 정의 불린 형을 만든다**
	- enum 타입을 통한 boolean 정의 예제
```jsx
enum Boolean {
	True = 1,
	False = (!True)
}
```
## 12.6 열거형

- 열거형 사용 지침
	- ***가독성 향상을 위해 열거형을 사용하라***
	- ***안정성을 위해 열거형을 사용하라***
	- ***변경하기 쉽게 열거형을 사용하라***
	- ***불린 변수에 대한 대안으로 열거형을 사용하라***
	- ***유효하지 않은 값을 검사하라***
	        - 열거형의 값이 유효한지 확인하는 if 혹은 case 작성하라
	- ***반복문의 범위를 지정하기 위해 열거의 처음과 마지막 항목을 정의하라***
	- ***열거형의 첫 번째 항목을 유효하지 않은 값으로 넘겨라***
	- ***프로젝트 코드 작성 표준에서 처음과 마지막 요소가 어떻게 사용될 것인지를 정확하게 정의한 후 일관성 있게 사용하라***
	- ***열거형의 요소에 명시적인 값을 할당할 때 발생할 수 있는 위험 요소를 주의하라***
- 언어가 열거형을 지원하지 않는 경우
	- 열거형을 흉내내는 자바 예제
```java
class Country {
	private Counter(){}
	public static final Country China = new Country();
	public static final Country England = new Country();
	public static final Country France = new Country();
	public static final Country Germany = new Country();
	public static final Country India = new Country();  
	public static final Country Japen = new Country();

}
```
## **12.7 이**름 상수
- 이름 상수 사용 지침
	- 이름 상수 → 처음 할당한 후로 상수의 값을 변경할 수 없다는 점을 제외하면 변수와 비슷하다
	- 이름 상수를 사용하면 프로그램을 “매개변수화”할 수 있다 ⇒ 변경이 있을  수 있는 프로그램의 특징을 매개변수로 입력하여 프로그램을 수정할 필요가 있는 경우 프로그램 전체를 변경하지 않고 한 곳에서 변경할 수 있다
	- ***데이터 선언에 이름 상수를 사용하라***
        - 이름 상수를 사용하면 데이터 선언부와 데이터의 크기를 알아야 하는 명령문을 이해하기 쉽고 유지보수에도 도움이 된다
```java
const LOCAL_NUMBER_LENTGH = 7
TYPE PHONE_NUMBER
localNumber(LOCAL_NUMBER_LENTGH ) As String
End Type
```
- ***“명백한” 리터럴이라도 리터럴은 피하라***
- 예시

```java
for month = 1 To NUM_MONTHS_IN YEAR
profit (month) = revenue(month) - expense(month)
Next
```
- 범위가 적절하게 지정된 변수나 클래스를 사용해 이름 상수를 흉내내라
	- 사용하는 언어가 이름 상수를 지원하지 않는다면 직접 만들어라
	- 지역 변수가 최우선이고 클래스 범위, 전역 변수 순의 전형적인 범위 규칙을 적용
- ***이름 상수를 일관성 있게 사용하라***
## 12.8 배열

- 배열 사용 팁
	- ***배열의 모든 인덱스가 배열의 경계 내에 있는지 확인하라***
		- 제일 많이 일어나는 문제는 프로그램이 경계를 벗어나 배열의 요소에 접근하려고 할 때 발생
- ***배열 대신 컨테이너 사용을 고려하거나 배열을 순차적인 구조체로 생각하라***
	- 배열을 사용하는 대신 요소에 순차적으로 접근하는 집합이나 스택, 큐를 사용해보자
	- 무의식적으로 배열을 선택하기 전에 순차적으로 접근할 수 있는 집합이나 스택, 큐와 같은 컨테이너 클래스 사용을 고려하라

- ***배열의 마지막 위치를 확인하라***
	- 반복문이 끝나는 위치를 잘 생각하는 것이 유용한 것처럼 배열의 마지막 위치를 확인함으로써 많은 오류를 해결할 수 있다
- ***다차원 배열에서는 인덱스가 정확한 순서대로 사용되는지 확인하라***
- ***인덱스가 혼선되지 않도록 주의하라***
## 12.9 새로운 형 만들기(형 별명)

- 새로운 형 만들기
	- 새로운 형을 만들어야 하는 이유
		- **수정하기 쉬워진다**
		- 새로운 형을 생성하는 일은 많은 작업을 요구하지 않으며 유연성에 큰 도움을 준다
        - **과도하게 정보를 분산시키는 것을 피할 수 있다**
        - **신뢰성을 향상시킨다**
        - 언어의 약점을 보완한다
		- 원하는 형을 언어에서 지원하지 않는 경우, 직접 새로운 형을 만들 수 있다
```java
typedef int Boolean;
```
- 새로운 형을 만들기 위한 지침
	- ***기능 지향적인 이름으로 형을 생성하라***
		- 해당 형의 바탕이 되는 컴퓨터 데이터의 종류를 가리키는 형 이름은 피한다
	        - 새로운 형이 표현하고 있는 현실 세계 문제의 일부분을 가리키는 형 이름을 대신 사용한다
	- ***미리 정의된 형을 가리키는 형 이름을 조심하라***
		- 작성한 프로그램과 구현 언어를 분리해주는 층을 제공한다
	- ***미리 정의된 형을 피하라***
	- ***미리 정의된 형을 재정의하지 마라***
		- 표준 형 선언을 변경하면 혼란스러울 수 있다.
		- Integer라는 미리 정의된 형을 갖고 있다면 Integer라는 이름의 새로운 형을 만들지 않는다
	- ***다른 플랫폼으로 이식하기 쉽게 대체 형을 정의하라***
	- ***미리 정의된 형으로 수비게 오인할 수 있는 형은 선언하지 말라***
        - 새로 정의한 형과 원래 프로그래밍 언어에서 제공하는 형을 명확하게 구분하는 것이 좋다
	- ***typedef를 사용하는 대신 클래스 생성을 고려하라***
## 체크 리스트

>![[codeComplete28.png]]
>![[codeComplete29.png]]
# 13장 특이한 데이터형
## 13.1 구조체
- 구조체
	- 서로 다른 형의 집합으로 구성된 데이터
	- ***데이터 관계를 이해하기 쉽게 하기 위해서 구조체를 사용하라***
        - 더 많은 정보를 제공하는 구조화된 변수를 사용하는 비주얼 베이직 예제
```visual-basic
employee.name = inputName
employee.address = inputAddress
employee.phone = inputPhone
```

- ***데이터 블록에 대한 작업을 단순화하기 위해서 구조체를 사용하라***
	- 서로 연관성이 있는 요소를 하나의 구조체로 결합한 후 해당 구조체에 대한 작업을 수행할 수 있다
	- 구조체로 선언하는 비주얼 베이직 예제

```visual-basic
Structure Employee
	name As String
	address As String
	phone As String
	ssn As String
	gender As String
	salary As String
End Structure
Dim newEmployee As Employee
Dim oldEmployee As Employee
Dim previousOleEmployee As Employee
```

- ***매개변수 목록을 단순화하기 위해서 구조체를 사용하라***

```visual-basic
EasyWayRoutine( employee)
```

- ***유지보수를 줄이기 위해서 구조체를 사용하라***
	- 구조체를 사용하면 연관된 데이터를 그룹으로 묶기 때문에 구조체를 변경할 때 프로그램 전체적으로 변경할 것이 더 적어진다
## 13.2 포인터
- 포인터를 이해하는 패러다임
	- 메모리상에서의 위치
		- 메모리상 위치는 주소로, 종종 16진수 표기법으로 표현
		- 포인터 자체는 이 주소만 포함
		- 포인터가 가리키고 있는 데이터를 사용하기 위해서는 해당 주소로 가서 메모리의 내용을 해석해야한다
    - 메모리의 내용을 해석하는 방법
	- 해당 포인터의 기본형으로 제공
        - 포인터가 정수를 가리킨다면 이는 컴파일러가 포인터가 가리키는 메모리 주소를 정수로 해석한다는 것을 의미
- 포인터 사용 팁
	- 포인터 오류는 일반적으로 포인터가 가리키면 안 되는 곳을 가리켜 발생한다
	- 메모리 충돌 → 잘못된 포인터 변수에 값을 할당할 때 써서는 안되는 메모리 영역에 데이터를 사용할 때 발생
- 포인터를 성공적으로 다루는 두 가지 전략
	- 처음부터 포인터 오류가 발생하는 상황을 만들지 않는다
	- 코드를 작성한 후 가능한 한 빨리 포인터 오류를 발견하는 것

- ***위의 두 가지 전략을 달성하기 위한 방법***
	- ***포인터 연산을 루틴이나 클래스에 고립시켜라***
		- 포인터에 접근하는 코드를 최소화함으로써 프로그램 전체에 영향을 미치고 찾는 데 아주 오랜 시간이 걸리는 부주의한 실수를 저지를 확률을 최소화한다
	- ***포인터를 선언과 동시에 정의하라***
	- 예시
```c
...
Employee *employeePtr = new Employee;
```

- ***포인터를 할당된 곳과 같은 영역에서 삭제하라***
	- 특정 범위 안에서 포인터를 사용한다면 같은 범위 내에서 new를 호출해 포인터를 할당하고 delete를 호출해 포인터를 해제한다
	- 포인터를 루틴 내에서 할당한다면 해당 루틴 내에서 해제한다
	- 포인터를 객체 생성자에서 할당한다면 해당 객체의 소멸자에서 해제한다
	- ***포인터를 사용하기 전에 검사하라***
		- 포인터를 사용하기 전에 해당 포인터가 가리키고 있는 메모리 위치가 유효한지 확인하자
        - ***포인터가 참조하는 변수를 사용하기 전에 검사하라***
        - ***손상된 메모리를 검사하는 인식표(dog-tag) 필드를 사용하라***
		- 태그 필드 또는 인식표는 오류 검사를 위한 목적으로 구조체에 추가하는 필드
		- 변수 할당 시 바뀌면 안되는 값을 태그 필드에 입력
		- 특히 메모리 삭제와 같이 구조체를 사용할 때 태그 필드의 값을 검사한다
		- 태그 필드가 예상했던 값이 아니라면 데이터가 손상된 것
			![[codeComplete30.png]]


        - ***명시적으로 중복 추가하라***
		- 특정한 필드를 두 번 사용하기
		- 중복된 필드에 있는 데이터가 일치하지 않는다면 메모리가 손상되었음을 알 수 있다
		- 이 경우 메모리를 직접 다루면 오버헤드가 클 수 있다. 하지만 포인터 연산을 루틴으로 작성한다면 중복되는 코드가 많지 않을 것이다
        - ***여분의 포인터 변수를 사용하라***
		- 절대로 포인터 변수를 아끼지 않는다
		- **변수는 하나 이상의 목적으로 사용되어서는 안 된다는 것**
        - ***복잡한 포인터 표현식을 단순화하라***
```c
quatityDiscount = rates->discounts->factors->net;
for (rateIndex = 0; rateIndex < numRates; rateIndex++) {
	netRate[ rateIndex ] = baseRate[ rateIndex ] * quatityDiscount ;
}
```
## 13.3 전역 데이터
- 전역 데이터를 사용할 때 발생하는 일반적인 문제점
	- 전역 변수에 대한 부주의한 변경
	- 전역 데이터의 기괴하고 이상한 별칭 문제
		- 전역 변수 하나를 루틴에 전달하고 나서 해당 루틴에서 그것을 전역 변수와 매개변수로 동시에 사용할 때 발생
        - 예시
```java
Sub WriteGlobal(ByRef inputVar As Integer)
inputVar = 0
globalVar = inputVar + 5
MsgBox (" Input Variable: " $Str(inputVar) )
MsgBox (" Global Variable: " $Str( globalVar ) )
End Sub
WriteGlobal (globalVar)
// result

	inputVar Variable: 5
	globalVar Variable: 5
```
- ***전역 데이터의 재진입 코드 문제***
	- 다중 스레드 코드에서 전역 데이터를 루틴 뿐만 아니라 같은 프로그램 내에서 공유할 수 있다. 그러한 환경에서 여러 개의 프로그램이 실행 중이더라도 전역 데이터가 그 값을 유지하도록 보장해야 함
- ***전역 데이터로 인한 코드 재사용 문제***
	- 재사용하고자 하는 클래스가 전역 데이터를 읽거나 쓰면 새로운 프로그램에 단순히 연결할 수 없다.
        - 가장 확실한 방법은 오래된 클래스가 전역 데이터를 사용하지 않게 수정할 것

- ***전역 데이터와 관련된 불확실한 초기화 순서 문제점***
	- 한 파일에서 전역 변수를 초기화할 때 다른 파일에서 이미 초기화된 전역 변수를 사용한다면 두 변수가 올바른 순서가 초기화되게 하기 위해 어떠한 명시적 단계를 거치지 않을 경우 두 번째 변수의 값이 완전히 사라진다
- ***전역 데이터로 인해 손상되는 모듈화와 지적인 관리 용이성***
	- 전역 데이터는 모듈화를 방해한다
        - 전역 데이터를 사용하면 한 번에 한 루틴에 집중할 수 없다
- 전역 데이터를 사용하는 이유
	- ***전역적인 값의 보관***
	- ***이름 상수의 역할***
	- ***열거형 흉내 내기***
	- ***매우 자주 사용되는 데이터의 사용을 능률화***
	- ***tramp data 제거***
- 최후의 수단으로만 전역 데이터를 사용하라
	- ***각 변수를 지역 변수로 만든 다음 필요할 때만 변수를 전역으로 만들어라***
        - 처음에는 모든 변수를 각 루틴의 지역 변수로 만들고, 다른 곳에서 필요하다면 전역으로 만들기 전 비공개 또는 보호 클래스 변수로 만들고, 정말로 전역으로 만들어야 한다면 어쩔 수 없는 경우에만 만든다
- ***전역 변수와 클래스 변수를 구분하라***
	- ***접근 루틴을 사용하라***
- 전역 데이터 대신 접근 루틴 사용
	- ***접근 루틴의 장점***
		- 데이터에 대한 제어 집중 가능
		- 변수에 대한 모든 참조가 보호된다는 것을 보장할 수 있다
		- 정보 은닉이 갖는 일반적인 장점을 자동으로 얻게 된다
		- 접근 루틴은 추상 데이터형으로 변환하기 쉽다
- ***접근 루틴 사용 방법***
	- Getter, Setter를 통한 사용
	- 접근 루틴 지침
		- ***모든 코드가 접근 루틴을 통해서만 데이터에 접근할 수 있게 하라***
		- ***모든 전역 데이터를 한곳에 집어넣지 말아라***
		- 모든 전역 데이터를 하나의 큰 공간에 집어넣고 접근 루틴을 작성하면 전역 데이터의 문제점을 없앨 수는 있지만, 정보 은닉과 추상 데이터형이 제공하는 몇 가지 장점을 잃게 된다
	- ***전역 변수에 대한 접근을 제어하기 위해서 잠금을 사용하라***
		- 변수를 사용하고 난 후 체크인 상태로 변경
		- 변수가 사용되는 동안 프로그램의 다른 부분에서 변수를 체크아웃하려고 하면 잠금/잠금 해제 루틴이 오류 메시지를 표시하거나 어설션을 발생시킨다
	- ***추상화 수준을 접근 루틴에 만들어라***
		- 예시
```java
account = NextAccount(account)
```
- ***데이터에 대한 모든 접근을 동일한 추상화 수준으로 유지하라***
	- 어떤 구조체에 한 가지 작업을 하기 위해서 접근 루틴을 사용한다면 그 구조체를 다루는 다른 모든 작업을 수행하는 데 접근 루틴을 사용해야한다
- 전역 데이터를 사용할 때의 위험 요소를 줄이는 방법
	- ***전역 변수를 분명히 하는 이름 규약을 만들어라***
        - 전역 데이터를 다루고 있음을 분명히 하라
- ***모든 전역 변수에 대해 주석을 잘 작성한 목록을 만들어라***
	- ***중간 결과를 담기 위해 전역 변수를 사용하지 마라***
	- ***모든 데이터를 거대한 객체에 입력하고 모든 곳에 전달하는 방법으로 전역 데이터를 사용하지 않는 것처럼 가장하지 말라***
## 체크 리스트
![[codeComplete31.png]]
