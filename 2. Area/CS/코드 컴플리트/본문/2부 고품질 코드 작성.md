# 코드 컴플리트 2부

# 5장 구현 설계

## 5.1 설계의 어려움

- 설계의 어려움
    - 소프트웨어 설계 : 컴퓨터 소프트웨어에 대한 명세를 동작 가능한 소프트웨어어로 변환하기 위한 계획에 대한 구상이나 창작, 도구
    - 설계는 요구사항을 코드 작성 & 디버깅에 연결하는 작업
    - 훌륭한 상위 수준 설계는 여러 개의 하위 수준 설계를 무리 없이 담을 수 있는 구조를 제공
    - 설계는 불명확한 문제다
        - 불명확한 문제 : 전체 혹은 일부를 해결해야만 정의할 수 있는 문제
        - 소프트웨어는 매우 변경사항이 많고, 자주 일어난다
    - 설계는 엉성한 프로세스다(결과는 정돈되었을지라도)
        - **완성된 소프트웨어 설계는 정돈되어 있고 깔끔해 보여야 하지만, 설계 과정은 최조ㅇ결과물만큼 깔끔하지 않다**
        - **실수하는 것이 설계의 핵심 ⇒ 설계 단계에서 실수하고 고치는 것이 똑같은 실수를 코드 작성 후에 발견해 코드를 수정하는 것보다 비용이 적게 든다**
    - 설계는 절충과 우선순위의 문제다
        - 현실 세계에서는 설계자의 주요 업무 중 하나가 서로 상충하는 설계 특징을 비교해 그 특성들 사이의 균형을 맞추는 일
            - 빠른 응답 속도 > 개발 시간 최소화 ⇒ 그에 맞게 설계
            - 반대도 마찬가지
    - 설계에는 제약이 따른다
        - 설계의 핵심은 어느 정도는 가능성을 만들고 어느 정도는 가능성을 **제한**한다는 데 있다
    - 설계는 비결정적이다
        - 어떤 목적을 달성하는 방법은 한 가지 이상일 수 있지만 컴퓨터 프로그램을 설계하는 방법은 보통 수십 가지에 이른다.
    - 설계는 발견적 학습 과정이다
        - 설계는 비결정적이기 때문에 설계 기법은 예상된 결과를 만들어내는 반복적인 처리 과정이라고 보단 발견적 학습(”경험 법칙”, “작동하는 지 시도해 보는것”)이다
    - 설계는 창발적이다
        - **설계는 창발적이다**
        - 설계는 설계 검토 & 격식 없는 토론 & 코드 작성 경험 자체 & 코드 수정 경험을 통해 진화하고 발전

## 5.2 핵심 설계 개념

- 소프트웨어의 주요 기술적 의무: 복잡성 관리
    - 본질적 어려움과 비본질적 어려움 - 브룩스(No Silver Bullets : Essence and Accidents of Software Engineering)
        - 소프트웨어 개발이 어려운 이유는 본질적이고 우연에 기인하는 서로 다른 종류의 문제 때문이다
        - 본질적 속성 : 어떠한 사물이 그러한 사물이 되기 위해서 반드시 가져야하는 속성
            - 자동차가 되기 위해서 엔진, 바퀴, 문이 있어야 한다
        - 비본질적 속성 : 특정 사물이 그것이 무엇이라고 결정하는 데 영향을 끼치지 않는 우연의 산물
            - 자동차에 엔진이 무엇이던, 바퀴가 어떤 휠이던, 문이 2개 or 4개이던 자동차다
            - 부수적이고, 임의적이고, 추가적이고, 우연한 것
        - 소프트웨어의 비본질적 어려움을 오래 전에 해결되었다
            - 언어 문법의 편의성 증대, IDE 개발 환경 확대 등을 통해
        - 소프트웨어에 남아있는 본질적인 어려움은 느리게 해결된다
            - 소프트웨어 개발이 본질적으로 매우 복잡하고 서로 연관된 개념들에 관한 세부 사항들을 해결하는 작업이기 때문이다.
            - 소프트웨어 개발이 갖는 본질적인 어려움은 복잡하고 무질서한 현실 세계와 상호작용하고, 종속 관계와 예외 사황들을 정확하고 완벽하게 구명하며, 대충이 아니라 정확히 맞는 솔루션을 설계해야하기 때문이다.    
> [!note] **컴퓨팅은 그저 1비트에서 수백 메가 비트 차이에 온통 집중해야하는 직업 - 에츠허르 데이크스트라     **
   
- 복잡성 관리의 중요성 - 에츠허르 데이크스트라
	- 대부분 실패한 프로젝트는 요구사항이나 계획 수립, 관리가 부족해서 실패한다
	- 프로젝트가 기술적인 이유로 실패한 경우에는 복잡성 관리 부족으로 실패한다
	- **복잡성 관리는 소프트웨어 개발에서 가장 중요한 기술적 주제 ⇒ 주요 기술적 의무**
	- **현대 컴퓨터 프로그램을 보관할 수 있을 정도의 큰 두뇌를 가진 사람은 아무도 없다**
		- **곧 소프트웨어 개발자가 전체 프로그램을 억지로 한 번에 머릿속에 밀어 넣으려고 해서는 안된다**
		- **목표를 한 번에 생각해야 하는 프로그램의 크기를 최소화하는 것**
	- 소프트웨어 아키텍처 수준에서는 시스템을 서브시스템으로 나누어 문제의 복잡성을 줄임 ⇒ **복잡한 문제를 간단한 문제로 나누는 것**
	- **인간의 선천적이 한계를 보완할 줄 아는 개발자는 자신뿐만 아니라 다른 사람도 이해하기 쉽고 오류가 적은 코드를 작성한다**
- 복잡성을 해결하는 방법
	- 복잡성을 관리하는 두 가지 접근 방법
		- 두뇌가 한 번에 처리해야 하는 본질적인 복잡성의 양을 최소화한다
		- 비본질적인 복잡성이 불필요하게 증가하지 않도록 한다
- 바람직한 설계의 특징
    - 좋은 내부 설계의 특징
        - 복잡성 최소화
            - **재치** 있는 설계 < **간단**하고 **이해**하기 쉬운 설계
        - 유지보수의 편리함
            - 유지보수 개발자를 고려한 설계
            - **유지보수 개발자가 작성한 코드에 대해 물어볼 만한 질문을 계속 떠올려보자**
        - 느슨한 결합
            - 프로그램의 각 부분 사이의 연결을 최소화하도록 설계
            - 클래스 사이의 연결을 최소화하기 위해 클래스 인터페이스에서 추상화, 캡슐화, 정보 은닉과 같은 방법 사용
            - 연결 최소화를 통해 통합, 테스트, 유지보수 시 작업 최소화
        - 확장성
            - 내부 구조를 해치지 않고 시스템의 기능을 개선
            - 예측 가능한 변경 사항을 미리 고민
        - 재사용성
            - 현재 시스템의 일부를 다른 시스템에 사용할 수 있도록 시스템 설계
        - 높은 Fan-in
            - 특정 클래스를 사용하는 클래스의 수가 많다는 것을 의미
            - 시스템이 유틸리티 클래스를 잘 활용하도록 설계
        - 낮은 Fan-out
            - 특정 클래스가 다른 클래스를 적게 사용한다는 의미
            - 루틴 내에서 호출되는 루틴 수나 클래스 내에서 사용되는 클래스의 수를 계산할 때 유용
        - 이식성
            - 시스템을 다른 환경으로 쉽게 이동시킬 수 있도록 설계
        - 간결성
            - 불필요한 부분이 없게 시스템을 설계하는 것
            - 어떤 코드를 수정하면 나머지 코드를 다시 개발하고 검토하고 테스트하고 확인해야한다
            - 소프트웨어의 차기 버전은 반드시 나머지 코드와 하위 호환성을 유지해야한다
        - 계층화
            - 시스템에 대해 특정한 계층에서 바라보고 일관되게 이해할 수 있도록 분산 계층을 유지
            - 시스템을 다른 계층을 보지 않고도 특정 계층에서 볼 수 있도록 설계해야 한다
            - 오래되고 잘못 설계된 코드를 많이 사용해야 하는 시스템을 개발하고 있다면 새 시스템에 대해 이전 코드와 조화를 이룰 시 있는 계층을 만들어야 한다
        - 표준 기법들
            - 시스템이 색다른 방법에 의존하면 할수록 다른 사람이 처음에 코드를 이해하기가 더 어려워진다
            - 표준화되고 일반적인 접근 방법을 사용해 전체 시스템이 친숙하다고 느껴지게 만들려고 노력해야한다
- 설계 수준
    ![[codeComplete8.png]]
    
    - 수준 1 : 소프트웨어 시스템
        - 전체 시스템
        - 시스템 수준은 서브 시스템이나 패키지 같이 상위 수준의 클래스 조합을 충분히 생각하는데 도움을 준다
    - 수준 2 : 서브시스템이나 패키지로 분할
        - 모든 중요한 서브시스템으 식별하는 것
        - 서브 시스템은 DB, 사용자 인터페이스, 비지니스 규칙, 명령 해석기, 보고서 엔진과 같이 클 수도 있음
        - **프로그램을 주요 서브시스템으로 어떻게 나눌 것인지, 각 서브시스템이 다른 서브시스템을 어떻게 사용하게 할 것인지를 결정하는 주요 설계 작업 수준**
        - **서로 다른 서브시스템이 서로 어떻게 소통할 것인지에 대해 규칙을 정하는 것이 중요**
        - 서브시스템 사이의 커뮤니케이션에 제한이 없을 때 나타나는 현상의 예
            
            ![[codeComplete9.png]]
            - 모든 서브 시스템이 다른 모든 서브시스템과 직접 커뮤니케이션함
            - 개발자가 그래픽 서브시스템에서 무언가를 변경하기 위해서 전체 시스템에서 얼마나 많은 부분을 이해해야 하는가?
            - 다른 시스템에서 비지니스 규칙을 사용할 때 무슨 일이 발생할까?
            - 시스템에 테스트를 위한 command UI 같은 새로운 사용자 인터페이스를 추가하려고 할 때 무슨 일이 발생할까?
            - 원격 기기에 데이터를 저장하고 싶을 때 무슨 일이 발생할까?
        - 커뮤니케이션 규칙 몇 개로 서브시스템의 상호작용을 줄인 예
            ![[codeComplete10.png]]
          
        - 상호 연결관계를 이해하고 유지하기 쉽게 하려면 내부 서브시스템의 관계를 간단한게 만듦
            - 가장 간단한 관계는 하나의 서브시스템이 다른 서브시스템에 있는 루틴을 호출
            - 가장 복잡한 관계는 한 서브시스템에 있는 클래스가 다른 서브시스템에 있는 클래스를 상속받는 경우
        - 범용적으로 적용할 만한 규칙은 시스템 수준의 다이어그램이 순환 구조를 갖지 않는 것 ⇒ 프로그램에서 Class A가 Class B를 사용하고 Class B 가 Class C를 사용하고 Class C가 Class A를 사용하는 순환 관계는 **없어져야한다**
        - 공통적인 서브시스템
            - 비지니스 규칙
                - 컴퓨터 시스템에 입력하는 법률과 규칙, 정책, 절차
                - 예시 : 급여 시스템에서 원천세 공제 & 예납 세율에 대한 규칙 입력
            - 사용자 인터페이스
                - 프로그램의 나머지 부분에 지장을 주지 않고 발전할 수 있도록 사용자 인터페이스 컴포넌트를 고립시키는 서브시스템을 개발
                - 대부분의 경우, 사용자 인터페이스 서브시스템은 GUI 인터페이스, 명령줄 인터페이스, 메뉴 처리, 윈도우 관리, 도움말 시스템 등에 대한 여러 개의 종속적인 서브시스템이나 클래스 사용
            - 데이터베이스 접근
                - 데이터베이스 접근에 대한 구현 세부 사항을 감춰 프로그램 대부분이 저수준 구조체를 다루기 위한 복잡한 세부 사항에 걱정할 필요가 없게 만들고 비지니스 수준에서 사용되는 형태로 데이터를 처리
                - 데이터베이스 연산을 한곳에 집중시키고 데이터를 다룰 때의 오류 발생 가능성도 감소시킴
            - 시스템 의존성
                - 하드웨어의 의존성을 패키지화하는 것과 같은 이유로 운영 체제에 대한 의존성을 서브시스템으로 패키지화
                    - 윈도우 API에 대한 호출을 윈도우 인터페이스 서브시스템으로 고립시킴
    - 수준 3: 클래스로 분할
        - 시스템에 필요한 모든 클래스를 구체화하는 작업
            - 데이터베이스-인터페이스 서브시스템은 데이터베이스 메타데이터뿐만 아니라 데이터 접근 클래스 & 지속성 프레임워크 클래스로 추가로 나뉠 수 있음
        - 각 클래스가 시스템의 나머지 부분과 상호작용하는 방법에 대한 세부적인 사항도 클래스에 명시. 특히 클래스의 인터페이스가 정의
        - 일반적으로 며칠 이상 걸리는 프로젝트라면 서브시스템을 클래스로 나누는 작업이 필요
        - 클래스와 객체 ( 쿠키 틀과 쿠키)
            
>[!note] 💡 틀로 쿠키를 찍어낸다

- 객체
	- 실행 중인 프로그램에 존재하는 구체적인 entity
	- 이름, 나이, 성과 같은 속성
	- 프로그램을 실행할 때 생성되는 특정한 값과 속성을 갖는 동적인 것
	- DB에서 스키마
- 클래스
	- 객체를 다루기 위한 도구
	- DB에서 인스턴스
- 수준 4: 루틴으로 분할
- 클래스를 루틴으로 나눈다
- 클래스의 private 루틴을 상세하게 설계
- 클래스의 루틴을 완전하게 정의하는 작업을 통해 클래스의 인터페이스에 대해 더 잘 이해하게 되면 인터페이스도 그것에 맞게 변경해야 하는 경우 ⇒ 수준 3으로 돌아가 수정해야하는 경우도 있다
- 공식적으로 할 필요가 없다면 적어도 머릿속에서라도 해야 한다
- 수준 5: 내부 루틴 설계
- 각 루틴의 상세한 기능을 수현
- 내부 루틴 설계는 일반적으로 개별적인 루틴을 개발하는 개발자의 몫
- 설계는 의사코드를 작성하고 참고 서적에 알고리즘을 살펴보고 루틴 내의 코드 단락을 어떻게 구성할 것인지를 결정하고 프로그래밍 언어로 코드를 작성하는 활동으로 구성
## 5.3 설계 빌딩 블록: 발견적 학습

- 발견적 학습 방법
    - 현실 세계의 객체를 찾아라
        - 객체 설계 단계
            - 객체와 객체의 속성(메서드와 데이터)을 식별한다
            - 각 객체에 무엇을 할 수 있는지 결정한다
            - 각 객체가 다른 객체에 무엇을 할 수 있는지 결정한다
            - 각 객체에서 다른 객체에 보일 부분을 결정한다. 즉, 공개되는 부분과 비공개되는 부분을 결정한다
            - 각 객체의 공개 인터페이스를 정의한다
        - *객체와 객체의 속성을 식별한다*
            - **컴퓨터 프로그램은 대개 현실 세계의 엔티티에 기반을 둔다**
            - 예시
			    ![[codeComplete11.png]]
            - 객체를 식별하고 나면 객체의 속성을 찾는 것은 크게 어렵지 않다
            - 각 객체는 프로그램과 관련된 속성을 갖는다
                - 객체 : 속성 예시
                    - 직원 : 이름, 직위 ,청구율
                    - 윈도우 : 대화상자, 버튼, 폰트, 그리기 도구
            - ***각 객체에 무엇을 할 수 있는지 결정한다***
                - 각 객체에서 다양한 작업을 수행할 수 있다
                - 청구 시스템에서 직원 객체는 직함, 청구율을 변경할 수 있다
            - ***각 객체가 다른 객체에 무엇을 할 수 있는지 결정한다***
                - 어떤 객체가 어떤 객체를 포함할 수 있는가?
                - 어떤 객체가 어떤 객체로부터 상속받을 수 있는가?
                - 시간 기록표(A 객체)는 직원, 고객 객체(B 객체)를 포함할 수 있다
            - ***각 객체에서 다른 객체에 보일 부분을 결정한다.***
                - 설계 시 객체의 어느 부분을 공개하고, 비공개로 유지할 지 파악
                - 데이터와 메서드 모두에 대해 이러한 사항 결정 필요
            - ***각 객체의 공개 인터페이스를 정의한다***
                - 각 객체에 대해 형식적으로 이해하기 쉬운 프로그래밍 언어 수준의 인터페이스를 정의
                - public interface, protected interface
    - 일관성 있게 추상화하라
        - 집합체(aggregate)라는 개념을 도입해 작업할 때 추상화를 통해 작업
        - 어떤 물체를 유리, 나무, 못의 결합이라하지 않고 **“집” 이라 부른다면 이는 추상화이다**
        - Base Class
            - 상속 받은 클래스가 갖는 공통 특성들에 집중하고 다른 세부 사항은 무시하기 위해 만들어진 추상화
    - 구현 세부 사항을 캡슐화하라
        - 추상화 다음 캡슐화
        - 추상화는 객체를 높은 수준에서 볼 수 있도록 하고 캡슐화는 다른 수준에서 해당 객체를 특정 수준 이상으로 볼 수 없도록 하는 것
            - 캡슐화는 집의 외관은 볼 수 있지만, 문의 재료가 무엇인지 알 수 있을 만큼 가까이 접근할 수는 없다는 개념
    - 상속이 설계를 단순화할 수 있을 때 상속하라
        - 상속은 추상화와 시너지 효과가 있다
        - 상속은 프로그래밍을 단순화한다 → 문의 일반적 특성에 의존하는 것을 처리하는 일반 루틴을 작성하고 나서 특정 종류의 문에 대한 특정 작업을 철리하는 구체적인 루틴 작성이 가능하기 때문 ⇒ Open()이나 Close()와 같은 연산은 문이 현관문이던,실내문,실외문, 유리문이어도 상관없이 적용 ⇒***Open()이나 Close()** 를 **다형성***
    - 비밀을 숨겨라(정보 은닉)
        - 구조적인 설계에서 ***“블랙박스” 개념***
        - 정보 은닉은 ***복잡성을 감추는 데 중점 ⇒*** 소프트웨어의 주요 기술적 의무(복잡성 관리)에 특히 강력한 발견적 기법
        - 객체지향적 설계에서는 정보 은닉을 위한 **캡슐화 & 모듈성 개념 와 추상화 개념 연결**
        - 비밀과 프라이버시
            - 정보 은닉 관점에서 각 클래스(또는 패키지나 루틴)는 그것을 다른 클래스로부터 숨기는 설계 결정이나 구현 결정으로 특징
            - 그 비밀은 바뀌기 쉬운 영역, 파일 포맷이나 데이터 타팁이 구현되는 방법, 어떤 영역에서의 오류가 가능한 한 프로그램에 입히는 피해가 작도록 프로그램의 다른 부분으로부터 차단될 필요가 있는 영역
            - 클래스 설계에서 가장 중요한 작업 중 하나는 어떤 기능을 클래스 외부로 알리고 어떤 기능을 비밀로 남길지 결정 ⇒ ***“가시성”***
        - 정보 은닉의 예
            - 새로운 ID가 생성되는 방법은 무조건 감춰야 하는 설계 사항
            - 프로그램 전체에 ++g_maxID 사용 → 새로운 ID가 g_maxID의 값을 하나 증가시켜 생성된다는 사실을 외부에 노출 ⇒ 전체 프로그램에 id = NewID() 루틴 안에는 여전히 return (++g_maxID) ⇒ NewID() a만 수정하면 됨
            - 정보 은닉은 숫자 상수 대신 이름 상수(named constant) 사용 ~ 데이터 타입의 생성을 비롯해 클래스 ,루틴, 서브시스템 설계에 이르기까지 모든 설계 수준에서 유용
        - 은닉의 두 가지 부류
            - 정보 은닉의 두 가지 그룹
                - 특별하게 관심이 없는 경우에 고민할 필요가 없도록 복잡성을 감추는 것
                - 변경이 발생했을 때 그 효과가 일부에만 영향을 미치도록 변경의 원인을 감추는 것
            - 정보 은닉의 장애물
                - 정보의 지나친 배분
                    - 시스템 전체 정보를 지나치게 배분
                    - 특정 값을 상수로 사용 → 값의 참조를 여겨 곳에서 사용 ⇒ ***이 정보를 숨겨 한 곳에서만 값이 바뀌도록 하는 것이 좋음***
                - 순환 의존성
                    - 클래스 A가 B를 호출 , B가 C를 호출, C가 A를 호출
                    - 클래스의 루틴 제거 필요
                - 전역 데이터로 오해받는 클래스 데이터
                    - 클래스 데이터를 전역 데이터로 생각해 전역 데이터와 관련된 문제를 피하고자 클래스 데이터를 사용하지 않는 것
                    - 전역 데이터의 문제
                        - 다른 루틴이 전역 데이터에 액세스 하는 문제
                        - 다른 루틴이 전역 데이터를 다루는 것을 알고 있지만 정확하게 무엇을 하는지 알지 못하는 문제
                - 성능 손해
                    - 아키텍처 수준에서는 정보 은닉을 위한 시스템 설계와 성능을 위한 설계가 충돌하지 않는다
                    - 코드 레벨에서 성능 개선을 미리 준비하는 방법은 코드를 모듈화 하는 것
            - 정보 은닉의 가치
                - 무엇을 숨겨하는 지에 대한 질문은 설계를 돕는다
                - 구현 단계에서 리터럴 대신 이름 상수를 사용하면 클래스 내부의 좋은 루틴과 좋은 매개변수 이름을 생성하는 데 도움을 준다
    - 변경될 것 같은 영역을 찾아라
        - 변경의 효과가 한 루틴, 클래스,패키지에 제한되도록 불안정한 영역으로 고립 시키는 것이 목표
        - 변화를 대비하기 위해 따라야 하는 단계
            1. 변경될 것처럼 보이는 항목을 찾는다
                1. 요구사항 분석에서 변경 가능성이 있는 것을 미리 다뤄라
                2. 그렇지 못했다면,어느 프로젝트에서나 변경이 일어날만한 것을 찾아라
            2. 변경될 것처럼 보이는 항목을 분류한다
                1. 변경되기 쉬운 요소를 클래스로 다루고, 함께 변경될 수 있는 다른 요소들과 함께 분류
            3. 변경될 것처럼 보이는 항목을 고립시킨다
                1. 잠재적인 변경에 영향을 받지 않는 상호 클래스 인터페이스 설계
                2. 변화가 해당 클래스의 내부에 제한되어 외부의 영향을 받지 않도록 인터페이스 설계
        - 변경 가능성이 큰 영역
            - *비지니스 영역*
            - *하드웨어 의존성*
                - 하드웨어 의존성을 자체적인 서브시스템이나 클래스로 고립시켜라
            - *입력과 출력*
                - 외부 인터페이스에 대해 변경이 일어날 수 있는 모든 사항을 조사해라
            - *표준을 따르지 않는 언어 기능*
                - 현재 사용하고 있는 프로그래밍 언어가 표준을 따르지 않는 확장 기능을 사용하고 있다면, 다른 환경으로 옮겨갔을 때 해당 기능을 사용할 수 있도록 확장 기능을 별도의 클래스 내에 숨겨라
            - *어려운 설계 및 구현 부분*
                - 기능을 분류해 나쁜 설계나 구현이 미치는 시스템에 대한 영향을 줄여라
            - *상태 변수*
                - 상태 변수 사용 시 유연성과 가독성 고려
                    - ***boolean 변수를 상태 변수로 사용하지 말라 - Enum 사용하기***
                        - 상태 변수가 추가되는 일은 흔하므로, 열거형에 상태 변수를 추가하면 재컴파일만 하면 된다
                    - ***변수에 직접 접근하지 말고 접근 루틴을 만들어라***
                        - 변수 대신 접근 루틴을 검사해 더욱 정교하게 상태를 검사하라
            - *데이터 크기 제약*
                - 배열의 크기를 100으로 제약하지 말고 MAX_EMPLOYEE같은 상수를 사용해라
        - 변경 정도 예측하기
            - 변경이 발생할 것 같다면 시스템이 이를 수용할 수 있는지 확인
            - 절대로 변경이 일어나지 않을 것 같은 부분만 시스템에서 하나 이상의 클래스에 큰 영향을 미치도록 한다
            - 변경될 것 같은 영역을 식별하는 방법
                - 프로그램에서 사용자에게 쓸모 있는 최소한의 부분을 파악하는 것 ⇒ 변경 가능성이 낮음
                - 시스템에 대한 최소 변경 사항을 정의
    - 결합을 느슨하게 유지하라
        - 다른 모듈에 거의 의존하지 않는 모듈을 만드려고 노력하라
        - 결합의 기준
            - 크기
                - 모듈 사이의 연결 횟수
                - 작은 인터페이스를 가진 것들 → 다른 모듈에 연결하기 쉬움
                - 파라미터를 1개 받는 루틴이 6개 받는 루틴보다 모듈이 느슨하게 연결되어 있다
                - 잘 정의된 공개 메서드가 느슨하다
            - 가시성
                - 두 모듈간의 연결이 얼마나 명시적인가를 보여주는 것
                - 매개변수 목록에 데이터를 전달하는 것이 분명하게 연결되기 때문에 좋다
            - 유연성
                - 얼마나 쉽게 모듈 사이의 연결을 변경할 수 있는 지
                - 어떤 모듈이 다른 모듈을 호출하는 게 쉬울수록 결합은 느슨해진다
        - 결합의 종류
            - 간단한 데이터 매개변수 결합
                - 두 모듈 사이에서 전달되는 모든 데이터가 기본 데이터형
                - 모든 데이터가 매개변수로 전달되는 경우
                - 자연스럽고 허용 가능한 결합
            - 간단한 객체 결합
                - 모듈이 객체를 인스턴스화
                - 매우 좋은 결합
            - 객체 매개변수 결합
                - Object1이 Object2에게 Object3 객체를 넘겨달라고 요구하는 경우
                - 조금 강한 결합
            - 의미론적인 결합
                - 한 모듈이 다른 모듈의 프로그래밍 요소를 이용하지 않고 다른 모듈의 내부 작동에 대한 논리적인 지식을 사용할 때 나타나는 결합
                - 매우 강한 결합으로 찾기 어려움
                - 사용된 모듈 코드를 변경하면 모듈을 사용하는 코드가 컴파일러로 절대 감지할 수 없이 망가짐 → 매우 좋지 않음
>[!note]
>💡 효과적인 모듈이 추가적인 추상화 수준을 제공하는 것이 느슨한 결합의 핵심!

>[!important]
>💡 **디자인 패턴을 사용하기 위해서 디자인 패턴을 사용하지 말라
            
- 일반적으로 널리 사용하는 디자인 패턴을 찾아라
	- 패턴의 이점
		- 이미 만들어진 추상화를 제공함으로써 복잡성을 줄인다
			- 패턴을 통해 해당 코드에 상당히 많은 상호 관계와 프로그래밍 프로토콜이 들어감을 인지시킨다
		- 일반적으로 널리 사용되는 해결책의 세부 사항들을 규정함으로써 오류를 줄인다
			- 디자인 패턴을 사용하는 것은 코드를 직접 사용하는 대신 라이브러리를 사용하는 것과 같은 개념적 유사성이 있다
		- 대안을 제안함으로써 발견적 학습의 가치를 제공한다
		- 설계에 대한 수준 높은 논의를 할 수 있어 의사소통을 원활하게 한다
- 다른 발견적 학습
	- 응집력을 강하게 하라
		- 응집도 : 클래스에 있는 모든 루틴이나 루틴에 있는 코드가 얼마나 밀접하게 중심 목적을 지원하는지, 그 클래스가 얼마나 집중되어 있는지에 대한 정도
		- 응집도는 복잡성을 관리하는 도구
- 계층을 만들어라
	- 소프트웨어의 복잡성을 관리하는 의무를 달성하는 데 유용한 도구
	- 계층을 만들면 현재 다루고 있는 수준에만 집중할 수 있기 때문
- 클래스 계약을 형식화하라
	- 각 클래스의 인터페이스를 나머지 프로그램과의 계약으로 생각하라
		- ***“데이터 x,y,z를 제공하기로 약속하고 그 데이터들이 a,b,c 라는 특성을 갖는다는 것을 약속한다면 8,9,10이라는 제약 내에서 1,2,3의 연산을 수행할 것을 약속합니다”***
		- 클래스의 클라이언트가 클래스와 맺는 계약 → **선행조건**
		- 객체가 클라이언트와 맺는 계약 → **후행조건**
- 책임을 할당하라
	- 객체에 어떻게 책임을 할당할 것인가를 생각하라
- 테스트가 가능하도록 설계하라
	- 테스트가 용이한 시스템은 무엇인지를 고민하면 흥미로운 설계를 만들 수 있다
		- 사용자 인터페이스를 독립적으로 조사할 수  있도록 코드의 나머지 부분과 구별할 필요가 있는가?
- 실패를 피하라
- 결합 시점을 의식적으로 선택하라
	- binding 시점 → 특정 값이 변수에 결합하는 시점
	- 초기에 결합하는 코드는 간단하지만 유연성이 떨어진다
- 제어 지점을 정하라
	- ***“정확한 장소의 법칙 - 중요한 코드를 찾기 위한 정확한 장소와 유지보수 변경을 수행하기 위한 정확한 장소가 있어야한다(Plauger 1993)***
- 주먹구구식 기법의 사용을 고려하라
	- 효과가 있는 주먹구구식 해결책이 효과 없는 해결책보다 낫다
- 다이어그램을 그려라
- 모듈화를 유지하라
	- 모듈화의 목표는 각 루틴이나 클래스를 “블랙박스”처럼 만드는 것
    - 설계의 발견적 학습에 대한 요약
        - 현실 세계의 객체를 찾아라
        - 일관성 있는 추상화를 구성하라
        - 세부 사항을 캡슐화하라
        - 정보 은닉
        - 변경될 것 같은 영역을 규명하라
        - 느슨한 결합을 유지하라
        - 일반적으로 널리 사용되는 디자인 패턴을 찾아라
        - 응집력을 강하게 하라
        - 계층을 만들어라
        - 클래스 계약을 형식화하라
        - 책임을 할당하라
        - 테스트가 가능하도록 설계하라
        - 실패를 피하라
        - 결합 시점을 의식적으로 선택하라
        - 제어 지점을 정하라
        - 주먹구구식 기법의 사용을 고려하라
        - 다이어그램을 그려라
        - 모듈화를 유지하라
    - 발견적 접근 방법을 위한 지침
        1. *문제의 이해 - 문제를 이해해야한다*
            1. 모르는 것이 무엇인가? 데이터는 무엇인가? 조건은 무엇인가? 등
            2. 그림을 그려라, 적절한 표기법을 도입하라, 조건을 여러 부분으로 분리하라
        2. *계획의 고안 - 데이터와 모르는 것과의 관계를 찾아라. 연결 고리를 찾을 수 없다면 부차적인 문제를 고려해야할 지도 모른다. 결국에는 해결채에 대한 계획을 세워야한다*
            1. 그 문제를 이전에 본 적 있는가? 비슷한 문제를 본적이 있는가? 연관된 문제를 알고 있는가? 도움이 될만한 공식을 알고 있는가?
            2. *모르는 부분을 찾아라. 모르는 부분과 동일하거나 유사한 문제를 갖고 있는 문제를 생각해보라*
        3. *계획의 실행 - 계획을 실행하라*
            1. 문제 해결을 위한 계획을 실행할 때 각 단계를 검사한다.
            2. *각 단계가 옳은지 분명히 알 수 있는가? 그것이 옳다고 사실을 증명할 수 있는가?*
        4. *검토 - 해결책을 검토하라*
            1. 결과를 확인할 수 있는가? 논거를 검사할 수 있는가? 결과를 다르게 유추할 수 있는가? 한 눈에 알아볼 수 있는가? 다른 문제도 그 결과나 방법을 사용할 수 있는가?

## 5.4 설계 실천법

>[!important]
>💡 두 번째 시도는 첫 번째보다 거의 항상 더 좋고, 설계를 되풀이할 때마다 전체 설계를 향상시킬 수 있다는 것을 배운다
    
- 반복
    - 설계는 반복 프로세스 → A 위치에서 B → A로 돌아오는 경우가 많음
    - 상위 수준 문제를 다루면서 얻는 큰 그림은 거시적 관점에서 하위 수준의 세부 사항을 기재하는데 도움이 된다
    - 하위 수준 문제를 다루면서 얻게 되는 세부 사항은 더 현실적인 상위 수준 설계를 가능하게 한다
    - ***최상위 수준과 최하위 수준의 고려 사항을 조율하는 것은 바람직한 활동***
- 분할과 정복
    - 점증적인 개선은 복잡성을 다루는 강력한 도구
    - 프로그램을 서로 다른 관심 영역으로 나누고 각 부분을 개별적으로 처리하도록 하라
- 하향식과 상향식 설계 접근 방법
    - 하향식 설계
        - 높은 추상화 수준에서 시작
        - 기본 클래스나 구체적이지 않은 다른 설계 요소를 정의하고 설계하면서 파생 클래스 규명하기 & 클래스 공동 작업, 다른 세부적인 설계 요소 등 상세화 수준을 높임
    - 상향식 설계
        - 구체적인 것에서 시작해 일반적인 쪽으로 작업
        - 구체적인 객체를 규명하는 것부터 시작해 그 내용으로부터 객체와 기본 클래스 집합을 일반화
    - 하향식 접근 방법을 지지하는 주장
        - 인간의 두뇌가 한 번에 집중할 수 있는 양에 한계가 있으므로 일반적인 클래스부터 시작해 단계별로 클래스를 더 구체적인 클래스로 분해한다면 두뇌가 한 번에 너무 많은 세부 사항을 처리하지 않아도 된다
        - 분할-정복 프로세스의 반복적 측면
            - 일반적으로 한 수준만 분해하고 작업을 중단하지 않는다 → 계속해서 여러 수준으로 진행된다
            - 일반적으로 첫 번째 시도에 만족하지 않기 때문에 반복적 → 한 번에는 만족스러운 설계를 하지 못하기 때문
        - 프로그램의 분해는 분해보다 코드 작성이 더 쉬워 보일 때까지 계속 분해
    - 상향식 접근 방법을 지지하는 주장
        - 하향식 접근 방법은 때때로 너무 추상적이라 시작하기 어려움
        - 더 가시적으로 작업해야 한다면 상향식 설계 접근 방법을 시도
        - 상향식 구성을 할 때 기억해야 할 사항
            - 시스템이 무엇을 해야 하는지 알고 있는지 스스로 묻는다
            - 그 질문으로부터 구체적인 객체와 책임을 파악한다
            - 공통적인 객체를 식별하고, 서브시스템 구조나 패키지, 객체 내에서의 합성, 상속 등 적합한 것을 사용해 그 객체들을 그룹 짓는다
            - 다음 상위 수준에서 작업을 계속하거나 최상위로 돌아가 다시 하위 수준으로 작업을 진행한다
    - 사실상 논쟁은 없다
        - 하향식 & 상향식 전략의 가장 중요한 차이
            - 하향식
                - 분해 전략, 일반적인 문제에서 시작해 관리할 수 있는 조각으로 분해
                - 사람들은 큰 것을 작은 요소로 분해하는 것에 능숙
                - 세부 사항 구현을 미룰 수 있다 → 종종 구현 세부 사항의 변화로 인해 혼란스러워지므로(파일 구조나 보고서 형식의 변경)
                - 계층의 최하위 부분에 있는 클래스에 숨겨야 하는 세부 사항에 대해 미리 아는 것이 유용
                - 시작이 간단한 경향이 있지만, 저수준에서의 복잡성이 최상위 수준에도 영향을 미치게 되어 필요 이상으로 복잡해질 수 있다
            - 상향식
                - 결합 전략, 관리할 수 있는 부분에서 시작해 일반적인 솔루션을 구축
                - 일반적으로 필요한 유틸리티 기능을 초기에 파악할 수 있어서 간결하고 잘 구성된 설계가 만들어진다
                - 유사한 시스템이 이미 개발되어 있을 때 상향식 접근 방법을사용하면 이전시스템을 살펴보고 무엇을 재사용할 수 있는지 살펴본 후 새로운 시스템의 설계를 시작할 수 있다
                - 이 접근 방법만 사용해서 개발하기 쉽지 않다 ⇒ 대부분의 사람들은 작은 개념으로 큰 개념을 만드는 것보다 큰 개념을 가져다 작은 개념으로 나눈 것을 더 잘한다
                - 이미 시작한 조각으로 프로그램을 만들 수 없다는 사실을 알게 되는 경우 ⇒ 최상위 수준에서 작업해야만 하위 수준에서 어떤 조각이 필요한지 알게 될 수도 있다
                - 시작이 복잡한 경향이 있지만, 초기에 복잡성을 식별함으로써 전체 시스템이 부서지지 않는다면 높은 수준의 클래스 설계를 할 수 있다
- 실험적인 프로토타이핑
    - 프로토타이핑
        - 적은 비용으로 특정한 설계 질문에 답하는 데 필요한 최소한의 임시(쓰고 버리는) 코드를 작성하는 것
        - 개발자가 질문에 답하는 데 필요한 최소한의 코드를 작성해야한다는 원칙을 지키지 않으면 제대로 작동하지 않는다
        - 설계 질문이 구체적이지 않을 때도 효과가 없다
            - “이 데이터베이스 프레임워크가 X,Y,Z를 가정했을 때 초당 1,000개의 트랜잭션을 지원할 것인가” 식의 질문이 필요하다
    - 협력적인 설계
        - 협력을 취하는 형태
            - 비공식적으로 동료에게 다가가 아이디어를 생각해보자고 요청한다
            - 동료와 함께 회의실에 앉아서 화이트보드에 여러 가지 설계 아이디어를 그린다
            - 동료와 함께 키보드 앞에 앉아 사용하는 프로그래밍 언어로 세부적인 설계를 수행한다.
            - 한 명 이상의 동료와 디자인 아이디어를 검토할 수 있게 회의 일정을 잡는다
            - 공식 검토 일정을 잡는다
            - 자신의 작업을 검토해줄 수 있는 동료가 없다면 초기 설계 작업을 서랍 속에 넣어 놓고 일주일이 지난 후 다시 살펴본다. 이전에 작업했던 내용을 잊어버려 스스로 잘 검토할 수 있을 것이다
            - 조직 외부에 도움을 요청한다
    - 설계를 얼마나 잘해야할까?
        - 설계의 형식화와 상세 수준
	        - 설계의 가장 큰 어려움은 어려워서 설계를 잘못했다고 알고 있을 때가 아니라 너무 쉬워서 설계할 필요가 없다고 생각하는 순간에 발생하는 경향이 있다
		- *“계획된 활동은 계획되지 않은 활동을 쫓아내는 경향이 있다”(Simon, 1965)*
			- 그저 그런 설계 대안에 대한 노력 20%, 훌륭하지도 않은 설계 문서 정리에 80% 보다 수많은 설계 대안을 작성하고 조사하는데 80%, 설계 문서 작업에 20% 노력을 들이는 편이 낫다

| 요소                                | 구현하기 전에 설계에서 필요한 상세 수준 | 문서화 형식   |
| --------------------------------- | ---------------------- | -------- |
| 설계/구현 팀이 응용 프로그램 분야에 대한 경험이 많다    | 낮은 수준                  | 낮은 수준    |
| 설계/구현 팀이 응용 프로그램 분야에 대한 경험이 많지 않다 | 중간 수준                  | 중간 수준    |
| 설계/구현 팀이 경험이 많지 않다                | 중간에서 높은 수준             | 낮은/중간 수준 |
| 설계/구현 팀의 이직률이 중간 수준에서 높은 수준이다     | 중간 수준                  | -        |
| 응용 프로그램이 높은 안정성을 요구한다             | 높은 수준                  | 높은 수준    |
| 응용 프로그램이 특수 업무용이다                 | 중간 수준                  | 중간/높은 수준 |
| 프로젝트가 작다                          | 낮은 수준                  | 낮은 수준    |
| 프로젝트가 크다                          | 중간 수준                  | 중간 수준    |
| 소프트웨어의 예상 수명이 짧다(몇 주 또는 몇 달)      | 낮은 수준                  | 낮은 수준    |
| 소프트웨어의 예상 수명이 길다(몇 달 또는 몇 년)      | 중간 수준                  | 중간 수준    |

- 설계 작업 기록하기
	- 설계 문서에 설계를 작성하는 방법 - 가장 전형적인 방법
	- 규모가 작은 프로젝트, 비형식적 프로젝트, 가볍게 설계를 기록해도 되는 프로젝트 에서의 설계
		- *설계 문서를 코드 자체에 넣어라*
			- **코드 주석으로 문서화 - JavaDoc과 같은 문서 생성기 사용**
		- *설계에 대한 논의와 결정을 Wiki에 기록하라*
			- 설계에 대한 논의를 프로젝트 위키에 작성
		- *이메일로 요약하라*
			- 설계 논의를 끝낸 후 누군가가 설계에 대한 요약(특히 결정한 내용)을 작성해 프로젝트 팀원에게 이메일을 보내라. 이메일 복사본은 프로젝트의 공용 이메일 폴더에 저장
		- *디지털카메라를 사용하라*
			- 디지털카메라로 화이트보드에 있는 그림을 찍고 그 그림을 문서에 넣는 방법도 있다
		- *설계 플립 차트를 보관하라*
		- *CRC(클래스, 책임, 협력자) 카드를 사용하라*
			- 색인 카드를 사용하는 것
			- 각각의 카드 위에 설계자가 클래스의 이름과 책임, 협력자(해당 클래스와 협력하는 다른 클래스)를 기록
			- 설계 그룹은 설계를 잘했다고 만족할 때까지 그 카드를 가지고 작업
		- *적절한 상세 수준에서 UML 다이어그램을 작성하라*

## 5.5 잘 알려진 방법론에 대한 의견

- 설계가 잘못 되었다는 신호
    - 모든 세부 사항까지 설계하는 것
    - 설계를 전혀 하지 않는다는 것

## 6장 클래스 다루기

## 6.1 클래스의 토대: 추상 데이터형

- 추상 데이터형(Abstract Data Type, ADT)
    - 정의 : 데이터와 데이터를 처리하는 연산의 집합
        - 연산 : 프로그램의 나머지 부분에 데이터가 **무엇인지를 설명해주는 역할**과 나머지 프로그램에서 그 **데이터를 변경할 수 있게 해주는 역할**
    - 모든 연산이 포함된 그래픽 윈도우, 파일 연산 등
    - ADT가 필요한 예
        - 텍스트 제어 프로그램 예
            - ADT를 사용한다면 데이터(글꼴 이름, 크기, 폰트 특성) & 폰트 루틴
            - PointsToPixels → 루틴 | currentFont.size, 12 → 데이터
            - currentFont.size = PointsToPixels(12)
    - ADT를 사용할 때 좋은 점
        - ***구현 세부 사항을 감출 수 있다***
            - 정보 은닉을 통해 데이터 유형이 바뀌어도 프로그램 전체에 아무런 영향을 미치지 않고 어느 한 곳에서 변경할 수 있음
        - ***변경이 전체에 영향을 미치지 않는다***
            - 더 많은 속성을 추가하더라도 한 곳에서 프로그램을 변경할 수 있다
        - ***인터페이스가 더 많은 정보를 제공하도록 만들 수 있다***
        - ***성능을 향상시키기 쉽다***
            - 기 작성된 루틴을 다시 작성하면 된다
        - ***프로그램이 명백하게 정확해진다***
            - 루틴을 통해 틀린 부분을 명확하게 판별 가능하다
        - ***프로그램의 가독성이 높아진다***
        - ***전체 프로그램에 데이터를 넘길 필요가 없다***
            - 데이터를 일부의 루틴을 통해서만 직접 접근하므로 ADT에 속하지 않은 루틴은 그 데이터를 신경 쓸 필요가 없다
        - ***저수준 구현 구조체 대신 현실 세계의 개체를 다룰 수 있다***
            - 데이터를 다루는 연산들을 정의하면 프로그램 대부분이 배열 접근이나 구조체 정의. True or False와 같은 데이터의 관점에서 돌아간다.
    - ADT의 원칙
        - ***전형적인 저수준 데이터형을 저수준 데이터형이 아닌 ADT로 만들거나 사용하라***
            - 사실상 모든 전형적인 데이터형을 ADT로 표현 가능하다
            - **리스트가 청구 내용을 나타낸다면 ADT를 리스트가 아닌 청구 내용으로 취급하자**
        - ***파일과 같은 일반적인 객체를 ADT로 취급하라***
        - ***간단한 객체도 ADT로 취급하라***
            - 예 : ***TurnLightOn() & TurnLightOff()***
        - ***ADT가 저장된 매체와 독립적으로 ADT를 참조하라***
            - 파일을 직접 읽는 루틴보다 클래스와 접근 루틴의 이름을 데이터 저장 방식과 연관이 없도록 작성하고 테이블과 같은 추상 데이터형으로 표현
    - 비객체지향 프로그래밍 환경에서 ADT로 여러 개의 데이터 인스턴스를 다루기
        - C 언어와 같은 객체지향이 아닌 환경에서 작업한다면 다중 인스턴스를 지원하는 기능을 직접 구현
        - 예시
            ```c
            SetCurrentFontSize(sizeInPoints)
            SetCurrentFontBoldOn()
            SetCurrentFontBoldOff()
            SetCurrentFontItalicOn()
            SetCurrentFontItalicOff()
            SetCurrentFontTypeFace(faceName)
            ```
        - ADT 인터페이스를 다루는 세 가지 방법 - fontId
            - ADT 서비스를 사용할 때마다 명시적으로 인터페이스 식별
                - 데이터를 다루는 모든 루틴에 fontId를 전달
            - ADT 서비스에서 사용되는 데이터를 명시적으로 제공
                - ADT 서비스를 사용하는 루틴마다 ADT가 사용하는 데이터를 선언
            - 암시적인 인스턴스를 사용
                - 새로운 서비스를 설계해 특정한 폰트 인스턴스를 현재의 폰트로 설정
    - ADT와 클래스
        - 추상 데이터형은 클래스의 기본 개념의 바탕
        - 프로그래밍 언어가 클래스를 지원하면 추상 데이터형을 클래스로 구현 가능
        - 클래스는 일반적으로 상속과 다형성 개념을 추가로 지원
        - 추상 데이터형 = 상속과 다형성 ⇒ **Class**   

## 6.2 좋은 클래스 인터페이스

- 좋은 클래스 인터페이스
    - 좋은 추상화
        - 추상화는 복잡한 연산을 단순한 형태로 보여주는 능력
        - 클래스 인터페이스
            - 인터페이스 내부에 숨겨져 있는 구현 세부 사항에 대한 추상화 제공
            - 서로 밀접한 루틴들을 제공
        - 예시
            
            ```java
            Public class Employee {
            	
            	Employee();
            	
            	private FullName name;
            	private String address;
            	private String workPhone;
            	private String homePhone;
            	private TaxId taxIdNumber;
            	private JobClassification jobClass;
             
            	FullName getName();
            	String getAddress();
            	String getWorkPhone();
            	String getHomePhone();
            	TaxId getTaxIdNumber();
            	JobClassification getJobClassification(); 
            	
            	private ... 
            }
            ```
        - 클래스 추상화에 대한 평가는 공개 루틴의 집합, 즉 클래스의 인터페이스의 기초
        - ***클래스 인터페이스가 일관된 추상화 수준을 갖도록 한다***
        - ***클래스가 구현하고 있는 추상화가 무엇인지 이해해야 한다***
            - 자신이 정확하게 원하는 것이 무엇인지 알고 있는 상태에서 유사한 두 추상화 중에서 한 가지를 선택해야한다
        - ***서로 반대되는 기능을 갖는 서비스 pair를 제공하라***
            - 대부분의 연산은 유사하거나 같거나 정반대의 연산을 갖는다
            - 진짜 필요한 기능만 구현하라
        - ***관련이 없는 정보를 다른 클래스로 옮겨라***
        - ***가능하면 인터페이스를 의미론적이기보다는 프로그래밍적으로 만들어라***
            - 각 인터페이스는 프로그래밍적인 부분 & 의미론적 부분으로 구성
                - 프로그래밍적 부분 : 인터페이스에서 컴파일러로 강제화할 수 있는 데이터형이나 특성
                - 의미론적 부분 : 인터페이스가 어떻게 사용될 것인지에 대한 가정
                    - 반드시 RoutineA를 RoutineB보다 먼저 호출해야한다
                    - RoutineA에 dataMember1에 전달되기 전에 초기화되지 않으면 RoutineA는 충돌할 것이다
        - ***코드 변경 시 인터페이스의 추상화가 망가지지 않도록 주의한다***
        - ***인터페이스 추상화에 맞지 않는 공개 멤버를 추가하지 말라***
            - 클래스 인터페이스에 루틴을 추가할 때마다 **“이 루틴이 기존 인터페이스가 제공하는 추상화와 일관성이 있는가?” 를 질문해라**
        - ***추상화와 응집도를 함께 고려하라***
            - 좋은 추상화를 제공하는 클래스 인터페이스는 일반적으로 강한 응집도를 갖는다
    - 좋은 캡슐화
        - 추상화와 캡슐화를 모두 갖거나 아니거나. 중간은 없다
        - ***클래스와 멤버의 접근성을 최소화하라***
            - ***“어떻게 해야 인터페이스 추상화의 무결성을 최상으로 유지할 수 있는가?”***
            - 노출시키는 루틴이 추상화와 일관성이 있다면 노출시켜도 상관없지만, 확신이 서지 않으면 일반적으로 숨기는 것이 숨기지 않는 것보다 낫다
        - ***멤버 데이터를 public으로 노출하지 말라***
            - float x 와 같은 멤버 데이터를 노출하는 것보다 float GetX();로 만들어라
        - ***내부 구현 세부 사항을 클래스의 인터페이스에 입력하지 말라***
            - 진정한 캡슐화는 개발자가 구현 세부 사항을 전혀 볼 수 없다
            - 예시
            
            ```cpp
            class Employee {
            public:
            	...
            	Employee(...);
            	...
            	FullName GetName() const;
            	String GetAddress() const;
            	...
            private:
            	// 구현 세부 사항이 이 포인터 내부에 감추어져 있다
            	EmployeeImplementation *m_implementation;
            }
            ```
            
        - ***클래스의 사용자를 가정하지 말라***
            - 클래스, 인터페이스 모두 수반된 계약대로 설계하고 구현해야한다
        - ***friend 클래스를 피하라***
            - State 패턴과 같은 특정 환경에서는 복잡성을 관리하기 위해 프랜드 클래스를 사용한다
            - ***friend 클래스는 캡슐화를 위반한다 → 한 번에 생각해야 하는 코드의 양을 늘려 복잡성을 증가시킨다***
            - "친구 클래스" 개념은 Java에서 기본적으로 지원되지 않습니다. 이는 클래스가 "친구"로 표시된 다른 클래스 또는 함수에 대한 개인 및 보호 멤버에 대한 액세스 권한을 부여할 수 있는 C++의 개념입니다. 이는 일반적으로 C++의 캡슐화 메커니즘에서 허용하는 것보다 밀접하게 연결된 클래스 간의 상호 작용 수준을 높이기 위해 종종 수행됩니다. Java에는 다른 액세스 제어 세트가 있으며 friend 키워드가 포함되어 있지 않습니다. 패키지 개인 가시성을 사용하거나 내부 클래스를 사용하여 Java에서 친구와 같은 동작을 모방할 수 있습니다.
            - 패키지 개인 가시성
                - 액세스 수정자(공용, 보호 또는 개인)를 지정하지 않으면 동일한 패키지의 다른 클래스에서 클래스, 필드 또는 메서드에 액세스할 수 있습니다. 이것은 friend 클래스와 완전히 동일하지는 않지만 동일한 패키지의 클래스 간에 더 높은 수준의 액세스를 허용합니다.
                - 예시
                
                ```java
                package com.example;
                
                class MyClass {
                    String name = "ChatGPT";
                }
                
                class MyFriendClass {
                    void display() {
                        MyClass myClass = new MyClass();
                        System.out.println("Hello, " + myClass.name);
                    }
                }
                ```
                
            - 내부 클래스
                - 내부 클래스는 비공개로 표시된 항목을 포함하여 외부 클래스의 모든 필드와 메서드에 액세스할 수 있습니다.
                - 이 예에서 `InnerClass`는 `OuterClass`의 내부 클래스이므로 `InnerClass`는 `OuterClass`의 `secret` 필드에 액세스할 수 있습니다.
                - 예시
                    
                    ```java
                    public class OuterClass {
                        private String secret = "OpenAI";
                    
                        class InnerClass {
                            void displaySecret() {
                                System.out.println("The secret is " + secret);
                            }
                        }
                    }
                    ```
                    
        - ***어떤 루틴이 공개 루틴만 사용한다고 해서 public 인터페이스에 두지 말라***
            - 루틴이 공개 루틴만 사용한다는 사실은 중요한 고려 사항이 아니다
            - 대신 그 루틴을 노출하는 것이 인터페이스에 의해 표현된 추상화와 일관성이 있는지 확인하라
        - ***코드를 작성할 때의 편의성보다 가독성이 높은 코드를 작성하라***
        - ***캡슐화의 의미론적인 위반을 각별히 주의하라***
            - 클래스의 사용자가 의미론적 캡슐화를 망가뜨리는 몇 가지 방법
                - 클래스 A의 PerformFirstOperation() 루틴이 initializeOperations() 루틴을 자동으로 호출하는 것을 알고 있기 때문에 클래스 A의 initializeOperations() 루틴을 호출하지 않는다
                - employee.Retrieve() 함수가 DB에 연결되어 있지 않을 때 DB에 연결한다는 것을 알고 있기 때문에 employee.Retrieve(database) 함수를 호출하기 전에 database.Connect() 루틴을 호출하지 않는다.
                - 클래스 A의 PerformFirstOperation() 루틴이 이미 호출되었다는 것을 알고 있기 때문에 클래스 A의 Terminate()루틴을 호출하지 않는다
                - ObjectA가 ObjectB를 정적 공간에 보관해서 ObjectB는 계속해서 접근할 수 있다는 것을 알고 있기 때문에 ObjectA에 의해서 생성된 ObjectB에 대한 포인터나 참조를 ObjectA가 영역을 벗어난 후에도 사용한다
                - 두 상수의 값이 같다는 것을 알고 있기 때문에 ClassA.MAXIMUM_ELEMENTS 대신 클래스 B의 MAXIMUM_ELEMENTS 상수를 사용한다
            - 이 예시의 문제는 클라이언트 코드가 클래스의 public 인터페이스에 의존하지 않고 private 구현에 의존하고 있다는 점
        - ***지나치게 밀접한 결합을 주의하라***
            - 클래스와 멤버의 접근성을 최소화하라
            - 프렌드 클래스는 너무 밀접하게 결합되기 때문에 피하라
            - 파생 클래스와 기본 클래스가 느슨하게 연결되도록 기본 클래스의 데이터를 protected가 아닌 private으로 선언하라
            - 클래스의 공개 인터페이스에서 멤버 데이터를 노출하지 말라
            - 의미론적인 캡슐화를 유지하라
            - 데미테르의 법칙을 준수하라

## 6.3 설계와 구현 문제

- 포함(”has a”관계)
    - containment(포함) 의 정의
        - 클래스가 데이터 요소나 객체를 포함한다는 개념
    - ***포함을 통해서 “갖다”를 구현하라***
        - 직원은 이름을 “갖고” 전화번호를 “갖는다”
        - Employee 클래스의 멤버 데이터로 만들어 포함을 구현할 수 있다
    - 최후의 수단으로 비공개 상속을 통해소 “has a”를 구현하라
        - 한 객체를 다른 객체의 멤버로 선언하는 것만으로는 포함을 구현할 수 없으므로, 포함되는 객체로부터 비공개적으로 상속을 받는 방법을 사용
        - 포함하는 클래스가 포함되는 클래스의 protected 멤버 함수와 멤버 데이터에 접근할 수 있도록 구성하기 위해 사용
    - ***약 7개 이상의 데이터 멤버를 포함하는 클래스를 주의하라***
        
        
- 상속(”is a” 관계)
    - 상속의 목적은 두 개 이상의 파생 클래스에서 공통으로 사용되는 요소를 갖는 기본 클래스를 정의해 더 간단한 코드를 작성하는 데 있음
    - 상속 사용을 하기 위한 결정
        - 각 멤버 루틴의 경우, 루틴이 파생 클래스에서 보일 것인가? 기본 구현을 포함할 것인가? 기본 구현의 override가 가능할 것인가?
        - 각 데이터 멤버(변수, 이름 상수, 열거형 등 포함)의 경우, 데이터 멤버가 파생 클래스에서 보일 것인가?
        - ***공개 상속을 통해 “이다(is a)”를 구현하라***
            - 기본 클래스는 파생 클래스가 어떻게 작동할 것인지를 예측하고 파생 클래스가 작동하는 방법에 제약을 가할 수 있다
            - 파생 클래스가 기본 클래스에 정의된 인터페이스 계약을 완벽하게 따르지 않는다면 포함이나 상속 계층 변경을 고려
        - ***상속을 고려해서 설계하고 문서화하라. 그게 아니면 상속을 금지하라***
        - ***리스코프 치환 원칙을 따르라***
            - 파생 클래스가 기본 클래스의 특수화된 버전(”is a”)이 아니라면 기본 클래스로부터 상속받아서는 안된다
        - ***상속받고 싶을 때만 상속받게 하라***
            - 파생 클래스는 멤버 루틴 인터페이스나 구현, 또는 둘 다 상속 받을 수 있다
            - 상속 루틴의 형태
                - 오버라이드 가능한 추상 루틴은 파생 클래스가 루틴의 인터페이스를 상속받지만 구현부는 상속받지 않는다는 것을 의미
                - 오버라이드 가능한 루틴은 파생 클래스가 루틴의 인터페이스와 기본 구현을 상속받으며 기본 구현을 오버라이드할 수 있다는 것을 의미한다
                - 오버라이드가 불가능한 루틴은 파생 클래스가 루틴의 인터페이스와 기본 구현을 상속받지만 루틴의 구현을 오버라이드할 수 없다는 것을 의미한다
        - ***오버라이드가 불가능한 멤버 함수를 “오버라이드”하지 말라***
        - ***공통으로 사용하는 인터페이스와 데이터, 행위를 상속 단계에서 가능한 한 가장 높은 곳으로 옮겨라***
            - 루틴을 높이 옮겼을 때 해당 객체의 추상화를 깬다면 거기서 멈춰라
        - ***인스턴스가 하나뿐인 클래스를 의심하라***
            - 생성한 인스턴스가 하나뿐일 때는 객체를 클래스로 잘못 알고 설계했을 수 있다
            - 새로운 클래스 대신 객체를 생성할 수 있는지 고려하라
        - ***파생 클래스가 하나뿐인 기본 클래스를 의심하라***
            - 파생 클래스가 하나뿐인 기본 클래스를 보면 개발자가 “너무 앞서 나가서 설계”하고 있다는 생각이 든다
            - 꼭 필요한 것 이상으로 상속 구조를 만들어서는 안 된다
        - ***루틴을 오버라이드했는데 파생된 루틴 내부에서는 아무것도 하지 않는 클래스들을 의심하라***
            - 이는 일반적으로 기본 클래스의 설계에 오류가 있다는 것을 암시
            - 이 오버라이드는 여러 문제가 있다
                - 인터페이스의 의미 변경
                - 다른 파생 클래스로 확장했을 때 문제 발생
                - 유지보수하기 어려운 코드 생성 → 부모 클래스의 인터페이스와 행위가 자손 클래스의 행위와 거의 아무런 연관성이 없음
        - ***깊은 상속 구조를 피하라***
            - 깊은 상속 구조는 오류의 증가와 깊이 연관되어 있다
        - ***광범위한 타입 검사보다 다형성을 택하라***
        - ***모든 데이터를 보호가 아닌 비공개로 만들어라***
    - 다중 상속
        - 다중 상속은 객체에 일련의 속성을 추가하는 데 사용하는 간단한 클래스인 “mixin”을 정의할 때 주로 쓸모가 있다 ⇒ 특성들이 파생된 클래스에 혼합될 수 있기 때문
        - 상속에 관한 규칙이 많은 이유
            - 상속을 사용할 지 말지 결정을 위한 내용

| 공통 데이터 | 공통 행위 | 결과                                  |
| ------ | ----- | ----------------------------------- |
| 공유 O   | 공유 X  | 다중 클래스가 그 클래스가 포함할 수 있는 공통 객체 생성    |
| 공유 X   | 공유 O  | 공통적인 루틴을 정의한 기본 공통 클래스를 상속          |
| 공유 O   | 공유 O  | 고옽ㅇ적인 데이터와 루틴을 정의한 기본 공통 클래스를 상속받는다 |
| 공유 X   | 공유 X  | 상속을 하고 인터페이스를 제어하고 싶다면 포함           |
- 멤버 함수와 데이터
	- ***클래스에 가능한 한 적은 수의 루틴을 유지하라***
		- 루틴의 수를 최소화하는 것과 다른 요인 중 무엇이 더 중요한지 평가하라
	- ***원하지 않는 멤버 함수와 연산자가 암묵적으로 생성되지 않도록 하라***
	- ***클래스에서 호출되는 루틴의 수를 최소화하라***
		- 클래스가 사용한 클래스가 많을수록 오류도 증가한다 → “***팬 아웃”***
	- ***다른 클래스에 대한 간접적인 루틴 호출을 최소화하라***
		- 데미테르의 법칙
			- 객체 A가 자신의 루틴은 어느 것이든 호출할 수 있다
			- 객체 A가 객체 B의 인스턴스를 만들었다면 객체 B의 루틴은 모두 호출 할 수 있다. 하지만 객체 B가 제공하는 객체의 루틴은 호출하지 않아야한다
	- ***일반적으로 클래스가 다른 클래스와 협력하는 정도를 최소화하라***
		- 인스턴스로 만드는 객체의 수
		- 인스턴스로 만든 객체에 대한 서로 다른 직접적인 루틴 호출의 수
		- 인스턴스로  만든 다른 객체가 반환하는 객체에 대한 루틴 호출의 수
- 생성자
	- ***가능하다면 모든 멤버 데이터를 모든 생성자에서 초기화하라***
	- ***비공개 생성자를 사용해 싱글턴 속성을 구현하라***
	- ***다른 사실이 증명될 때까지 얕은 복사보다 깊은 복사를 택하라***
		- 깊은 복사는 객체의 멤버 데이터를 복사
		- 얕은 복사는 참조 복사
		- 얕은 복사는 성능 향상 목적 ⇒ 확실하지 않은 성능 이득을 위해 복잡성을 추가하는 것보다 특별한 이유가 없다면 깊은 복사를 선택하라

## 6.4 클래스를 작성하는 이유

- 클래스를 생성하는 이유
    - ***현실 세계의 객체를 모델링한다***
    - ***추상 객체를 모델링한다***
        - 추상 객체, 실체는 없지만 다른 실질적인 객체의 추상화를 제공하는 객체를 모델링하기 위함
        - Circle과 Sqaure는 실제 존재하지만, Shape는 다른 구체적인 도형들에 대한 추상화
        - 적절한 추상화 객체를 생각해내는 것이 객체지향 설계에서 가장 어려운 문제
    - ***복잡성을 줄인다***
        - 프로그램의 복잡성 감소
        - 코드의 크기를 최소화하거나 유지보수를 쉽게 하거나 정확성을 향상시키는 것
    - ***복잡성을 고립시킨다***
        - 오류가 발생했을 때 오류가 코드 전체에 퍼져 있지 않고 어떤 클래스 안에만 있다면 훨씬 쉽게 찾을 수 있다
        - 개발 도중에도 다양한 설계를 쉽게 시도해 볼 수 있고 그중에서 가장 좋은 설계를 선택할 수 있다
    - ***구현 세부 사항을 숨긴다***
        - 클래스 생성을 통해 구현 세부 사항을 숨긴다
    - ***변경의 효과를 제한한다***
        - 변경 가능성이 있는 부분을 고립시켜서 변경의 효과를 단일 클래스나 소수의 클래스로 제한
        - 변경 가능성이 가장 높은 부분을 가장 쉽게 변경할 수 있도록 설계하라
    - ***전역 데이터를 숨긴다***
        - 전역 데이터를 사용할 필요가 있다면 구현 세부 사항을 클래스 인터페이스 뒤에 숨길 수 있다
        - 이에 대한 이점은 프로그램을 변경하지 않고 데이터의 구조를 변경할 수 있고, 데이터에 대한 접근을 감시할 수 있다
        - 접근 루틴을 사용하는 원칙을 지키면 그 데이터가 정말로 전역으로 선언되어야 하는지 알 수 있다
    - ***매개변수 전달을 간소화한다***
        - 어떤 매개변수가 여러 루틴 사이에서 전달되고 있다면 매개변수를 객체 데이터로 공유하는 클래스에 여러 루틴이 필요할 수 있다는 뜻
    - ***중앙 집중 관리한다***
        - 한 곳에서 작업을 처리하는 것
        - 예시 - 클래스 하나를 사용해 DB I/O 제어
    - ***코드 재사용을 돕는다***
        - 잘 분리된 클래스에 코드를 작성하면 하나의 큰 클래스에 코드가 포함되어 있을 때보다 쉽게 다른 프로그램에서 재사용될 수 있다
    - ***프로그램 전체를 고려한다***
        - 프로그램이 변경될 것으로 예상하고 있다면 그러한 부분을 별도의 클래스에 입력해 고립시키는 것이 좋다
    - ***연관된 기능을 패키지로 구성한다***
        - 정보를 숨기거나 데이터를 공유하거나 확장 가능한 형태로 설계할 수 없다면, 관련된 기능을 패키지화하라
    - ***특정한 리팩터링을 수행한다***
        - 하나의 클래스를 두 개의 클래스로 변환하고 위임을 감추고 중간자를 제거하고 확장 클래스를 마드는 방법으로 새로운 클래스를 만들 수 있다
    
- 피해야 할 클래스
    - ***God 클래스를 생성하지 말라***
        - 모든 것을 알고 있고 모든 것을 할 수 있는 전지전능한 클래스를 생성하지 마라
    - ***관련이 없는 클래스를 제거하라***
        - 클래스가 행위는 없이 데이터로만 구성된다면 그 클래스가 정말로 클래스인지 생각해보고 그 클래스를 없애서 클래스의 멤버 데이터가 다른 클래스의 속성이 될 수 있는지 고려
    - ***동사를 뒤에 붙이는 클래스를 피하라***
        - 데이터는 없이 행위로만 구성된 클래스는 일반적으로 클래스가 아니다
        - *DatabaseInitialization()* 이나 *StringBuilder()*와 같은 클래스를 다른 클래스의 루틴으로 변환할 것을 고려

## 6.5 프로그래밍 언어와 관련된 이슈

- 파생 클래스에서 다형성을 구현하기 위해 멤버 루틴을 어떻게 오버라이드 하는지 생각해보자
- 프로그래밍 언어마다 크게 다른 점
    - 상속 트리에서 오버라이드된 생성자와 소멸자의 작동 방식
    - 예외 처리 조건에서 생성자와 소멸자의 작동 방식
    - 기본 생성자(인자가 없는 생성자)의 중요성
    - 소멸자나 finalizer가 호출되는 시기
    - 할당과 equality 연산자와 같이 프로그래밍 언어에서 기본으로 제공하는 연산자들을 오버라이드하는 방법
    - 객체가 생성되고 소멸될 때나 객체가 선언되고 범위를 벗어날 때 처리되는 메모리 처리 방식
    

## 체크리스트

![[codeComplete12.png]]
![[codeComplete13.png]]

## 7장 고급 루틴

## 7.1 루틴을 작성하는 이유

- 루틴의 목적
    - ***복잡성을 줄인다***
        - 루틴 작성 시에는 루틴에 대해 생각하겠지만 일단 루틴을 작성하고 나면 루틴의 내부 동작 방식을 몰라도 해당 루틴의 구현 세부 사항을 신경쓰지 않고 루틴을 사용할 수 있음
        - 내부 루프나 조건문이 깊게 중첩되어 있다면 루틴을 서브 루틴으로 나누어야 한다
    - ***이해하기 쉬운 중간 단계의 추상화를 도입한다***
        - 코드의 일부를 이해하기 쉬운 이름의 다른 루틴으로 작성하는 것이 좋다
    - ***중복 코드를 피한다***
        - 코드가 반복되면 루틴을 작성해야 한다
    - ***서브 클래싱을 지원한다***
        - 길고 구조화가 덜 된 루틴보다 길이도 짧고 구조적으로 완성도 높은 루틴을 오버라이드하면 변경할 내용이 많지 않다
        - 오버라이드가 가능한 루틴을 간단하게 유지하면 서브클래스 구현에서 오류가 발생할 확률도 줄어든다
    - ***코드의 실행 순서를 감춘다***
        - 이벤트가 처리되는 순서를 숨기는 것이 좋다
    - ***포인터 연산을 감춘다***
        - 포인터 연산을 루틴에 구현함으로써 복잡한 포인터 연산에 대한 고민 없이 개발에만 집중할 수 있다
        - 포인터 연산을 한 곳에서 처리함으로써 더욱 안전한 코드를 개발 가능
    - ***이식성을 높인다***
        - 루틴을 사용하면 미래에 이식이 가능한 기능과 아닌 기능을 구분할 수 있다
    - **복잡한 불린 테스트를 단순화한다**
        - 테스트를 함수로 작성하면 코드를 좀 더 쉽게 이해할 수 있다
    - **성능을 개선한다**
        - 여러 곳에 있는 코드 대신 하나의 루틴에 있는 코드를 최적화할 수 있다
        - 코드를 한 곳에 작성해 놓으면 비효율적인 부분을 찾기 위해 더 쉽게 분석할 수 있다
    - ***모든 루틴의 길이를 짧게 만들기 위해서?***
        - 이 이유는 불필요
        - **크기가 큰 하나의 루틴 내에서 처리하는 것이 좋은 경우도 있다**
    - 루틴으로 작성하기에는 너무 단순해 보이는 연산
        - 길이가 짧은 루틴의 장점
            - 가독성 향상
            - 코드 반복을 줄일 수 있다

## 7.2 루틴 수준의 설계

- 루틴에서의 응집성
    - 정의 : 루틴에 있는 연산들이 얼마나 밀접하게 연관되어 있는지를 나타낸다
    - 응집성이 높을수록 코드의 오류가 적다
    - 기능적 응집성 : 루틴이 오직 하나의 연산만 처리하는 경우, 가장 바람직한 형태
    - 순차적 응집성 : 루틴을 특정한 순서대로 수행해야하고 단계마다 정보를 공유하며 동시에 수행할 때 완전한 기능을 제공하지 못하는 연산을 포함할 때 존재한다
    - 통신적 응집성
        - 루틴에 있는 연산들이 같은 데이터를 사용하지만, 서로 아무런 연관성이 없을 때 발생
        - 어떤 루틴이 요약 보고서를 출력하는 기능과 루틴에 전달된 데이터를 초기화하는 기능을 구현하고 있다면 이 루틴은 통신적 응집성을 갖는다
        - 더 나은 응집성을 갖기 위해서 보고서 출력 루틴이 아니라 요약 데이터를 생성한 루틴에서 초기화 작업을 수행해야 한다
    - 시간적 응집성
        - 여러 연산이 동시에 수행되어야 해서 하나의 루틴으로 결합할 때 발생
        - 이 문제를 피하기 위해서 다른 이벤트의 구성자로서 시간적 루틴을 생각하라
    - 지양해야하는 응집성
        - 절차적 응집성
            - 루틴에 있는 연산들을 정해진 순서대로 처리할 때 발생
            - 직원의 이름을 받은 후 주소와 전화번호 순으로 입력받는 루틴이 예시
            - 응집성을 개선하기 위해서 독립적인 기능을 별도의 루틴에 구현한다. GetFirstPartOfEmployeeData() 대신 GetEmployee() 처럼 호출하는 루틴이 하나의 온전한 기능을 갖도록 한다
            - 기능적 응집성을 달성하기 위해서 일반적으로 두 개 이상의 루틴을 변경해야한다
        - 논리적 응집성
            - 여러 가지 기능을 한 루틴에서 수행할 때 루틴에 전달되는 조건에 따라 수행하는 기능이 다른 경우
            - 루틴의 논리적인 흐름에 의해 각 기능을 처리한다는 의미
            - 한 예로 루틴에 어떤 타입을 전달하느냐에 따라 고객의 이름이나 직원의 근무 시간 정보, 재고 정보를 입력하는 루틴의 경우
            - 이 경우 매개변수에 따라 작업 호출이 달라지는 것이 아니라 독립적인 연산을 수행하는 세 개의 루틴을 만들어야함
            - if나 case문의 연속으로 구성되어 있고 다른 루틴을 호출하고 있다면 논리적으로 응집된 루틴을 생성해도 별 문제는 없다 → 루틴의 유일한 기능이 정해진 명령을 처리하는 것일뿐 자체적으로 아무것도 실행하지 않는다면 일반적으로 좋은 설계 ⇒ Event Handler
        - 우연적 응집성
            - 루틴에 있는 연산이 특별한 연관 관계를 맺지 않을 때 발생
    

## 7.3 좋은 루틴 이름

- 효과적인 루틴 이름을 작성하기 위한 지침
    - ***루틴이 하는 모든 것을 표현하라***
        - 루틴 이름에 모든 출력과 부수적인 효과를 설명하라
        - 이름이 너무 길고 우스꽝스러울 경우 더 나은 이름을 갖기 위한 노력보다 루틴이 가급적이면 부수적인 영향을 갖지 않도록 코드를 작성해 루틴의 역할을 좀 더 분명하게 해야한다
    - ***의미가 없거나 모호하거나 뚜렷한 특징이 없는 동사를 사용하지 말라***
        - 해당 루틴과 관련된 루틴들을 재구성해 모든 루틴이 분명한 목적을 갖고 루틴의 기능을 정확하게 설명하는 이름을 갖도록 재구성하라
    - ***루틴 이름을 숫자만으로 구분하지 말라***
        - Part1, Part2 같은 루틴을 사용하지 말라
    - ***루틴 이름의 길이에 신경 쓰지 마라***
        - 전반적으로 루틴 이름은 ***“명료함”***에 초점을 맞추고, 이름의 길이에 제약을 받지 않고 이해하기 쉽게 이름을 지어야한다
    - ***함수의 이름을 지을 때는 리턴 값에 관해서 설명하라***
        - 함수는 값을 리턴하므로 리턴 값에 대한 내용이 이름에 포함되어야한다
        - printer.IsReady(), pen.CurrentColor() 같은 이름을 지어라
    - ***프로시저의 이름을 지을 때 확실한 의미가 있는 동사를 객체 이름과 함께 사용하라***
        - 객체에 대한 연산은 동사에 객체 이름을 붙여 쓴 형태의 이름을 갖도록 하라
        - PrintDocument(), CalcMonthlyRevenues(), CheckOrderInfo()
    - ***반의어를 정확하게 사용하라***
        - 반의어에 대한 이름 규약을 사용하면 일관성을 유지하는데 도움을 주고 이해하기 쉽다
        - add/remove | increment/decrement | open/close
    - ***공통적인 연산을 위한 규약을 만들어라***
        - 시스템 환경에 따라 각 연산을 명확하게 구분하는 일은 매우 중요하다. 이름 규약은 그러한 차이를 표현하기 위한 가장 쉽고 신뢰할만한 방법이다

## 7.4 루틴의 길이에 대한 문제

- 이론적으로 코드의 가장 적합한 최대 길이는 한 화면에 꽉 찰 정도나 출력했을 때 한두 페이지 분량인 50~150줄 정도
- 200줄 이상의 긴 루틴을 작성하고자 할 때는 주의해야한다

## 7.5 루틴 매개변수 처리

- 인터페이스 문제를 최소화하는 지침
    - ***매개변수를 입력-수정-출력 순서로 입력한다***
        ```java
        import java.util.List;
        import java.util.Collections;
        
        public class Example {
            public static void main(String[] args) {
                // Input: a list of integers
                List<Integer> numbers = Arrays.asList(5, 3, 8, 1, 2);
        
                // Modification: sorting the list
                List<Integer> sortedNumbers = sortNumbers(numbers);
        
                // Output: print out the sorted list
                System.out.println(sortedNumbers);
            }
        
            private static List<Integer> sortNumbers(List<Integer> numbers) {
                // Create a copy of the input list to avoid modifying the original one
                List<Integer> sortedNumbers = new ArrayList<>(numbers);
        
                // Sort the copy
                Collections.sort(sortedNumbers);
        
                // Return the sorted list
                return sortedNumbers;
            }
        }
        ```
        
    - ***고유한 in과 out 키워드의 사용을 고려한다***
        - *IN, OUT 키워드는 생소하므로, 자신이 사용하는 프로그래밍 언어를 이와 같은 방식으로 확장한다면 일관성이 있어야한다*
        - *IN, OUT 키워드는 컴파일러와 무관하므로 매개변수를 IN으로 선언하더라도 루틴 내부에서 해당 변수를 변경할 수 있다*
    - ***유사한 매개변수가 여러 루틴에서 사용된다면 해당 매개변수를 항상 같은 순서로 입력한다***
    - ***모든 매개변수를 사용한다***
        - 루틴에 매개변수를 전달하면 매개변수를 반드시 사용해야한다
        - 사용하지 않는다면 루틴 인터페이스에서 매개변수를 제거해야한다
        - ***프로그램 일부를 조건에 따라 컴파일하고 있다면 특정한 매개변수를 사용하는 루틴의 일부는 컴파일하지 않아야한다***
    - ***상태 변수나 오류 변수를 마지막에 입력한다***
    - ***루틴의 매개변수를 연산을 위한 변수로 사용하지 않는다***
        - 루틴에 전달한 매개변수를 연산을 위한 지역 변수처럼 사용하지 않아야 한다
        - 예시
            ```java
            public int Sample(int inputVal) {
            	inputVal = inputVal * currentMultiplier(inputVal);
            	inputVal = inputVal * currentAdder(inputVal);
            	...
            	return inputVal;
            }
            ```
            
        - 입력 매개변수를 잘 사용하는 예제
            ```java
            public int Sample(int inputVal) {
            	int workingVal = inputVal;
            	workingVal = workingVal * currentMultiplier(workingVal );
            	workingVal = workingVal * currentAdder(workingVal );
            	...
            	// inputVal의 값을 어디던 사용할 수 있음
            	...
            	return workingVal;
            }
            ```
            
    - ***매개변수에 대한 제약사항을 주석으로 작성한다***
        - 루틴에서 입력받는 데이터가 특정한 조건을 만족해야만 한다면 제약사항을 설명해야 한다
        - 제약 사항을 주석으로 작성하는 것보다 훨씬 좋은 방식은 assertion을 사용하는 것이다
        - 매개변수를 주석으로 작성해야할 조건
            - 매개변수가 입력을 위한 것인지, 변경되는지, 값을 반환하기 위한 것인지에 대한 내용
            - 숫자 매개변수의 단위(인치, 피트, 미터 등)
            - 열거형이 아닌 경우 상태 코드와 오류 값의 이미
            - 값의 범위
            - 절대로 가질 수 없는 값
    - ***루틴 매개변수의 수를 7개 정도로 제한한다***
    - ***매개변수에 사용할 입력, 수정, 출력 이름 규약을 고려한다***
        - 식별할 수 있는 이름 규약을 작성해야한다
    - ***루틴이 인터페이스 추상화를 유지할 수 있도록 변수나 객체를 전달한다***
        - 루틴에 전달하는 매개변수의 목록을 자주 변경하고, 그 매개변수가 동일한 객체로부터 온 것이라면 구체적인 요소들 대신 전체 객체를 전달해야한다
    - ***named 매개변수를 사용한다***
    - ***실질적인 매개변수가 형식적인 매개변수와 일치하는 지 확인한다***
        - 실제 루틴 호출에서 사용되는 변수나 상수, 표현식

## 7.6 함수를 사용할 때 특별히 고려해야 할 사항

- 함수를 사용할 때와 프로시저를 사용할 때
    - **함수는 입력을 위한(읽기 전용) 매개변수만 받아야 하고 오직 하나의 값만을 리턴해야 한다**
    - 함수 이름은 sin(), CustomerID(), ScreenHeight()처럼 함수가 리턴하는 값을 고려해야한다
    - 호출과 검사를 함수를 사용하는 예
        
        ```java
        outputStatus = report.FormatOutput(formattedReport);
        if( outputStatus == suceess){ then ... }
        ```
        
    - 루틴의 일차적인 목적이 함수의 이름에서 가리키고 있는 값을 반환하는 것이라면 함수를 사용하라. 그렇지 않다면 프로시저를 사용하라
- 함수 리턴 값 설정
    - ***가능한 모든 리턴 경로를 검사하라***
        - 루틴을 작성할 때 모든 가능한 환경에서 함수가 값을 리턴하는지 확인하기 위해 각각의 경로를 머릿속으로 실행해본다
        - 함수를 시작할 때 리턴 값을 기본값으로 초기화하는 것이 좋은 습관
    - ***지역 데이터에 대한 참조나 포인터를 리턴하지 말라***
        - 루틴이 끝나자마자 지역 데이터는 범위를 벗어나고 지역 데이터에 대한 참조나 포인터는 무효화 상태가 될 것이다.
        - 객체가 내부 데이터에 대한 정보를 리턴해야 한다면 그러한 정보를 클래스의 멤버 데이터로 저장해야한다
        - 지역 데이터에 대한 참조나 포인터 대신 멤버 데이터 항목의 값을 리턴하는 접근자 함수를 제공해야한다

## 7.7 매크로 루틴과 인라인 루틴

- 전처리기 매크로로 작성된 루틴의 고려 사항
    - ***매크로 표현식을 괄호로 묶어라***
        - 작성되는 매크로를 c++로 작성한 예제
            ```cpp
            #define Cube(a)_ ((a)*(a)*(a))
            ```
            
    - ***다중 명령문 매크로를 중괄호로 감싸라***
        - 여러 명령문으로 구성된 작동하는 매크로를 c++로 작성한 예제
            ```cpp
            #define LookupEntry(key, index) { \
            	index = (key - 10) / 5;
            	index = min(index, MAX_INDEX); \
            	index = max(index, MAX_INDEX); \
            }
            ```
            
    - ***필요한 경우 루틴으로 대체될 수 있도록 매크로의 이름을 루틴과 비슷하게 작성하라***
        - 해당 매크로를 루틴으로 대체하려고 한다면 처음부터 매크로의 이름을 함수처럼 만들자
- 매크로 루틴의 한계
    - 매크로를 대신할 수 있는 다양한 대안
        - **상수 값을 선언하기 위한 const**
        - **인라인 코드로 컴파일 될 함수를 정의하기 위한 inline**
        - **min, max 등과 같은 표준 연산을 타입에 맞게 안전한 방법으로 처리하기 위한 template**
        - **열거형을 정의하기 위한 enum**
        - **간단하게 새로운 타입을 정의하기 위한 typedef**
- 인라인 루틴
    - **컴파일러가 컴파일 하면서 해당 루틴을 인라인 코드로 변환하라**
    - **인라인 루틴을 자주 사용하지 말라**
    

> **체크리스트**
>![[codeComplete14.png]] 
# 8장 방어적 프로그래밍

## 8.1 잘못된 입력으로부터 프로그램 보호

- 프로그램 보호하기
    - 소프트웨어에서 Grabage in했다고 해서 garbage out을 해서는 안된다
    - 쓰레기 입력 처리를 위한 세 가지 방법
        - ***외부로부터 들어오는 모든 데이터의 값을 검사하라***
            - 데이터 허용 범위 체크
            - 시스템을 공격하려는 데이터(buffer overflow, SQL Injection, HTML,XML injection, Integer overflow, 시스템 호출에 전달되는 데이터)들을 조심해라
        - ***루틴의 모든 입력 매개변수 값을 검사하라***
        - ***잘못된 입력을 어떻게 처리할 것인지를 결정하라***
    - 방어적 프로그래밍은 품질 개선 기법의 보조 수단
    - 방어적 코드 작성의 가장 좋은 형태는 처음부터 오류를 입력하지 않는 것
    - 반복적 설계, 의사코드 작성, 코드 작성 전 테스트 케이스 작성, 저수준 설계에 대한 정밀 검사는 버그가 만들어지는 것을 예방할 수 있다

## 8.2 Assertion

- Assertion
    - 정의 : 루틴이나 매크로 실행 시 프로그램이 스스로 검사할 수 있도록 사용하는 코드
    - 크고 복잡한 프로그램과 높은 신뢰도를 보장해야 하는 프로그램에서 유용
    - 예시
        
        ```java
        assert denominator != 0 : "denominator is unexpected equal to 0";
        ```
        
    - 사용할 수 있는 경우
        - I/O 매개변수의 값이 예상된 범위 안에 들어가는 지
        - 파일이나 스트림이 루틴이 시작 혹은 끝날 때 열려있는지 닫혀있는지 확인할 때
        - 파일이나 스트림이 루틴이 시작 혹은 끝날 때 시작 혹은 끝에 있는지
        - 파일이나 스트림이 읽기 전용이나 쓰기 전용, I/O로 열려있는지
        - 입력만 가능한 변수의 값이 루틴에 의해 변경되지 않는지
        - 포인터가 Null이 아닌지
        - 루틴에 전달되는 배열이나 다른 컨테이너가 적어도 X개의 데이터 요소를 포함할 수 있는지
        - 테이블이 실제 값을 포함할 수 있도록 초기화하는지
        - 컨테이너가 루틴이 시작할때 혹은 끝날 때 비어 혹은 채워져 있는지
        - 매우 최적화되어 있고 이해하기 어려운 루틴의 결과가 수행 속도는 느리지만 이해하기 쉬운 루틴의 결과와 일치하는지
    - 일반적으로 Assertion은 개발 버전에서는 코드에 포함해 컴파일하지만, 제품에서는 제외
- 자신만의 ***Assertion*** 메커니즘 구축하기
    - Aseertion 사용 지침
        - ***발생이 예상되는 상황에서 오류 처리 코드를 사용하되, 절대로 발생해서는 안 되는 조건은 Assertion 사용하기***
            - Assertion은 절대로 발생해서는 안 되는 조건을 검사
            - 오류 처리 코드는 그렇게 자주 발생하지 않지만 코드를 작성한 개발자가 예상하는 범위 내에 있고 제품 코드에서 처리해야 하는 비정상적인 환경을 검사
            - **일반적으로 오류 처리는 잘못된 입력 데이터를 검사하고 Assertion은 코드상의 버그를 검사한다**
            - Assertion은 어떤 기능을 구현하는 데 사용할 수는 없지만, 프로그램 언어의 주석보다 능동적으로 개발자가 생각하고 있는 가정을 문서화 가능하다
        - ***실행할 가능성이 있는 코드를 Assertion 내에 입력하지 않는다***
            - 실행문은 별도의 줄에 입력하고 그 결과를 상태 변수에 할당한 다음 상태변수를 테스트하라
            - 예시
                
                ```java
                actionPerformed = PerformAction()
                Debug.Assert(actionPerformed)
                ```
                
        - ***선행 조건과 후행 조건을 문서화하고 검증하는 데 Assertion을 사용하라***
            - 선행 조건과 후행 조건이 사용될 때 각 루틴이나 클래스는 프로그램의 나머지 부분과 하나의 계약을 형성한다
            - *선행 조건 :* 루틴이나 클래스에서 다른 루틴을 호출하거나 객체를 생성하기 전에 반드시 참이어야하는 특성. **선행 조건은 루틴을 호출하는 쪽에서 반드시 지켜져야한다**
            - *후행조건 :* 루틴이나 클래스를 호출하고 난 후에 반드시 참이어야 하는 조건. **후행 조건은 호출된 코드나 클래스가 지켜야 하는 약속**
            - 예시
                ```java
                private float velocity(float latitude, float longitude, float elevation) throws Exception {
                    // Preconditions
                    if (!(latitude >= -90 && latitude <= 90)) {
                        throw new Exception("Precondition failed: -90 <= latitude and latitude <= 90");
                    }
                    
                    // Function Body
                    // Since there is no computation given for `returnVelocity` I will assume it is 0. 
                    // Replace it with the correct calculation.
                    float returnVelocity = 0;
                
                    // Postconditions
                    if (!(returnVelocity >= 0 && returnVelocity <= 600)) {
                        throw new Exception("Postcondition failed: 0 <= returnVelocity And returnVelocity <= 600");
                    }
                    
                    // Return value
                    return returnVelocity;
                }
                ```
                
        - ***매우 견고한 코드를 작성하기 위해서는 Assertion은 무조건 포함하고 그다음에 오류를 처리하라***
## 8.3 오류 처리 기법

- 오류 처리 방법
    - ***중립적인 값을 반환한다***
        - 잘못된 데이터에 대한 가장 좋은 대응은 작업을 계속 수행하더라도 아무런 문제가 없다고 알려진 값을 반환하는 방법
        - 수식이라면 0을 반환, 문자열 연산에서는 빈 문자열 반환, 포인터 연산은 빈 포인터 변환
    - ***다음에 오는 유효한 데이터로 대체한다***
        - 에러한 값은 버리고 다음 유효한 데이터로 대체한다
    - ***이전과 같은 값을 반환한다***
        - 변화값이 치명적인 문제로 여겨진다면(ex. 현금 인출기의 거래 인증) 큰 문제로 발생할 수 있다
    - ***가장 가까운 유효한 값으로 대체한다***
    - ***경고 메시지를 파일에 기록한다***
        - 잘못된 데이터를 감지하면 경고 메시지를 파일에 기록한 다음 계속해서 실행하는 방법
        - 로그를 사용한다면 공개할 수 있는지 또는 암호화해서 보호해야 하는지 고려하도록 해야한다
    - ***오류 코드를 반환한다***
        - 시스템의 특정한 부분만 오류를 처리하도록
            - 구현
                - 상태 변수에 값을 설정
                - 함수의 리턴 값으로 상태 값을 반환( Http Status)
                - 프로그래밍 언어에서 기본 제공하는 예외 메커니즘을 사용해 예외를 던진다
    - ***오류 처리 루틴이나 객체를 호출한다***
        - 오류 처리를 전역적인 오류 처리 루틴이나 오류 처리 객체에 집중 시키는 방법
        - 오류 처리 부분을 집중시켜 디버깅이 쉬워짐
        - 전체 프로그램이 이 기능을 알게 되고, 이 기능과 매우 밀접하게 결합하게 된다
    - ***오류가 발생한 곳에서 오류 메시지를 출력한다***
        - 오류 처리의 오버헤드 최소화
        - 사용자 인터페이스 메시지가 전체 응용 프로그램에 영향을 미치게 되어 일관성 있는 사용자 인터페이스를 작성해야 할 때나 UI와 시스템의 나머지 부분을 구분하려고 할 때, 소프트웨어를 다른 언어로 지역화하려고 할 때 어려움을 겪을 수 있다
    - ***상황에 따라 가장 잘 작동하는 방법으로 오류를 처리한다***
        - 개발자에게 엄청난 유연성을 제공
        - 시스템에 전체적인 성능이 정확성과 견고성에 대한 요구사항을 만족시키지 못하는 심각한 위험을 초래
        - 개발자가 개별 오류 처리에 따라 사용자 인터페이스 코드가 시스템 전체에 퍼져 오류 메시지 출력과 연관된 모든 문제점을 노출할 가능성도 있다
    - ***종료한다***
        - 안전성이 매우 중요한 프로그램에서 유용
- 견고함 대 정확성
    - ***정확성** :* 절대로 부정확한 결좌를 반환할 수 없다는 것을 의미
    - ***견고함*** : 부정확한 결과를 만들어 내더라도 소프트웨어가 작동할 수 있도록 계속 무언가를 하려고 애쓰는 것
    - **안전성이 중요하면 정확성**을, **개인용 응용 프로그램은 견고함**을 선호하는 경향이 있다
- 오류 처리를 위한 상위 수준에서의 설계
    - 오류 처리 방법은 소프트웨어가 정확성, 견고성, 다른 비기능적인 특성과 관련된 요구사항을 충족시키는 능력에 영향을 미친다
    - 잘못된 매개변수에 대한 일반적인 접근 방법을 선택하는 것은 아키텍처 수준이나 상위 수준에서의 설계에 관한 결정이며 둘 중 한 수준에서 처리해야 한다
    - 접근 방법을 선택하고 나면 일관성 있게 따라야 한다
    - 상위 수준에서의 코드가 오류를 처리하게 하고 하위 수준에서의 코드는 오류를 보고하기만 하기로 했다면 상위 수준 코드가 실제로 오류를 처리하게 하라

## 8.4 예외

- 예외
    - 코드가 오류나 예외적인 이벤트를 루틴을 호출한 코드에 전달할 수 있는 특수한 방법
    - 어떤 루틴에서 코드가 어떻게 처리해야 하는지를 모르는 예외적인 상황에 부딪히면 예외를 던진다
    - 예외는 상속과 공통 특성을 갖는다
        - 신중하게 사용하면 복잡성을 줄일 수 있다
        - 무분별하게 사용하면 이해하기가 거의 불가능한 코드를 만들 수 있다
    - 예외와 연관된 난관을 피하기 위한 방법
        - ***예외를 사용해 무시해서는 안 되는 오류를 프로그램의 다른 부분에 알린다***
            - 오류가 발생한 상황을 알리는 능력이 중요
            - 오류 조건이 감지되지 않은 코드를 통해 오류가 통과할 가능성을 예외는 제거한다
        - ***정말로 예외적인 조건인 경우에만 예외를 던져라***
            - 다른 코드 작성 습관으로는 해결할 수 없는 경우에만 사용하라
            - 예외를 사용할 때는 예상치 못한 조건을 처리하는 강력한 방법과 복잡성 증가 사이에 균형을 맞춰야한다 ⇒ 예외는 루틴을 호출하는 코드가 호출된 코드의 내부에서 어떤 예외를 던질 것인지를 아는 것이므로 캡슐화를 약화한다
        - ***책임을 전가하기 위해서 예외를 사용하지 않는다***
            - 오류를 발생시키는 코드는 처리 가능하다면 처리하라
        - ***생성자와 소멸자에서 예외를 잡을 수 없다면 생성자와 소멸자에서 예외를 던지지 않는다***
            - 예외를 생성자와 소멸자에서 발생시킨다고 가정하면 코드가 매우 복잡해진다
                - 만약 그리할 경우 생성자에서 예외 발생 시 소멸자가 호출되지 않아 리소스 누수가 있을 수 있다(c++의 경우)
        - ***올바른 추상화 수준에서 오류를 던진다***
            - 루틴은 루틴의 인터페이스에서 일관된 추상화를 제공해야 한다
            - 루틴을 호출한 쪽에 예외를 던지기로 했다면 예외의 추상화 수준이 루틴 인터페이스의 추상화 수준과 일관성있게 한다
        - ***예외를 발생시킨 모든 정보를 예외 메시지에 포함한다***
            - 예외 메시지를 읽는 사람에게 유용하므로 메시지에는 예외가 발생한 이유를 이해하는 데 필요한 정보를 포함하도록 한다
        - ***비어있는 catch 블록을 피한다***
            - catch 블록에 관한 설명이 있어야한다
                
                ```java
                try {
                	...
                } catch( AnException exception) {
                	Log.Error("Unexpected exception");
                }
                ```
                
        - ***라이브러리 코드가 던지는 예외를 파악한다***
            - 라이브러르 코드에서 발생한 예외를 잡지 못하면 프로그램 충돌이 발생하므로, 라이브러리가 발생시킬 예외를 작성해야한다
        - ***중앙 집중화된 예외 보고 시스템 구축을 고려한다***
            - 예외 처리에서 일관성을 보장하는 방법
            - 공통 로거나 Exception 처리 방법 고려하기
        - ***프로젝트의 예외 사용을 규격화한다***
            - C++와 같이 다양한 객체, 데이터, 포인터를 던질 수 있는 프로그래밍 언어를 사용한다면 구체적으로 무엇을 던질 것인지 규격을 결정하기
            - 프로젝트에서 발생시키는 모든 예외에 대해 기본 클래스로 사용할 수 있는 프로젝트에 특화된 예외 클래스 작성을 고려해보기. 기록, 오류 보고 등을 집중시키고 규격화할 수 있다
            - 오류를 처리하기 위해서 어떤 코드가 throw-catch 문법을 사용할 수 있는지에 대해 구체적인 상황을 정의
            - 어떤 코드가 처리되지 않는 예외를 던질 수 있는지에 대해 구체적인 상황을 정의
            - 중앙 집중화된 예외 보고자가 사용될 것인지 결정
            - 예외가 생성자와 소멸자에서 허용되는지 정의
        - ***예외의 대안의 고려해본다***
            - 정말로 예외 처리가 필요한지 고려해보기

## 8.5 오류로 인한 손해를 막기 위한 방책

- 바리케이트 치기
    - 특정한 인터페이스를 “안전한” 지역으로 가는 경계로 사용하기
    - 안전한 지역의 경계를 지나는 데이터의 유효성을 검사하고 데이터가 유효하지 않다면 적절하대 대응
	    ![[codeComplete15.png]]
    - 클래스의 공개 메서드는 데이터가 안전하지 않다고 가정하고 데이터를 검사하고 깨끗하게 만들어야 한다
    - ***데이터를 입력할 때 적절한 타입으로 변환한다***
- 방어 시설과 어설션 사이의 관계
    - 방어 시설을 사용하면 어설션과 오류 처리를 확실하게 구별할 수 있다
    - 방어 시설 외부 루틴은 데이터에 대해 확실하게 가정할 수 없기 때문에 오류 처리를 사용해야한다
    - 방어 시설 내부의 루틴은 어설션을 사용해야한다. 루틴에 전달되는 데이터가 살균되고 나서 방어 시설을 지나 전달되기 때문. 방어 시설 내부의 루틴 중 하나가 잘못된 데이터를 감지한다면 이는 데이터의 오류라기보단 프로그램상의 오류

## 8.6 디버깅 보조 도구

- 제품의 제약 사항을 개발 버전에 무의식적으로 적용하지 않는다
    - 개발자의 공통된 맹점은 배포한 소프트웨어의 제한 사항이 개발 버전에 적용된다고 가정하는 것
        - 배포 버전은 자원을 아끼고, 빨라야하고, 위험한 연산이 사용자에게 노출되면 안되지만 개발 버전은 반대이다
    - 개발 중에 개발을 좀 더 원활히 진행하도록 도와주는 도구를 사용하는 데 속도와 자원을 양보해야한다
- 디버깅 보조 도구를 초기에 도입한다
    - 디버깅 보조 도구를 초기에 사용하라
- 공격적인 프로그래밍 기법을 사용한다
    - 예외적인 경우는 개발 중에 눈에 띄어야하고, 배포되는 버전의 코드가 실행 중일 때는 복구 가능한 방법으로 처리해야한다 (***”공격적인 프로그래밍”)***
    - 공격적인 프로그래밍 기법을 작성하는 방법
        - assert가 프로그램을 중단하게 한다. 개발자가 알려진 문제를 무시하기 위해 엔터키를 누르는 습관을 갖지 않게 한다. 고칠 수 밖에 없도록 골치 아픈 문제를 만든다
        - 메모리 할당 오류를 발견할 수 있게 할당된 모든 메모리를 완벽하게 채운다
        - 파일 형식과 관련된 오류를 발견하기 위해 할당된 파일이나 스트림을 완벽하게 채운다
        - 객체를 삭제하기 전에 쓰레기 데이터로 채운다
        - 개발하고 있는 소프트웨어가 적합하다면 배포된 소프트웨어에서 어떤 오류가 발생하고 있는지를 확인할 수 있게 오류 로그 파일을 이메일로 보내도록 프로그램을 설정한다
    - ***개발 중에 가혹하게 실패해서 제품에서는 좀 더 가볍게 실패할 수 있게 한다***
- 디버깅 보조 도구를 제거하는 계획을 세운다
    - ***버전 관리 도구와 ant나 make 같은 빌드 도구를 사용한다***
        - 디버그 코드를 제외한 설정을 탐은 빌드 도구 사용
    - ***기본 제공되는 전처리기를 사용한다***
        - 프로그래밍 언어가 전처리기를 제공한다면 컴파일러 옵션을 변경해 디버그 코드를 포함하거나 제외할 수 있다
    - ***자신만의 전처리기를 작성한다***
        - 프로그래밍 언어가 전처리기를 포함하고 있지 않더라도 상당히 쉽게 디버그 코드를 포함하거나 제외하기 위한 전처리기를 작성할 수 있다
        - 디버그 코드를 나타내기 위한 규약을 구축하고 규약을 따르는 선행 컴파일러를 작성한다
            - java의 //#BEGIN DEBUG 와 //#END DEBUG  키워드에 반응하는 전처리기를 작성할 수 있다
    - ***디버깅을 위한 루틴을 작성한다***
        - 이러한 접근 방법은 성능상 약간의 손해를 가져오지만, 자신만의 전처리기를 작성하는 것보다 빠른 해결방법이다

## 8.7 제품 코드를 얼마나 방어적으로 프로그래밍할 것인지 정하기

- 방어적 프로그래밍 지침
    - ***중요한 오류를 검사하는 코드는 남겨두라***
        - 프로그램의 어느 부분이 발견되지 않은 오류를 갖고 있어도 되는지 결정하라
    - ***사소한 오류를 검사하는 코드를 제거하라***
        - 오류가 정말로 사소하게 영향을 미친다면 그러한 오류를 검사하는 코드는 제거한다
    - ***심각한 충돌을 발생시키는 코드는 제거하라***
        - 사용자는 디버깅과 제품의 품질 향상에 얼마나 도움이 되는지에 상관없이 자신이 작업했던 내용을 잃는 것을 달가워하지 않는다
        - 프로그램이 데이터 손실을 일으킬 수 있는 디버깅 코드를 포함하고 있다면 그러한 코드를 제품 코드에서 제거한다
    - ***프로그램이 우아하게 충돌하도록 돕는 코드를 남겨두라***
        - 프로그램의 치명적인 오류를 감지하는 디버깅 코드를 포함하고 있다면 프로그램이 종료되기 전에 수행해야 하는 다른 추가 작업을 모두 처리한 후 종료할 수 있도록 그 코드를 남겨둔다
    - ***기술 지원을 위해서 오류를 기록한다***
        - 제품 코드에 디버깅 보조 도구를 남기되, 작동 방식을 변경하지 않는 방법을 고려해본다
        - 개발 시에 프로그램을 중지시키는 어설션을 코드에 포함시켰다면 해당 어설션 루틴을 완전히 제거하기보다는 메시지를 파일에 기록할 수 있도록 변경하는 것을 고려해볼 수 있다
    - ***오류 메시지가 친절한지 확인한다***
        - 프로그램에 내부적인 오류 메시지를 남겨둔다면 사용자에게 친숙한 언어로 작성되었는지 검증한다

## 8.8 방어적 프로그래밍에 대해 한 번 더 고민하기

![[codeComplete16.png]]
![[codeComplete17.png]]
# 9장 의사코드 프로그래밍 프로세스

>[!important]
>💡 PPP : Pseudocode Programming Process

## 9.1 클래스 및 루틴 개발 단계 요약

- 클래스 생성 단계
    ![[codeComplete18.png]]
   
- ***클래스에 대한 일반적인 설계를 작성한다***
	- 클래스의 구체적인 책임을 정의하고 클래스가 숨길 “비밀”이 무엇인지 정의하고, 클래스 인터페이스가 추구할 추상화가 무엇인지 정확하게 정의
	- 클래스가 다른 클래스로부터 파생될 것인지, 다른 클래스가 상속받을 수 있도록 허락할 것인지를 결정
	- 클래스의 핵심적인 공개 메서드를 식별하고 클래스에서 사용할 중요한 데이터 멤버를 식별하고 설계
    - 클래스 내에 각 루틴을 구현한다
        - 각 루틴을 구현하게 되면 추가로 다른 루틴이 필요하다는 것을 알게 되며 추가적인 루틴을 작성하면서 발생하는 문제가 전체적인 클래스에 영향을 미치기도 한다
    - 클래스를 전체적으로 검토하고 테스트한다
        - 일반적으로 각 루틴은 작성하면서 테스트한다
        - 클래스를 전체적으로 사용할 수 있게 되면 개별적인 루틴 수준에서 테스트할 수 없었던 문제에 대해 검토하고 테스트 해야한다
- 루틴을 작성하는 단계
	![[codeComplete19.png]]

## 9.2 전문가를 위한 의사코드

- 의사코드
    - 정의
        - 알고리즘이나 루틴, 클래스, 프로그램이 어떻게 작동할지를 기술하는 자연어 문장과 같은 비형식적인 표기법
    - 의사코드 프로그래밍 프로세스
        - 루틴의 코드를 능률적으로 작성하기 위해서 의사코드를 사용하는 특수한 접근 방법
    - 의사코드를 효과적으로 사용하기 위한 지침
        - 구체적인 연산을 정확하게 기술하기 위해 자연어 문장과 같은 형태의 명령문을 사용한다
        - 특정 프로그래밍 언어의 문법적인 요소를 피한다. 의사코드는 코드 자체보다 좀 더 높은 수준에서 설계할 수 있다. 프로그래밍 언어에서 제공하는 기능으로 표현하면 좀 더 세부적인 내용을 다루게 되어 높은 수준에서 설계할 때 얻는 장점을 잃게 될 뿐만 아니라 불필요하게 해당 프로그래밍 언어의 문법에 제약을 받게 된다
        - 목적에 좀 더 초점을 맞춘다. 특정 프로그래밍 언어에서 해당 접근법을 어떻게 구현할 것인지가 아니라 그 방법을 사용하는 목적을 설명한다
        - 코드를 거의 자동으로 생성할 수 있을 정도로 의사코드를 작성한다. 의사코드가 너무 높은 수준에 있으면 코드 작성 시 문제가 될 수 있는 세부 사항을 무시할 수 있다. 코드를 쉽게 작성할 수 있을때까지 더 자세히 의사코드를 개선한다
    - 좋은 의사코드 예시
        
        ```
        /*
        	언어 선택을 제한하지 않았음
        	목적을 분명히 한다
        */
        Keep track of current number of resources in use
        If another resource is available
        	Allocate a dialog box structure
        	If a dialog box structure could be allocated
        		Note that on more resource is in use
        		Initialize the resource
        		Store the resource number at the location provided by the caller
        	Endif
        Endif
        Return true if a new resource was created; else return false
        ```
        
    - 좋은 의사코드 방식을 사용했을 때 얻을 수 있는 장점
        - 검토가 수월해진다. 소스 코드를 보지 않고 상세한 설계를 검토할 수 있다. 의사코드로 인해 낮은 수준의 설계 검토가 쉬워 코드 자체를 검토할 필요가 줄어든다
        - 반복적인 개선을 지원한다. 높은 수준에서 설계를 시작한 후 그 설계를 의사코드로 변경하고 의사코드를 다시 소스코드로 바꾼다. 이렇게 작은 단위로 연속해서 개선하면 세부적인 사항을 낮은 수준으로 구현할 때 설계를 점검할 수 있다. 그 결과 상위 수준에서는 상위 수준의 오류, 중산 수준에서는 장군 수준의 오류, 하위 수준에서는 하위 수준의 오류를 처리함으로써 더 낮은 수준에서 문제가 되거나 악영향을 끼치기 전에 오류를 잡을 수 있다
        - 변경하기 쉽다. 몇 줄의 의사코드는 코드 한 페이지보다 변경하기 쉽다. 프로젝트를 성공적으로 수행하기 위한 핵심 요소 중 하나는 오류를 “최저 비용 단계”에서 잡는 것이다
        - 주석 작업을 최소화환다.
        - 다른 어떤 형태의 설계 문서보다 유지보수하기 쉽다. PPP를 사용하면 의사코드 문장이 코드 안에서 주석이 된다

## 9.3 PPP를 이용한 루틴 구현

- 루틴을 설계한다
    - ***선행 조건을 검사한다***
        - 루틴 자체에 대한 작업을 수행하기 전 루틴이 해야 할 일이 잘 정의되었고 전체적인 설계에 잘 어울리는 지 검사
        - 루틴을 프로젝트의 요구사항에 맞게 호출하는지도 다시 한번 확인한다
    - ***루틴이 해결할 문제를 정의한다***
        - 설계에서 포함해야하는 정보
            - 루틴이 숨길 정보
            - 루틴에 대한 입력
            - 루틴의 출력
            - 루틴이 호출되기 전에 True이어야 하는 선행 조건들(특정 범위 내에 있는 입력 값, 초기화된 스트림, 열리거나 닫힌 파일, 채워지거나 내보내진 버퍼 등)
            - 호출한 곳으로 반환하기 전 루틴이 True임을 보장하는 후행 조건들(지정된 범위 내에 있는 출력 값, 초기화된 스트림, 열리거나 닫힌 파일, 채워지거나 내보내진 버퍼 등)
    - ***루틴의 이름을 짓는다***
        - 분명하고 모호하지 않은 이름을 가져야 한다
    - ***루틴을 어떻게 테스트할 것인지 결정하낟***
        - 루틴을 작성할 때 어떻게 테스트할 것인지 생각하라
        - 단위 테스트를 수행할 때나 별도로 루틴을 테스트하는 사람에게 도움이 된다
    - ***표준 라이브러리에서 사용할 수 있는 기능을 조사한다***
        - **코드의 품질과 생산성 모두를 향상시킬 수 있는 최고의 방법은 좋은 코드를 재사용하는 것**
        - 회사에서 관리하는 라이브러리 코드에서 제공하는지 확인한다
    - ***오류 처리에 대해 생각한다***
        - 루틴에서 잘못될 수 있는 모든 경우에 대해 고려한다
        - 잘못된 입력이나 다른 루틴에서 반환된 유효하지 않은 값 등에 대해 생각한다
    - ***효율성에 대해 생각한다***
        - 대다수 시스템에 해당하는 첫 번째 상황에서는 효율성이 그렇게 중요하지 않다
            - 나중에 필요할 때 루틴을 개선할 수 있을 정도로 루틴의 인터페이스의 추상화가 잘 되어 있는지, 루틴의 코드가 이해하기 쉬운지 확인
            - 캡슐화가 잘 되어 있다면 느리고 자원을 많이 낭비하는 고급 언어로 구현된 코드를 좀 더 빠른 알고리즘이나 빠르면서 간결한 저수준 언어로 구현한 코드로 대체할 수 있고 다른 루틴은 건드리지 말아야한다
        - 소수의 시스템에 해당하는 것으로 성능이 중요한 경우
            - 아키텍처는 각 루틴에서 얼마나 많은 자원을 사용할 수 있고, 연산을 얼마나 빨리 수행해야 하는지 명시해야함
            - 루틴이 자원과 속도의 목표를 달성할 수 있도록 설계한다
            - 자원이나 속도 중 어느 하나가 더 중요하다면 속도를 위해 자원을 포기하거나 그 반대가 되도록 설계한다
        - **위의 두 가지 방법을 제외하면 일반적으로 개별적인 루틴 수준에서 효율성을 고려한느 것은 시간 낭비다**
    - ***알고리즘과 데이터형을 조사한다***
        - 복잡한 코드를 처음부터 작성하기 전에 알고리즘 책을 뒤져 이미 사용 가능한 것이 있는지 확인하자
        - 미리 구현된 알고리즘을 사용하는 경우에는 프로그래밍 언어에 맞게 고쳐서 작성하자
    - ***의사코드를 작성한다***
        - 의사코드를 작성하는 이유는 실제로 루틴을 작성할 때 도움이 되도록 전체적인 흐름을 미리 정하는 것에 있다
        - 프로그래밍 편집기나 통합 개발 환경으로 의사코드 작성하자
        - 일반적인 것부터 시작해서 구체적인 것으로 작업을 진행
        - 작성 순서
            1. 루틴의 목적을 간결하게 한 문장으로 작성한다
                1. 예시
                    1. 이 루틴은 호출 루틴에서 제공하는 오류 코드에 따라 오류 메시지를 출력한다
                    2. 이 루틴이 메시지를 출력하는 방법은 현재 처리 중인 상태에 따라 달라진다
                    3. 이 루틴은 성공이나 실패를 가리키는 값을 반환한다
            2. 해당 루틴에 대한 의사코드 작성
                2. 예시
                    4. 이 루틴은 호출 루틴에서 제공하는 오류 코드에 따라 오류 메시지를 출력한다
                    5. 이 루틴이 메시지를 출력하는 방법은 현재 처리 중인 상태에 따라 달라진다
                    6. 이 루틴은 성공이나 실패를 가리키는 값을 반환한다
                    7. 기본 상태를 “실패”로 설정한다
                    오류 코드에 대한 메시지를 검색한다
                    8. 만약 오류 코드가 유효하다면
                        1. 만약 대화식 방식이라면, 오류 메시지를 대화식으로 보여주고 성공을 선언한다
                        2. 만약 명령줄 방식이라면, 오류 메시지를 명령줄에 기록하고 성공을 선언한다
                    9. 만약 오류가 유효하지 않다면, 사용자에게 내부 오류가 발견되었다고 알린다
                    10. 상태 정보를 반환한다
    - ***데이터에 대해 생각한다***
        - 데이터 관리가 중요하다면 논리적인 구조보다 데이터를 먼저 고민하는 것이 좋을 수도 있다
        - 핵심적인 데이터형을 정의하면 루틴의 논리적인 구조를 설계할 때 유용
    - ***의사코드를 검사한다***
        - 의사코드를 작성하고 데이터르 설계했다면 작성한 의사코드를 몇 분 도안 검토해본다
        - 다른 사람에게 코들르 검토해 달라고 부탁하거나 설명을 들어달라고 부탁한다
    - ***의사코드에서 몇 가지 아이디어를 내보고 가장 좋은 방법을 선택한다(반복)***
        - 코드 작성 시작 전에 의사코드에서 가능한 한 많은 아이디어를 시도해 본다
    - 기본 개념은 의사코드의 각 문장 아래에 코드를 추가하고 원래 의사코드를 문서로서 남겨둘 수 있을 만큼 간단해질 때까지 의사코드 안의 루틴을 반복하는 것
    - 처음으로 작성한 의사코드의 일부는 더 작게 분해할 필요가 있을 정도로 높은 수준일 경우 추가로 의사코드를 분해해야한다
    - 코드를 어떻게 작성해야 할 지 확신이 들지 않는다면 확신이 들 때까지 의사코드를 계속 작성한다
- 루틴을 구현한다
    ![[codeComplete20.png]]
    
    - ***루틴의 선언부를 작성한다***
        
        ```
        /* 이 루틴은 호출 루틴에서 제공하는 오류 코드에 따라 오류 메시지를 출력한다
           이 루틴이 메시지를 출력하는 방법은 현재 처리 중인 상태에 따라 달라진다
           이 루틴은 성공이나 실패를 가리키는 값을 반환한다
        */
        
        Status ReportErrorMessage ( ErrorCode errorToReport)
        
        기본 상태를 “실패”로 설정한다
        오류 코드에 대한 메시지를 검색한다
        만약 오류 코드가 유효하다면
            만약 대화식 방식이라면, 오류 메시지를 대화식으로 보여주고 성공을 선언한다
            만약 명령줄 방식이라면, 오류 메시지를 명령줄에 기록하고 성공을 선언한다
        만약 오류가 유효하지 않다면, 사용자에게 내부 오류가 발견되었다고 알린다
        상태 정보를 반환한다
        ```
        
    - ***의사코드를 고수준의 주석으로 변환한다***
        
        ```
        /* 이 루틴은 호출 루틴에서 제공하는 오류 코드에 따라 오류 메시지를 출력한다
           이 루틴이 메시지를 출력하는 방법은 현재 처리 중인 상태에 따라 달라진다
           이 루틴은 성공이나 실패를 가리키는 값을 반환한다
        */
        
        Status ReportErrorMessage ( ErrorCode errorToReport)
        
        /* 기본 상태를 “실패”로 설정한다
        오류 코드에 대한 메시지를 검색한다
        만약 오류 코드가 유효하다면
            만약 대화식 방식이라면, 오류 메시지를 대화식으로 보여주고 성공을 선언한다
            만약 명령줄 방식이라면, 오류 메시지를 명령줄에 기록하고 성공을 선언한다
        만약 오류가 유효하지 않다면, 사용자에게 내부 오류가 발견되었다고 알린다
        상태 정보를 반환한다
        */
        ```
        
    - ***각 주석 아래에 코드를 채운다***
        
        ```
        /* 이 루틴은 호출 루틴에서 제공하는 오류 코드에 따라 오류 메시지를 출력한다
           이 루틴이 메시지를 출력하는 방법은 현재 처리 중인 상태에 따라 달라진다
           이 루틴은 성공이나 실패를 가리키는 값을 반환한다
        */
        
        Status ReportErrorMessage ( ErrorCode errorToReport) {
        		// 기본 상태를 “실패”로 설정한다
        		Status errorMessageStatus = Status_Failure;
        		// 해당 오류 코드에 대한 메시지를 검색한다
        		Meesage errorMessage = LookupErrorMessage(errorToReport);
        	/*
        	만약 오류 코드가 유효하다면
        	...(코드 삽입)
        	    만약 대화식 방식이라면, 오류 메시지를 대화식으로 보여주고 성공을 선언한다
        	    만약 명령줄 방식이라면, 오류 메시지를 명령줄에 기록하고 성공을 선언한다
        	만약 오류가 유효하지 않다면, 사용자에게 내부 오류가 발견되었다고 알린다
        	상태 정보를 반환한다
        	*/
        }
        ```
        
    - ***코드를 더 나눠야 하는지 검사한다***
        - 주석 아래에 있는 코드를 새로운 루틴으로 나눈다. 의사코드 한 줄이 예상했던 것보다 많은 코드로 확장되었다면 해당 코드를 별도의 루틴으로 나눌 수 있다. 해당 루틴을 호출하는 코드를 작성한다. PPP를 제대로 사용했다면 새로운 루틴의 이름을 의사코드로부터 쉽게 유추할 수 있어야 한다. 원래 작성하고 있던 루틴을 완성하고 나면 새로운 루틴으로 이동해서 해당 루틴에 대한 PPP를 다시 적용할 수 있다
        - PPP를 재귀적으로 적용한다. 의사코드 한 줄 아래에 20줄이 넘는 코드를 작성하는 대신 원래 있던 의사코드를 여러 줄의 의사코드로 분해하는 시간을 갖는다. 그 후 새로 작성한 의사코드 아래에 코드를 채워 넣는다
- 코드를 검사한다
    - 구현한 코드가 정확한지 확인하기 위한 코드 검사 수행
    - ***머릿속에서 루틴의 오류를 검사한다***
        - 루틴에 대한 첫 번째 형식적인 검사는 머릿속으로 한다
        - 클린업 검사 단계, 비형식적 검사 단계 수행
        - 각 경로를 머릿속으로 실행 → 이를 실행하기 어렵기 때문에 루틴을 작게 유지해야한다
        - 정상적인 경로, 종결점, 모든 예외 조건을 검사하고 있는지 확인
        - 이 작업을 혼자 수행한 후 한 명 이상의 동료와 함께 수행한다
        - **작동하는 루틴만으로는 충분하지 않다. 왜 작동하는지를 모른다면 알 때까지 연구하고 토론하고 다른 설계로 실험해본다**
    - ***루틴을 컴파일한다***
        - 루틴 검토 후 루틴을 컴파일
        - 컴파일을 늦춤으로써 얻을 수 있는 이득
            - 개발과 컴파일을 반복하는 사이클에 빠지지 않도록 해줌
        - 루틴을 컴파일해서 최대한 많은 정보를 얻기 위한 지침
            - 컴파일러의 경고 수준을 가장 높은 수준으로 설정한다. 컴파일러가 포착하기 힘든 오류를 발견할 수 있도록 설정함으로써 수많은 오류를 잡을 수 있다
            - validator를 사용한다 ex) lint
            - 모든 오류 메시지와 경고의 원인을 제거한다.
            - 모든 경고를 이해하기 위해 노력하라
    - ***코드를 디버거에서 한 단계씩 살펴본다***
        - 루틴을 컴파일하고 나면 디버거에 입력해 각 줄을 한 단계씩 살펴본다
        - 각 줄의 코드가 예상대로 실행되는지 확인한다
    - ***코드를 테스트한다***
        - 테스트 케이스를 통해 코드를 테스트한다
    - ***루틴에 있는 오류를 제거한다***
        - 오류가 발견되었다면 오류를 제거해야 한다
        - 루틴에 유달리 버그가 많다면 처음부터 다시 작성한다
- 나머지를 정리한다
    - 정리작업
        - 루틴의 인터페이스를 검사한다. 모든 입력과 출력 데이터를 확인하고 모든 매개변수가 사용됐는지 확인한다
        - 일반적인 설계 품질을 검사한다. 루틴이 한 가지 일만 하고 그 일을 잘 처리하는지 확인하고 다른 루틴과 느슨하게 결합되어 있으며 방어적으로 설계되었는지 확인한다
        - 루틴의 변수를 검사한다. 부정확한 변수의 이름이나 사용되지 않는 객체, 선언되지 않은 변수, 부적절하게 초기화된 객체 등을 검사한다
        - 루틴의 명령문과 논리적인 구조를 검사한다. 하나 차이로 인한 오류, 무한 루프, 적절하지 않은 중첩, 자원 누수 등을 검사한다
        - 루틴의 레이아웃을 검사한다. 루틴과 표현식, 매개변수 목록의 논리적인 구조가 명확하도록 공백을 사용했는지 확인한다
        - 루틴의 문서화를 검사한다. 주석으로 변환되는 의사코드가 여전히 정확한지 확인한다. 알고리즘 설명, 인터페이스와 불명확한 의존성에 대한 문서, 불분명한 코드 작성 습관의 정당성을 검사한다
        - 불필요한 주석을 제거한다. 때때로 의사코드 주석이 코드와 중복되는 경우가 있다. 특히 PPP를 재귀적으로 적용해서 잘 명명된 루틴에 대한 호출 바로 앞에 주석이 있는 경우가 그렇다
- 필요한 만큼 반복한다
    - 루틴의 품질이 좋지 않다면 의사코드 단계로 돌아간다
    - 고급 프로그래밍은 반복적인 프로세스이니 주저하지 말고 구현 작업을 다시 반복하라

## 9.4 PPP대안

- 대안
    - ***TDD***
        - 코드를 작성하기 전 테스트 케이스를 먼저 작성하는 개발방법
    - ***리팩터링***
        - 의미를 유지하는 일련의 변환 과정을 통해 코드를 향상 시키는 개발 방법
    - ***계약에 의한 설계***
        - 각 루틴이 선행 조건과 후행 조건을 갖고 있다고 생각하는 개발 방법
        - \<Object-Oriented Software Construction> - 책

	![[codeComplete21.png]]





