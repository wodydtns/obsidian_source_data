# 31장 레이아웃과 스타일

## 31.1 레이아웃 기초 지식

- 극단적인 레이아웃
	- 코드와 주석은 완전히 같다
	- 공백은 사람에게만 유용하다
- 형식화 기본 법칙
	- 코드를 보기 좋게 작성하는 것도 중요하지만, 코드의 구조를 보여주는 것이 더 중요하다
	- 구조를 더 잘 보여주는 기법과 외관상 보기 좋게 만드는 기법이 있다면 구조를 더 잘 보여주는 기법을 선택해야 한다
- 프로그램에 대한 사람과 컴퓨터의 해석
	- 컴퓨터는 오로지 괄호나 시작과 끝에 신경 쓰는 반면, 사람은 코드의 외견상 표현으로부터 단서를 얻어내는 경향이 있다
	- 예시
```
// 사람은 (3+4) * (2+7)
// 컴퓨터는 공백을 무시하고 우선순위 규칙에 따라 3 + (4*2) + 7
x = 3+4 * 2+7;
```
- ***좋은 레이아웃 스키마는 프로그램의 외견상 구조와 논리적 구조를 일치시키거나 사람과 컴퓨터가 코드를 똑같은 내용으로 이해할 수 있게 해주는 것***
- 좋은 레이아웃은 얼마나 가치가 있는가?
	- 레이아웃에서는 컴퓨터와의 의사소통과 사람과의 의사소통 차이가 중요하다
	- 프로그래밍 작업에서 컴퓨터가 읽을 수 있도록 프로그램을 작성하는 것은 작은 부분을 차지하고 다른 사람들이 읽을 수 있도록 프로그램을 작성하는 것은 큰 부분을 차지한다
	- ***프로그램을 일관된 형태로 구조화하는 것이 프로그램을 구조화하는 구체적 방법보다 훨씬 중요하다***
- 종교로서의 레이아웃
	- 훌륭한 개발자는 자신의 레이아웃 습관에 대한 편견이 없으며 적응하는 데 다소 어려움이 있더라도 더 좋은 습관이 있다면 그러한 습관을 받아들일 수 있어야 한다
- 좋은 레이아웃의 목표
	- 레이아웃 세부 사항에 관한 많은 결정은 주관적인 미학에 관한 문제
	- ***코드의 논리 구조를 정확하게 표현한다***
		- 형식화의 기본 정리
	- ***코드의 논리 구조를 일관되게 표현한다***
		- 어떤 레이아웃 스타일은 예외 사항이 너무 많아 일관되게 규칙을 따르기가 어렵다. 좋은 스타일을 대부분의 경우에 적용한다
	- ***가독성을 향상시킨다***
		- 좋은 레이아웃 스키마는 코드를 읽기 쉽게 만든다
	- ***변경 사항에 대한 내성을 지닌다***
		- 가장 훌륭한 레이아웃 스키마는 코드 변경을 잘 견딘다
	- ***레이아웃 목표를 사용하기 위한 방법***
		- 좋은 레이아웃 스키마를 위한 기준을 토론의 근거로 삼아 다른 스타일보다 어떤 스타일을 선호하는 주관적인 이유를 공개적으로 표명
## 31.2 레이아웃 기법
- 공백
	- ***공백을 사용해 가독성을 높여라***
	- ***그룹화***
		- 공백은 관련된 명령문이 서로 그룹화되어 있다는 것을 알려주는 것
	- ***빈 줄***
		- 관련된 명령문을 그룹화하는 것이 중요한 것처럼 관련 없는 명령문을 구분하는 것도 중요
	- ***들여쓰기***
		- 들여쓰기를 사용해 프로그램의 논리적인 구조를 보여줘라
	- 괄호
	- **필요하다고 생각하는 것보다 훨씬 많은 괄호를 사용하라**
## 31.3 레이아웃 스타일

- 순수 블록
    ![[codeComplete74.png]]
- 순수 블록 흉내 내기
	- 예시

```cpp

if ( pixelColor == Color_Red) {
	statement1;
	statement2;
}

```

```cpp

switch (pixcelColor ) {
	case Color_Red;
			statement1;
			statement2;
			...
	break;
	case Color_Green;
			statement1;
			statement2;
			...
	break;
	default:
		statement1;
		statement;
		...
	break;
}

```

- 블록 경계를 나타내는 begin-end 쌍(중괄호) 사용
	- 예시

```cpp

if ( pixelColor == Color_Red )
	{
	statement1;
	statement2;
	...
	}

```
- 줄 끝 레이아웃
	- 코드가 줄의 중간이나 끝에 들여쓰기 되는 레이아웃 전략
	- 예시

```cpp

While ( pixcelColor = Color_Red)
		statement1;
		statement2;
		...
		wend

```

- **조건 표현식이 복잡해질수록 논리적인 구조에 대해 쓸모 없거나 잘못된 단서를 제공한다**
- 예시

```cpp

		If (soldCount > 10 And prevMonthSales > 10 ) Then

			If (soldCount > 10 And prevMonthSales > 10 ) Then  

					If ( soldCount > 1000 ) Then
						markdouwn = 0.1
						profit = 0.05
					Else
						markdown = 0.05
					End If
						Else
							markdown = 0.025
					End If
						Else
							markdown = 0.025
					End If
```
	
- 어떤 스타일이 가장 좋은가
	- 비주얼 베이직을 사용하고 있다면 순수 블록 들여쓰기
	- 자바의 표준 방법은 순수 블록 들여쓰기
	- C++ 에서는 좋아하는 스타일을 선택하거나 팀원의 다수가 선호하는 스타일을 선택
## 31.4 제어 구조 레이아웃

- 제어 구조 블록의 형식화에 대한 세세한 부분들
	- ***들여쓰기 되지 않은 begin-end 쌍을 피하라***

```cpp
for ( int i=0; i <MAX_LINES;i++)
{

	ReadLine(i);
	ProcessLine(i);
}
```

- ***begin과 end에서 이중 들여쓰기를 피하라***
- 잘못된 예시

```java
for ( int i=0; i <MAX_LINES;i++)
	{
		ReadLine(i);
		ProcessLine(i);
	}
```

- 기타 고려 사항

	- ***단락 사이에 빈 줄을 사용하라***

```cpp

window.dimensions = editWindow.dimensions;
window.title = editWindow.title;
window.backgroundColor = userPreferences.backgroundColor;
window.foregroundColor = userPreferences.foregroundColor;
cursor.start = startingScanLine;
cursor.end = endingScanLne;
cursor.blinkRate = editMode.blinkRate;
SaveCursor( cursor );
SetCursor( cursor );

```

- ***단일 명령문 블록을 일관성 있게 형식화하라***
	- 예시

```cpp

if (expression)
	one-statement;
if (expression) {
	one-statement;
}
if (expression)
	{
	one-statement;
	}
if (expression)     one-statement;

```
- ***복잡한 표현식인 경우에는 독립적인 조건을 별도의 줄에 입력하라***
	- 예시
```java

if ( ( ( '0' <= inChar ) && ( inChar <= '9' ) ) ||
( ( 'a' <= inChar ) && ( inChar <= 'z' ) ) ||
( ( 'A' <= inChar ) && ( inChar <= 'Z' ) ) ||

```

- ***goto를 피하라***
	- goto를 형식화하는 방법
		- goto를 피한다. 이것이 형식화 문제를 피하는 방법이다
		- 코드가 이동해야 하는 레이블을 대문자로 입력한다. 이렇게 하면 레이블이 분명해진다
		- goto를 포함하는 명령문을 한 줄에 입력한다. 이렇게 하면 goto문이 분명해진다
		- goto가 이동하는 레이블을 한 줄에 입력하고 명령문 주위에 빈 줄을 추가한다. 이렇게 하면 해당 레이블이  분명해진다. 레이블을 포함하는 코드를 왼쪽 끝으로 정렬하면 레이블이 훨씬 더 분명해진다

- ***case 문에 대한 줄 끝 예외를 두지 말라***
	- 예시

```java

swtich ( ballColor ) {

	case BallColor_Blue:
		Rollout();
		break;
	case BallColor_Orange:
		SpinOnFinger();
		break;
	case BallColor_FluorescentGreen:
		Spike();
		break;
	case BallColor_White:
		KnckCoverOff();
		break;
	case BallColor_WhiteAndBlue:
		if( mainColor == BallColor_White ) {
			KnockCoverOff();    
		}
		else if ( mainColor == BallColor_Blue ) {
			RollOut();
		}
		break;
	default:
		FatalError( "Unrecognized kind of ball. " ) ;
		break;
}

```
## 31.5 개별 명령문 레이아웃
- 명령문 길이
	- 80자를 넘는 줄은 읽기가 어렵다
	- 80자로 길이를 제한하면 깊은 중첩을 막을 수 있다
	- 80자를 넘는 줄을 보통 8.5 X 11 용지에 들어맞지 않는다. 특히 용지 한 장에 두 페이지의 코드를 출력할 때는 더욱 그렇다
	- 명료함을 위한 공백 사용

- ***논리적인 표현식을 읽기 쉽게 만들기 위해서 공백을 사용하라***
	- 예시

```java

while ( pathName[ startPath+position ] <> ';' ) and
		(( startPath + position) < length( pathName )) do

```

```java

while ( pathName[ startPath+position ] <> ';' ) and
		( ( startPath + position) < length( pathName ) ) do

```

- ***배열 참조를 읽기 쉽도록 공백을 사용하라***

```java

grossRate[ census[ groupId ].gender, census[ groupId ].ageGroup ]

```

- ***루틴의 인자를 읽기 쉽도록 공백을 사용하라***

```java

GetCensus( inputFile, empCount, empData, maxEmps, inputError );

```
- 연속된 줄 형식화하기
	- ***불완전한 명령문을 명학하게 만들어라***
		- 복잡한 연산을 분명히 해주는 스타일

```java

totalBill = totalBill
+ customerPurchases [ customerID ]
+ CitySalesTax( customerPurchases[ customerID ] )
+ StateSalesTax( customerPurchases[ customerID ] )
+ FootballStadiumTax()
- SalesTaxExemption( customerPurchases[ customerID ] )

```
- ***관련이 있는 요소를 가까운 위치에 둬라***
	- 줄을 잘 나눈 예시
```java

customerBill = PreviousBalance( paymentHistory[ customerId ] ) +
LateCharge( paymentHistory[ customerId  ] );

```

- ***여러 줄로 나뉜 함수 호출은 보통만큼 들여쓰기하라***

```java

DrawLine( window.north, window.south, window.east, window.west ,
					currentWidth, currentAttribute );
SetFontAttributes( faceName [ fontId ], size[ fontId ], bold[ fontId ],
									italic[ fontId ], syntheticAttribute[ fontId ].underline, syntheticAttribute[ fontId ].strikeout );
```
- ***연장된 줄의 끝을 찾기 쉽게 만들어라***
```cpp

DrawLine (
	window.north,
	window.south,
	window.east,
	window.west
	currentWidth,
	currentAttribute

)

SetFontAttributes (
	faceName[ fontId ],
	size[ fontId ],
	bold[ fontId ],
	italic[ fontId ],
	syntheticAttribute[ fontId ].underline,
	syntheticAttribute[ fontId ].strikeout
)

```

- ***여러 줄로 나뉜 제어 명령문은 보통만큼 들여쓰기하라***

```java

while ( ( pathName[ startPath + position ] != ';' ) &&
	( ( startPath + position ) <= pathName.length() ) ) {
	...

}

for( int employeeNum = employee.first + employee.offset;
	employeeNum < employee.first + employee.offset + employee.total;
	employeeNum++ ) {
	...

}

```

- ***할당문의 오른쪽으로 정렬하지 마라***
	- 좋지 않은 예제

```java

customPurchases = customPurchases + CustomerSales( CustomerID );
customerBill    = customerBill + customerPurchases;
totalCustomerBill = customerBill + PreviousBalance( CustomerID )+
										LateCharge( CustomerID);
customerRating = Rating( CustomerID, totalCustomerBill);

```

- 좋은 예제
```java

customPurchases = customPurchases + CustomerSales( CustomerID );
customerBill = customerBill + customerPurchases;
totalCustomerBill = customerBill + PreviousBalance( CustomerID )+
	LateCharge( CustomerID);
customerRating = Rating( CustomerID, totalCustomerBill);

```

- ***할당문의 연장된 줄을 표준 너미만큼 들여쓰기하라***
- 한 줄에 한 명령문만 사용하기
	- 한 줄에 한 명령문을 입력하면 프로그램의 복잡성을 정확하게 볼 수 있다. 복잡한 명령문은 복잡해 보여야하고, 간단한 명령문은 간단해 보여야한다
	- 한 줄에 여러 개의 명령문을 입력해도 최신 컴파일러에 최적화 단서를 제공하지 않는다. 최신 컴파일러의 최적화 기능은 형식화에서 그 단서를 찾지 않는다
	- 한 줄에 한 명령문을 입력하면 코드를 상하좌우로 읽는 대신 위아래로만 읽는다. 특정한 코드를 찾을 때 시선이 왼쪽 여백을 따라가야 한다. 한 줄에 두 개의 명령을 포함하고 있지는 않은지 모든 줄을 자세히 살펴볼 필요가 없다
	- 한 줄에 한 명령문을 입력하면 컴파일러가 오류가 발생한 줄 번호를 제공하는 것만으로도 문법 오류를 쉽게 찾을 수 있다. 한 줄에 여러 개의 명령문을 입력하면 줄 번호로 어떤 명령문에 오류가 있는지 알아낼 수 없다
	- 한 줄에 한 명령문을 입력하면 줄 단위 디버거에서 한 명령씩 살펴보기가 쉬워진다.한 줄에 여러 개의 명령문을 입력하면 디버거가 한 번에 모든 명령을 실행하기 때문에 한 명령씩 실행하기 위해 어셈블러 모드로 전환해야한다
	- 한 줄에 한 명령문을 입력하면 한 줄을 삭제하거나 일시적으로 코드를 주석으로 만드는 것과 같이 각 명령을 편집하기 쉬워진다

- 데이터 선언 레이아웃
	- 한 줄에 하나의 데이터 선언만 사용하라

```java

int rowIndex;
int columnIdx;
Color previousColor;

```

- ***처음으로 사용되는 위치와 가까운 곳에 변수를 선언하라***
	- 큰 블록에서 모든 변수를 선언할 때 바람직한 스타일은 변수가 처음 사용되는 위치와 가까운 곳에 변수를 선언하는 것이다
	- 이렇게 하면 변수의 범위와 수명을 줄일 수 있고 필요한 경우 좀 더 작은 루틴으로 코드를 리팩터링 할 수 있다
- ***분별력 있게 데이터 선언을 나열하라***
## 31.6 주석 레이아웃
- 주석 레이아웃
	- 주석이 설명하는 코드와 나란히 주석을 들여써라
        - 예시

```visual-basic

For transactionId = 1 To totalTransactions

` 거래 데이터를 구한다

GetTransactionType( transactionType )
GetRansactionAmount(  transactionAmount )
` 거래 터압에 따라 거래를 처리한다
If transactionType = Transaction_Sale Then
	AcceptCustomerSale( transactionAmount )
Else
	If transactionType = Transaction_CustomerReturn Then
		` 자동으로 처리하거나 필요한 경우 관리자 승인을 받는다
		If transactionAmount >= MANAGER_APPROVAL_LEVEL Then
			' 관리자 승인을 받고 승인 결과에 따라
			' 수락하거나 거절한다
			GetMgrApproval( isTransacitonApproved )
			If ( isTransacitonApproved ) Then
				AcceptCustomerReturn( transactionAmount )
			Else
				RejectCustomerReturn( transactionAmount )
			End If
		End If
End If
Next
```

- ***적어도 빈 줄 하나를 입력하고 주석을 시작하라***

```java

//comment zero
CodeStatmentZero;
CodeStatmentOne;

// comment one
CodeStatmentTwo;
CodeStatmentThree;

```

```java

//comment zero
CodeStatmentZero;
CodeStatmentOne;

// comment one
CodeStatmentTwo;
CodeStatmentThree;

```
## 31.7 루틴 레이아웃
- 루틴 레이아웃
	- ***빈 줄을 사용해 루틴의 각 부분을 구분하라***
		- 루틴 헤더와  데이터, 이름 상수 선언, 본문 사이에 빈 줄을 사용한다
	- ***루틴 인자에 대해 표준 들여쓰기를 사용하라***
		- 루틴 헤더에 줄 끝 레이아웃을 사용한 예제 - 너무 번거로움
```java

public boolean ReadEmployeeData(int maxEmployees,EmployeeList Employees,EmployeeFile inputFiles, int employeeCount,	boolean isInputError)

```

- 읽기 쉽고 유지보수가 가능한 표준 들여쓰기

```java

public boolean ReadEmployeeData(
	int maxEmployees,
	EmployeeList Employees,
	EmployeeFile inputFiles,
	int employeeCount,
	boolean isInputError
)

```
## 31.8 클래스 레이아웃
- 클래스 인터페이스 레이아웃
	- 클래스 멤버 작성 순서
		1. 클래스를 설명하고 클래스의 전체적인 사용법에 관한 내용을 제공하는 헤더 주석
		2. 생성자와 소멸자
		3. 공개 루틴
		4. 보호 루틴
		5. 비공개 루틴과 멤버 데이터

- 클래스 구현 레이아웃
	- 클래스 구현 배치 순서
		1. 클래스가 들어 있는 파일의 내용을 설명하는 헤더 주석
		2. 클래스 데이터
		3. 공개 루틴
		4. 보호 루틴
		5. 비공개 루틴
    - ***한 파일에 하나 이상의 클래스가 있다면 각 클래스를 명확하게 구별하라***
		![[codeComplete75.png]]
		![[codeComplete76.png]]
- 파일과 프로그램 레이아웃
	- ***한 클래스를 하나의 파일에 작성하라***
		- 사용하는 언어에서 허용한다면 하나의 목적을 위한 여러 루틴을 하나의 파일에 보관해야한다
		- 한 파일 내에 있는 모든 루틴은 클래스를 구성한다.
		- 클래스는 의미론적인 언어 개념이고 파일은 물리적인 운영체제 개념이다. 클래스와 파일 간의 유사성은 우연의 일치일 뿐이고 개발 환경이 db나 루틴, 클래스, 파일 사이의 관계를 불명확하게 만드는 다른 무언가에 코드를 작성하는 기능을 지원함에 따라 시간이 갈수록 점점 약해진다
- ***클래스 이름과 관련 있는 파일 이름을 작성하라***
	- 클래스 이름이 *CustomerAccount* 이면  파일 이름은 *CustomerAccount.cpp and CustomerAccount.h* 다

- ***파일 내에서 루틴을 명확하게 분리하라***
		![[codeComplete77.png]]
- ***루틴을 알파벳 순서로 나열하라***
## 체크리스트
- 체크리스트
	![[codeComplete78.png]]
	![[codeComplete79.png]]
# 32장 스스로를 설명하는 코드
## 32.1 외부 문서

- ***단위 개발 일지(Unit Development Folders)***
	- 개발자가 구현 중에 사용했던 기록이 담겨 있는 비공식적인 문서
	- 단위는 패키지나 컴포넌트를 의미할 수도 있지만, 일반적으로 하나의 클래스를 의미
	- UDF의 주 목적은 다른 곳에 문서화되어 있지 않은 설계 결정 사항에 대한 정보 제공
	- 프로젝트와 관련 있는 요구사항의 복사본, 해당 단위가 구현하는 상위 수준 설계의 일부, 개발 표준 복사본, 코드 목록, 단위 개발자의 설계 노트와 같은 최소한의 내용을 명시한 표준이 있음
	- 일반적으로 내부적으로만 사용
- ***상세 설계 문서***
	- 하위 수준 설계 문서
	- 클래스 수준 또는 루틴 수준의 설계 시 결정 사항과 고려했던 대안, 최종 접근 방법을 선택한 이유
## 32.2  문서화를 위한 프로그래밍 스타일

- 문서화를 위한 프로그래밍 스타일
	- 주석 없이 좋은 스타일만으로 문서화한 예시

```java

for ( primeCandidate = 2; primeCandidate <= num; primeCandidate++) {
	isPrime[ primeCandidate ] = true;

}

for ( int factor = 2; factor < ( num / 2); factor++ ) {
	int factorableNumber = factor + factor;
	while( factorableNumber  <= num ) {
		isPrime[ primeCandidate ] = false;
		factorableNumber = factorableNumber + factor;
	}

}

for ( primeCandidate = 1; primeCandidate <= num; primeCandidate++) {
	if ( isPrime[ primeCandidate ] ) {
		System.out.println( primeCandidate + " is prime." );
	}

}

```

- 체크리스트
	![[codeComplete93.png]]
    ![[codeComplete94.png]]
## 32.3 주석을 작성할 것인가? 작성하지 않을 것인가?
## 32.4 효과적인 주석을 위한 핵심 사항

>[!important] 💡 ***완성된 코드에 허용되는 세 가지 주석은 코드로 표현할 수 없는 정보, 의도 주석,요약 주석***



- 주석의 종류
	- 코드 반복
		- 장황한 주석은 코드가 하는 일을 말만 바꾸어 다시 말한다
    - 코드 설명
	- 설명적인 주석은 일반적으로 복잡하거나 교묘하거나 미묘한 코드를 설명하는 데 사용된다
	- 코드가 그렇다면 주석은 유용하지만, 일반적으로 코드가 혼란스럽기 때문이다. 코드의 설명이 필요하다면 주석을 추가하는 것보다 코드를 향상시키는 것이 대부분 더 낫다
    - 코드 표시 기능
	- 표시 주석은 코드에 남겨서는 안 되는 주석이다
	- 예시 : TODO
	- 코드 요약
		- 코드를 요약하는 주석은 그저 요약만 한다
		- 이런 주석은 코드를 읽는 사람이 코드를 더 빠르게 살펴볼 수 있어 단순히 코드를 반복하는 주석보다는 훨씬 가치가 있다
	- 코드의 의도를 설명
		- 코드의 목적을 설명한다
		- 예시
			- — 현재 직원 정보를 가져온다
	- 코드 자체로는 표현할 수 없는 정보
        - 코드로는 표현할 수 없지만, 반드시 소스코드에 포함시켜야 하는 정보가 있다
        - 저작권 설명, 기밀 사항, 버전 번호 등을 비롯한 다른 세부 사항이 포함된 문서
- 효율적인 주석 작성
	- 주석 작성에 시간이 걸리는 이유
        - 주석을 작성하는 스타일이 시간이 오래 걸리거나 장황한 경우
		- 새로운 스타일을 찾아 수행할 것
        - 프로그램이 무엇을 하는지 설명하기 위한 단어가 쉽게 떠오르지 않는 경우
		- 대개 개발자가 프로그램이 하는 일을 제대로 이해하지 못하는 신호
	- 주석을 효율적으로 작성하기 위한 가이드라인
        - ***변경하기 어렵지 않은 스타일을 사용하라***
		![[codeComplete82.png]]
	- ***주석 작성 시간을 줄이기 위해 의사코드 프로그래밍 프로세스를 사용하라***
		- 코드를 작성하기 전에 주석에 개략적으로 작성한다면 다양한 이득을 볼 수 있다
	- ***주석을 개발 스타일에 포함시켜라***
		- 의사코드를 사용해 생각을 명확하게 정리하면 코드 작성도 쉽고 주석은 자동으로 완성된다
	- ***성능 때문에 주석을 작성하지 않는다는 것은 핑계일 뿐이다***
- 가장 적당한 주석 수
	- 패커스 존스는 IBM의 연구에서 명령문 10개마다 주석을 하나 작성했을 때 이해도가 가장 높다는 것을 발견했다
	- 이보다 적으면 코드를 이해하기 어렵고, 많으면 코드에 대한 이해도를 떨어뜨렸다
## 32.5 주석 스타일

- 개별 줄에 주석 작성
- 주석을 작성해야 하는 경우
	- 해당 줄의 코드가 설명이 필요할 정도로 복잡하다
	- 해당 줄에서 오류가 발생한 적이 있어 기록하고 싶다
- 주석을 작성하는 경우의 가이드라인
	- ***제 멋대로인 주석은 피하라***
	- ***줄 끝 주석의 문제점***
            ![[codeComplete83.png]]
		- 코드의 시각적 구조를 방해하지 않으려면 오른쪽으로 정렬해야함 ⇒ 형식을 맞추기가 쉽지 않음
		- 줄 끝 주석은 관리하기 어려움
		- 줄 끝 주석은 모호한 경우가 많음 ⇒ 줄 끝 오른편에 공간이 많지 않아 주석을 한 줄에 넣으려면 주석이 짧아짐
	- ***한 줄짜리 줄 끝 주석을 피하라***
		- 코드 한 줄에 대한 의미 있는 주석을 작성하기가 어렵다
	- ***코드 여러 줄에 대한 줄 끝 주석을 피하라***
	- ***줄 끝 주석을 사용해야 할 때***
		- ***데이터 선언 주석을 작성하기 위해 줄 끝 주석을 사용하라***
```java

int boundary = 0; // 배열에서 정렬된 부분의 상위 인덱스
String insertVal = BLANK; // 정렬된 위치에 삽입하기 위한 데이터 elmt

```
- ***유지보수 기록을 위해서 줄 끝 주석을 사용하지 말라***

```java

// **사용하지 말자**
for i 1 to maxElmts . 1 -- 오류 수정 #A423 10/1/05 (scm)

```
- ***블록의 끝을 표시하기 위해서 줄 끝 주석을 사용하라***
- 코드 단락에 주석 작성
	- ***코드의 의도를 나타내기 위한 주석을 작성하라***
	- ***문서화에 들일 노력을 코드 작성에 들여라***
        - 예시

```java

// 명령어 종결자를 찾는다

foundTheTerminator = false;
commandStringLength = inputString.length();
testCharPosition = 0;

while( !foundTheTerminator && (testCharPosition < commandStringLength ) ) {
	if( inputString[ testCharPosition ] == COMMAND_WORD_TERMINATOR ) {
		foundTheTerminator = true;
		terminatorPosition = testCharPosition; // 이 변수가 검색 결과를 포함한다
	}else{
		testCharPosition =  testCharPosition  +  1;
	}
}

```
- ***단락 주석을 작성할 때 방법보다는 그 이유를 집중적으로 다루어라***
	- 이유에 대해 주석을 작성하고 훌륭한 스타일을 사용한 예제
```java

// 만약 새로운 계정을 만들고 있다면
if ( accountType == AccountType.NewAccount ) ...

```

- ***코드를 읽는 개발자에게 다음에 오는 내용을 알려주기 위해 주석을 작성하라***
	- 훌륭한 주석은 코드를 보는 사람에게 다음에 무엇이 올지 말해준다
	- 개발자는 주석만 읽고도 코드가 무엇을 수행하고 특정한 기능을 어디서 찾아야 하는지에 대한 아이디어를 얻을 수 있어야 한다
- ***주석을 소중하게 여겨라***
- ***일반적이지 않은 내용을 문서화하라***
	- 코드 자체만으로 명확하지 않은 내용이 있다면 그러한 내용을 주석에 넣어라
- ***축약하지 마라***
	- 주석은 축약된 내용을 이해하려는 노력 없이도 명백하고 읽기 쉬워야 한다
- ***중심 주석과 부차적인 주석을 구별하라***
	- 예시
```java

// 삭제되어야 하는 문자열은 생력하면서 <-- 중심 주석
// 테이블에 있는 문자열을 복사한다
// ... 테이블에 있는 문자열의 수를 결정한다 <-- 부차적인 주석 앞에 생략 기호 추가
...
// ... 삭제되어야 하는 문자열을 표시한다

```

- 중심 주석을 특정한 루틴에 입력하기
- ***프로그래밍 언어나 개발 환경에서의 오류나 문서화되지 않은 기능에 관한 내용을 주석으로 작성하라***
	- 오류 처리를 문서화한 예제

```java

blockSize = optimalBlockSize( numItems, sizePerItem );

/*

	다음 코드는 WriteData()에서 세 번째 매개변수가 500일 때만
	발생하는 오류를 해결하는 데 필요하다
	명확하게 하기 위해 '500'을 이름 상수로 대체했다

*/

if ( blockSize == WRITEDATA_BROKEN_SIZE ) {
	blockSize = WRITEDATA_BROKEN_SIZE;
}

WriteData ( file, data, blockSize );

```

>[!important] 💡 ***교묘한 코드는 정말 나쁜 코드***
-  **교묘한 코드에는 주석을 작성하지 않는다**
	- 예시
```java

// 매우 중요한 사항:
// 이 클래스의 생성자는 UiPublication에 대한 참조를 매개변수로 받는다
// UiPublication 객체는 DatabasePublication 객체보다 먼저 소멸되어서는 안된다

```
- 데이터 선언에 주석 작성
	- ***수치 데이터의 단위를 주석으로 작성하라***
	- 어떤 숫자가 길이를 표현한다면 그 길이가 인치나 피트, 미터, 킬로미터 중 어떤 단위로 표현되는지 명시해야 한다
- ***허용 가능한 값의 범위를 주석으로 작성하라***
	- 변수가 어떤 범위 내에 있어야 한다면 기대 범위를 주석으로 작성한다
- ***코드의 의미를 주석으로 작성하라***
	- 예시
		![[codeComplete84.png]]
	- ***입력 데이터의 한계를 주석으로 작성하라***
	- ***비트 수준의 플래그를 문서화하라***
		![[codeComplete85.png]]
	- ***변수와 연관된 주석에 변수의 이름을 입력하라***
	        - 특정한 변수를 가리키는 주석이 있다면 변수가 갱신될 때마다 주석이 갱신되게 해야 한다. 일관된 변경을 향상시크는 한 가지 방법은 해당 주석에 변수 이름을 함께 입력하는 것이다
	- ***전역 데이터를 문서화하라***
		- 주석에 데이터의 목적과 이 데이터가 전역으로 선언되어야 하는 이유를 설명해야 한다
		- 데이터가 사용되는 곳에서도 해당 데이터가 전역 데이터임을 분명히 밝혀야한다
- 제어 구조에 주석 작성
	- 예시
		![[codeComplete86.png]]
	- ***if나 case, 반복문, 명령문 블록 앞에 주석을 입력하라***
		- 제어 구조의 목적을 분명히하기 위해 주석을 사용하라
	- ***각 제어 구조의 끝에 주석을 작성하라***
	        ![[codeComplete87.png]]
	- ***루프의 끝을 가리키는 주석을 코드가 복잡하다는 것을 알리는 경고로 생각하라***
- 루틴에 주석 작성
	- 루틴 주석을 위한 가이드라인
		- ***설명하는 코드와 가까운 곳에 주석을 작성하라***
			- 주석과 코드가 불일치하기 시작하면 주석은 쓸모없어진다. 대신 근접성 원칙에 따라 주석을 가능한 한 관련 코드와 가까운 곳에 입력하도록 한다
		- ***루틴의 위에 한두 문장으로 각 루틴을 설명하라***
			- 설명을 짧게 작성하는 데 어려움이 있다면 설계가 좋지 않다는 신호
		- ***매개변수를 선언한 곳에서 문서화하라***
```java

public void InsertionSort (
	int[] dataToSort, //firstElement와 lastElement위치에 있는 정렬할 요소
	int firstElement, // 정렬하기 위한 첫 번째 요소의 인덱스
	int lastElement // 정렬하기 위한 마지막 요소의 인덱스
)

```

- ***javadoc과 같은 코드 문서화 유틸리티를 활용하라***
	![[codeComplete88.png]]
	- ***입력과 출력 데이터를 구별하라***
	- ***인터페이스 가정을 문서화하라***
	- ***사용하는 전역 변수를 문서화하라***
	- ***루틴의 한계에 대해 주석을 작성하라***
		- 계산이 어떤 조건에서 불명확하다면 그러한 조건을 문서화하라
		- 문제가 발생했을 때 취하는 기본 행동이 있다면 그러한 행동을 문서화하라
		- 특정한 크기의 배열이나 테이블만 처리해야 한다면 이를 설명하라
	- ***루틴이 미치는 전역적인 효과를 문서화하라***
		- 루틴이 전역 데이터를 변경한다면 전역 데이터에 무엇을 하는지 정확하게 기술한다
		- 일반적으로 문서를 작성하는 것이 지나치게 부담이 되면 코드를 재작성해 전역 데이터를 줄인다
	- ***사용된 알고리즘의 출처를 문서로 작성하라***
		- 자신이 알고리즘을 개발했다면 알고리즘에 관한 내용을 어디서 찾을 수 있는지 설명해야 한다
	- ***프로그램의 위치를 표시하기 위해 주석을 사용하라***
- 클래스와 파일, 프로그램에 대한 주석 작성
	- **클래스 문서를 작성하기 위한 일반적인 가이드라인**
		- ***클래스에 대한 설계 접근 방법을 기술하라***
			- 클래스의 설계 철학, 전체적인 설계 접근 방법, 고려했지만 결국 사용하지 않은 대안 등의 내용을 기술
		- ***한계와 사용 가정 등을 기술하라***
			- 루틴과 비슷하게 클래스 설계 시 발생한 모든 한계를 기술해야 한다
			- 입출력 데이터에 관한 가정, 오류 처리 책임, 전역적인 효과, 알고리즘의 출처 등을 기술해야 한다
		- ***클래스 인터페이스를 기술하라***
			- 클래스의 인터페이스는 클래스를 사용하는 데 필요한 모든 정보를 포함해야 한다
		- ***클래스 인터페이스에 세부 구현 내용을 기술하지 마라***
		            - 클래스 인터페이스 파일은 클래스를 사용하는 데 필요한 정보만 포함해야 하고 구현이나 내부 작업을 유지 관리하는 데 필요한 정보는 포함해서는 안된다
- **파일 문서화를 위한 일반적인 가이드라인**
	- ***각 파일의 목적과 내용을 설명하라***
		- 파일 헤더 주석은 파일에 포함된 클래스나 루틴을 기술해야한다
		- 파일이 하나 이상의 클래스를 포함하고 있다면 왜 클래스를 하나의 파일에 넣었어야 했는지 설명
		- 모듈화 이외의 이유로 파일을 여러 개의 소스 파일로 나눈 경우, 파일에 대한 목적을 자세히 설명하면 프로그램을 수정하는 개발자에게 큰 도움이 된다
	- ***주석 블록에 이름과 이메일 주소, 전화번호를 입력하라***
		- 코드 안에 작성자를 명시하는 것이 중요하다
		- 개별적인 루틴이나 클래스, 프로그램을 다루느냐에 따라 루틴이나 클래스, 프로그램 수준에서 작성자 정보를 표시해야 한다
        - 버전 관리 태그를 넣어라
```java

// $id: ClassName.java, v 1.1 2004/02/05 00:36:43 ismene Exp $

```
- 주석 블록에 법적인 사항을 넣어라
	![[codeComplete89.png]]
- ***파일 이름은 내용과 관련된 이름으로 지어라***
	- 예시
		- Employee.cpp

- **프로그램 문서를 위한 책 패러다임**
	- 책 구성 요소
		- 서문
			- 파일의 시작 부분에서 발견되는 것처럼 소개 주석의 그룹
			- 프로그램의 전체적인 개요
		- 목차
			- 최상위 파일, 클래스, 루틴
			- 목록이나 구조적인 차트
		- 단락
			- 루틴 선언, 데이터 선언, 실행 명령문 등 루틴을 구성하는 부분
		- 상호 참조
			- 줄 번호를 포함한 코드의 상호 참조 맵
## 32.6 IEEE 표준

- 소프트웨어 개발 표준
    ![[codeComplete90.png]]
- 소프트웨어 품질 보증 표준
	![[codeComplete91.png]]
- 관리 표준
	![[codeComplete92.png]]
## 체크리스트

- 체크리스트
    ![[codeComplete93.png]]
	![[codeComplete94.png]]
# 33장 개발자 성격
## 33.1 성격은 주제를 벗어난 것 아닌가
- 프로그래머의 성격
	- 성격은 훌륭한 개발자를 만드는 결정적인 요소
## 33.2 지성과 겸손
- 지성과 겸손
	- 일반적인 프로그램을 완전하게 이해하려면 세부 사항을 받아들이는 무한한 능력과 그것들을 파악할 수 있는 능력이 동시에 필요하다
	- 생각을 집중하는 방법이 지능보다 더 중요하다
	- 에츠허르 데이트스트라 -겸손한 프로그래머
	        - 프로그래머에 뛰어난 사람은 자신의 두뇌가 얼마나 작은지 깨달은 사람
        - 프로그래밍을 가장 못 하는 사람은 자신의 두뇌가 작업을 따라가지 못한다는 사실을 거부하는 사람
        - 좋은 프로그래밍 습관의 목표
		- 시스템 분해의 핵심은 그것을 이해하기 쉽도록 더욱 간단하게 만드는 것
		- 루틴을 짧게 만들면 두뇌의 부담이 줄어든다
		- 구현 세부 사항 수준의 관점 대신 문제 도메인 관점에서 프로그램을 작성하면 정신적 부담이 줄어든다
		- 모든 종류의 규약을 사용하면 이득이 거의 없는 비교적 흔한 프로그래밍 작업으로부터 머리를 해방시킨다
## 33.3 호기심
- 호기심
	- 뛰어난 개발자가 되는 과정에서 기술적인 문제에 대한 호기심은 매우 중요하다
	- ***개발 과정에 대한 자신의 인식을 구축하라***
		- 책에서 읽거나 소프트웨어 개발 과정을 직접 관찰하면서 개발 프로세스에 대해 더 많이 알게 될수록 변경 사항을 이해하고 좋은 방향으로 나아갈 수 있는 더 좋은 위치에 있을 수 있다
	- 주어진 일 전체가 기술을 발전시키지 않는 기간이 짧은 일로만 구성되어 있다면 불만을 가져라
	- ***실험하라***
		- 사용하는 언어의 기능이 어떻게 작동하는지 모른다면 그러한 기능을 사용할 수 있는 간단한 프로그램을 작성한 다음 어떻게 작동하는지 확인해본다 ⇒ **프로토타입 만들기**
	- ***문제 해결에 관한 책을 읽어라***
		- 문제 해결은 컴퓨터 소프트웨어 구축에서 가장 핵심적인 활동
	- ***행동하기 전에 분석하고 계획을 세워라***
		- 대부분의 개발자의 문제점은 분석을 지나치게 하는 것이 아니라, 행동에 쏠려있어 과도한 분석에 너무 집중하는 것은 아닐까 하는 걱정이다
	- ***성공적인 프로젝트를 학습하라***
		- 훌륭한 개발자의 작업을 학습하기
	- 프로그래밍에서 사례 연구에 관한 책의 유무에 상관없이 뛰어난 개발자가 작성한 코드를 찾아서 읽어보라
- ***문서를 읽어라***
	- **Read the fucking manual**
- ***다른 책과 정기 간행문들을 읽어라***
	- 독서를 많이 하지 않으면 기술적으로 발전하기가 어렵다
	- 훌륭한 프로그래밍 책을 두 달마다 한 권씩 읽는다면 머지않아 이 산업을 확실히 이해하게 되고 다른 사람과 차별화될 것이다
- ***다른 전문가들과 관계를 맺어라***
	- 소프트웨어 개발 기술을 연마하는 데 열중인 다른 사람들을 찾아라
- ***전문적인 개발자가 될 수 있도록 노력하라***
	- 1단계 - 초보
		- 초보자란 한 가지 언어의 기본 기능을 사용할 수 있는 개발자
		- 초보자는 클래스와 루틴, 루프, 조건문을 작성할 수 있으며 해당 언어의 많은 기능을 사용할 수 있다
	- 2단계 - 입문
		- 여러 언어의 기본 기능을 사용할 수 있으며 적어도 한 가지 언어를 능숙하게 다룬다
	- 3단계 - 유능
		- 한 가지 언어나 환경, 또는 둘 모두에 관한 전문적 기술을 갖고 있다
	- 4단계 - 리더십
		- 3단계 개발자의 전문적인 지식을 갖고 있으며 프로그래밍이 컴퓨터와의 의사소통 15% 사람과의 의사소통 85%로 이루어진다는 사실을 알고 있다.
		- 전문가는 기계보다 사람을 위해 코드를 작성한다
## 33.4 지적인 정직함
- 지적인 정직함
	- 전문가가 아님에도 전문가인 것처럼 행동하지 않는 것
	- 실수를 기꺼이 인정하는 것
	- 오류 메시지를 막기보다는 컴파일러 경고를 이해하려고 노력하는 것
	- 컴파일해서 프로그램 작동 여부를 확인하기보다는 프로그램을 명백하게 이해하는 것
	- 현실적인 상황 보고서를 제공하는 것
	- 현실적인 일정표를 제공하고 관리자가 일정을 조절할 수 있는지 물었을 때 자기 뜻을 지키는 것
## 33.5 의사소통과 협동
- 의사소통과 협동
	- 진정 뛰어난 개발자는 다른 사람들과 어떻게 원만하게 일하고 노는지 학습한다
	- 읽을 수 있는 코드를 작성하는 것은 팀원이 되는 일부분
## 33.6 창의성과 훈련
>[!important] 💡 **“ 형식은 자유를 준다”**

- 창의성과 훈련
	- 인간의 훈련을 강조한 방법과 도구가 특히 효과적
	- 매우 창의력이 뛰어난 사람 중 상당수가 매우 규칙적
## 33.7 게으름
- 게으름
	- 재미없는 작업을 미루는 것
	        - 유익하다고 말하기 어렵다
	- 재미없는 작업을 신경 쓰이지 않도록 빨리 처리하는 것
        - 작은 일을 곧바로 하는 습관을 지니면 일을 미루는 식의 게으름을 피할 수 있다
        - 재미없는 무언가에 최소한의 시간을 투자함으로써 문제를 해결한다
	- 재미없는 작업을 다시 수행할 필요가 없도록 툴을 작성하는 것
		- 가장 생산적인 게으름
## 33.8 덜 중요한 특성

- 인내심
	- 상황에 따라 인내심은 자산이 될 수도, 부채가 될 수도 있다
	- 포기할 때를 알기란 어렵지만, 그 시기를 묻는 것은 중요하다. 좌절하고 있다는 것을 알아차릴 때가 그러한 질문을 하기 좋은 시기
- 경험
	- 소프트웨어 분야에서 책에서 얻은 학습과 비교한 직접 경험의 가치는 여러 가지 이유로 다른 분야 비해 작다
	- 기초 지식은 빠르게 변하기 때문
	- 소프트웨어에서 이전에 사용했던 프로그래밍 언어의 사고 습관이나 오래된 장비에서 작동했던 코드 튜닝 기법을 떨쳐버릴 수 없으면 그 경험이 차라리 없는 것만 못하다
	- **진정한 경험을 쌓으려면 지속적으로 학습해야 한다**
- 별난 프로그래밍
	- 반드시 프로그래밍에 흥분해야한다. 하지만 흥분이 유능함을 대체할 수 없다. 무엇이 더 중요한지를 기억하라
## 33.9 습관
- **좋은 습관이 필요하다**
# 34장 소프트웨어 장인에 대한 주제
## 34.1 복잡성 정복
- 복잡성 정복
	- 한 번에 시스템의 작은 부분에 집중할 수 있도록 하나의 시스템을 아키텍처 수준에서 서브시스템으로 나눈다
	- 클래스의 내부 작업을 무시할 수 있도록 클래스 인터페이스를 신중하게 정의한다
	- 불필요한 사항을 기억할 필요가 없도록 클래스 인터페이스 수준에서의 추상화를 유지한다
	- 전역 데이터는 한 번에 살펴볼 코드의 비율을 증가시키기 때문에 피한다
	- 깊은 상속 관계는 생각할 것이 많으므로 피한다
	- 여러 단계로 중첩되는 반복문과 조건문은 더 간단한 제어 구조로 대체할 수 있으니 사용하지 않는다
	- goto 문은 대부분의 사람이 흐름을 따라가기가 어렵기 때문에 피한다
	- 서로 다른 오류 처리 기술을 사용하지 말고 일관된 접근 방법을 신중하게 정의한다
	- 내장형 예외 메커니즘은 자칫 goto 문처럼 이해하기 어려운 구조를 만들 수 있으니 체계적으로 사용하도록 한다
	- 클래스가 전체 프로그램 크기 만한 괴물 클래스로 자라지 않도록 주의한다
	- 루틴을 간략하게 유지한다
	- 명확하고 설명이 없어도 명백한 변수 이름을 지어 기억 낭비를 줄인다
	- 루틴에 전달되는 매개변수의 수를 최소화하고 루틴 인터페이스의 추상화를 유지하는 데 필요한 매개변수만 전달한다
	- 서로 다른 코드의 차이점을 기억하느라 기억력을 낭비하지 않도록 규약을 사용한다
## 34.2 자신에게 맞는 프로세스 선택
- 자신에게 맞는 프로세스 선택
	- 한 명 이상의 개발자로 구성된 프로젝트에서는 조직적인 특성이 프로젝트에 참여한 개인의 능력보다 큰 영향을 미친다
	- 사용하는 프로세스가 요구사항이 얼마나 견고한지와 얼마나 견고해야 하는지를 결정한다
	- 프로세스가 중요한 주요 이유는 소프트웨어에서 품질을 첫 번째 과정을 시작할 때부터 미리 고려해야 하기 때문
	- 성급한 최적화도 프로세스 오류에 속한다. 효과적인 프로세스는 처음에 굵직하게 조절하고 마지막에 미세하게 조절한다
	- 하위 수준 프로세스에서도 의사코드를 작성하고 의사코드에 코드를 채우는 프로세스를 따른다면 하향식 설계 방식의 장점을 취할 수 있다
## 34.3 컴퓨터보다 사람을 위한 프로그램을 작성하라
- 컴퓨터보다 사람을 위한 프로그램을 작성하라
	- 다른 사람과의 의사소통이 이해하기 쉬운 코드를 지향하도록 코드의 가독성을 강조해야한다
	- 좋은 가독성의 영향
		- 이해도
		- 검토 용이성
		- 오류 비율
		- 디버깅
		- 수정 용이성
		- 개발 시간 - 상기 과정의 결과
		- 외적 품질 - 상기 과정의 결과
## 34.4 언어에 제약을 받지 않고 언어를 활용한 프로그래밍
- 언어에 제약을 받지 않고 언어를 활용한 프로그래밍
	- 프로그래밍에 대한 모든 행위는 프로그래밍 언어가 기본적으로 제공하는 개념에 의해 제약을 받지 않아야 한다
	- 최고의 개발자들은 그들이 무엇을 원하는지 생각한 다음 그들이 원하는 대로 프로그래밍 도구를 사용해 목표를 달성할 방법을 결정한다
	- 프로그래밍 언어가 지원한다는 이유로 전역 데이터나 goto문을 사용할 필요는 없다. 그러한 위험한 프로그래밍 기능을 사용하기 보다는 그러한 약점을 보완할 수 있는 프로그래밍 규약을 사용하면 된다
	- **가장 명확한 방법을 사용하는 프로그래밍은 언어에 얽매이기보다는 언어를 활용하는 것**
## 34.5 규약을 활용해 핵심에 집중
- 규약을 활용해 핵심에 집중
	- 규약은 중요한 정보를 간결하게 전달한다
		- 이름 짓기 규약은 하나의 문자로 지역변수, 클래스, 전역 변수를 구분
		- 대문자는 타입과 이름 상수, 변수를 구분
	- 규약은 알려진 위험을 막아준다
		- 전역 변수 사용이나 한 줄에 여러 표현식을 사용하는 것을 금지해 위험한 습관을 제거할 수 있다
	- 규약을 이용하면 하위 수준 작업에 대해 예측이 가능하다
		- 메모리 요청 처리, 오류 처리, 입|출력, 클래스 인터페이스에 대한 규약이 있다면 코드에 의미 잇는 구조를 추가하게 되고 다른 개발자가 규약을 알고 있는 경우 더욱 쉽게 코드를 이해할 수 있다
	- 규약은 언어의 약점을 보완할 수 있다
		- 이름 상수를 지원하지 않는 언어(파이썬, 셸 스크립트) 에서 규약을 이용해 읽고 쓰기 위한 변수와 읽기 전용 상수를 모방하기 위한 변수를 구분할 수 있다
## 34.6 문제 중심의 프로그래밍
- 최상위 수준 코드는 파일, 스택, 큐, 배열과 같은 문자에 대한 세부 사항으로 채워져서는 안된다 ⇒ **최상위 수준 코드는 해결하려는 문제를 기술해야 한다**
- 프로그램을 추상화 수준으로 나누기
	- 분명히 어느 단계가 되면 구현 중심의 관점으로 작업해야 하지만, 문제 도메인 관점으로 작업하는 부분에서 구현 수준 관점으로 작업하는 부분을 분리할 수 있다

	![[codeComplete95.png]]

- **0 수준 : 운영체제 연산과 기계 명령어**
	- 고급 언어를 사용하고 있다면 , 가장 낮은 수준에 대해 걱정할 필요가 없다사용하고 있는 언어가 자동으로 처리해줄 것이다
- **1 수준 : 프로그래밍 언어 구조와 도구**
	- 프로그래밍 언어 구조는 해당 언어의 기본 데이터 형식, 제어 구조 등을 의미한다
	- 대부분의 일반적인 언어는 추가적인 라이브러리와 운영체제 호출에 대한 접근 방법을 제공
	- 이런 구조나 도구 사용은 너무 당연한 것
	- 많은 개발자가 이러한 추상화 수준을 넘어서 작업하지 못해 필요 이상으로 어려움을 겪는다
- **2 수준 : 저수준 구현 구조**
	- 알고리즘과 데이터 형식에 대해 대학 수업 시간에 배운 연산과 데이터 형식
	- 스택, 큐, 연결 리스트, 트리, 인덱스된 파일, 순차적인 파일, 정렬 알고리즘, 검색 알고리즘 등
- **3 수준 : 저수준 문제 도메인 관점**
	- 이 수준에서는 문제 도메인 관점에서 작업하는 데 필요한 기초 정보를 갖게 된다
	- 이 수준은 아래의 컴퓨터 과학 구조와 위의 문제 도메인 코드 사이의 아교와 같은 역할을 하는 계층
	- 많은 응용 프로그램에서 이 계층은 비지니스 객체 계층이나 서비스 계층
	- 이 클래스들은 이 수준에서 문제를 직접 해결하기에는 너무 기초적이지만, 상위 수준 클래스들이 문제를 해결하는 데 사용할 수 있는 틀을 제공한다
- **4 수준: 고수준 문제 도메인 관점**
	- 이 수준은 글자 그대로 문제를 다루는 추상적인 능력 제공
	- 이 수준의 코드는 컴퓨터 과학 전문가가 아닌 다른 사람, 기술에 대해 알지 못하는 고객이 읽을 수 있어야 한다ㄹ
	- 컴퓨터 과학 구조 계층에서 구현 세부 사항은 이 수준 아래에 있는 두 계층을 감추어야 한다. 이를 통해 하드웨어나 운영체제의 변경 사항이 이 계층에 영향을 주지 않도록 한다
- 문제 도메인에서 작업하기 위한 저수준 기법
	- 문제 도메인 관점에서 의미 있는 구조를 구현하기 위해 클래스를 사용한다
	- 데이터형에 대한 정보와 구현 세부 사항을 감춘다
	- 문자열과 숫자 리터럴의 의미를 기술하기 위해 이름 상수를 사용한다
	- 중간 계산 결과를 기술하기 위해 중간 변수에 할당한다
	- 복잡한 불린 테스트를 명료하게 하기 위해 불린 함수를 사용한다
## 34.7 낙석을 주의하라
>[!important] 💡 프로그래밍은 완전한 예술도 완전한 과학도 아니다. 일반적으로 그렇듯이 예술과 과학의 중간 어딘가에 있는 “기술”이다
- 낙석을 주의하라
	- 예술이나 과학, 기술, 공학에 상관없이 작동하는 소프트웨어 제품을 만들기 위해 여전히 개인적인 판단을 내려야 한다
	- 컴퓨터 프로그래밍에서의 좋은 판단을 내리기 위해 경고 표시와 프로그램의 문제점에 대한 세밀한 표시에 민감해져야 한다
	- **“교묘한 코드”는 “나쁜 코드”를 의미하는 코드 용어다**
		- 평균 이상으로 많은 오류를 갖고 있는 클래스도 경고 표시
        - 평균보다 많은 오류를 갖는 클래스가 있다면 계속 평균보다 많은 오류를 갖게 될 것이다 ⇒ 그런 클래스는 다시 개발하는 것이 좋다
- 프로그램의 비정상적인 결함 수는 프로세스에 결함이 있음을 암시한다
	- 좋은 프로세스는 오류를 내포하는 코드가 작성되지 않게 한다
	- 좋은 프로세스는 아키텍처에는 아키텍처 검토, 설계에는 설계 검토, 코드 작성에는 코드 검토가 따르는 검사와 조율 과정을 포함한다
- 프로젝트가 디버깅을 많이 해야 한다면 사람들이 현명하게 일하고 있지 않다는 경고 표시다
	- 경고 표시가 있다면 프로그램의 품질을 의심해봐야 한다
	- 반복되는 코드나 여러 곳에서 비슷하게 수정하는 식의 작업을 진행 중이라면 “불편하고 불만족스러움”을 느끼고 클래스나 루틴에서 제어가 적절하게 집중되어 있는지를 의심해야 한다
- 프로그램에 깊이 빠져 있을 때 프로그램 설계의 일부분이 코드를 작성하기에 충분한 정도로 잘 정의되어 있지 않다는 경고 표시에 주의를 기울인다
	- 주석을 작성하고 변수 이름을 짓고 문제를 명확한 인터페이스를 갖는 응집된 클래스로 분리하는 데 어려움이 있다면 코드를 작성하기 전에 설계를 더 열심히 생각해 봐야 한다는 뜻
- 프로그램이 이해하기 어렵다는 증상에 민감해야 한다
	- 자신이 이해하기 어렵다면 다른 개발자에게는 더 어려울 것이다
	- **어려운 것은 잘못된 것이다. 단순하게 만들어라**
- 프로그램에서 문제점을 쉽게 간과하지 못하게 하라
	- 컴파일러 경고는 자주 간과되는 경고 신호다
## 34.8 반복, 반복, 또 반복
- 반복, 반복, 또 반복
	- 반복은 맣은 소프트웨어 개발 행위에 적합하다
	- 반복 프로세스
		- 시스템의 초기 명세화 과정에는 모든 요구사항에 동의할 때까지 다양한 버전의 요구사항을 놓고 사용자와 작업하는 것도 포함
		- 시스템을 여러 단계로 나누어 만들고 배포해 프로세스에 융통성을 주는 것
		- 최종 제품을 만들기 전에 빠르고 비용이 적게 드는 대안 해결책을 개발하기 위해 프로토 타이핑하는 것
	- 소프트웨어 설계는 발견적 프로세스며 모든 발견적 프로세스처럼 반복적으로 개정하고 향상시켜야한다
	- 소프트웨어는 검증되기 보단 확인되는 경향이 있다. 즉, 정확하게 답할 때까지 반복적으로 테스트하고 개발된다
	- 상위, 하위 수준 설계 시도도 반복되어야 한다
	- 반복의 개념은 코드 튜닝에서 다시 나타난다
	- 검토는 그것이 수행되어야 하는 단계에 반복을 삽입함으로써 개발 프로세스에 영향을 미친다
		- 검토의 목적은 특정한 시점에서 작업의 질을 검사하기 위한 것이다.
		- 제품이 검토를 통과하지 못한다면 작업을 다시 하기 위해 되돌려진다. 성공하면 더 이상 반복할 필요가 없다
## 34.9 소프트웨어와 신조를 떼어 놓아라

- 소프트웨어 신탁(oracles)
	- 새로운 제도는 공표해 종사자들이 새로운 방법을 시험해볼 수 있게 해야 한다
	- 새로운 방법은 완벽하게 검증되거나 의미 없다고 판단되기 전에는 지속해서 사용해야 한다
	- 최신 유행에 집착하기 보다는 여러 방법을 혼합해 사용하라.
	- 호기심을 자극하는 최신 방법을 경험하는 것도 좋지만, 오래되고 신뢰할 수 있는 방법에 의존하라
- 절충주의
	- 프로그래밍 문제에 대한 가장 효과적인 해결책을 찾을 때 한 가지 방법에 대한 맹목적인 믿음은 다양한 선택에 대한 가능성을 미리 배제한다
	- 견고한 프로세스가 부적절하며 성공할 가능성도 거의 없다.
		- 설계를 예로 들면 때때로 하향식이 잘 맞을 때가 있고, 객체지향적 접근 방법, 상향식 방법, 데이터 구조 접근 방법이 더 잘 맞을 때도 있다 ⇒ **여러 가지 접근 방법을 사용해  봐야 한다**
	- 새로운 방법론이 처음에는 불편할 것이다.  프로그래밍에서 신조를 피하라는 충고는 그것으로 문제를 해결할 때 약간의 어려움이 생기자마자 새로운 방법을 사용하지 말아야한다는 것을 의미하지는 않는다. 새로운 방법도 공정하게 대우하고 오래된 방법도 마찬가지로 공정하게 대우하라
	- **문제에 따라 하나의 기법을 선택해야한다**
- 실험
>[!important]
> 💡 **핵심은 소프트웨어 개발의 모든 측면에 대해 열린 마음을 유지해야 한다는 것이다.
> 제품뿐만 아니라 프로세스에 대한 기술적인 정보를 얻어야 한다.
> 열린 마음으로 하는 실험과 기존에 정의된 접근 방법에 대한 신앙적인 고집은 서로 어울리지 않는다
>
- 절충주의는 실험과 밀접한 관련이 있다
- 개발 프로세스 전체를 실험해야 하지만, 융통성 없는 태도는 추진력을 감퇴시킨다
- 효과적으로 실험하기 위해서는 실험 결과에 따라 기꺼이 신념을 변경할 수 있어야 한다
- 소프트웨어 개발에서 융통성 없는 접근 방법의 상당수는 실수에 대한 공포 때문이다
- 실험은 절충주의만큼이나 많은 수준에서 적합하다. 선택할 준비가 된 각 수준에서 어떤 접근 방법이 가장 잘 작동할 것인지를 결정하기 위해 적절한 실험을 제안할 수 있다
# 35장 더 많은 정보를 얻으려면
## 35.1 소프트웨어 구현에 관한 정보
- **실용주의 프로그래머 - 앤드루 헌트, 데이비드 토머스**
- 생각하는 프로그래밍 - 존 벤틀리
- 익스트림 프로그래밍 - 켄트 벡
	- 구현 중심적 접근 방법
- Writing Solid Code : 버그 안녕 - 스티브 맥과이어
- 프로그래밍 수련법 - 브라이언 w. 커니핸
## 35.2 구현 외의 주제
- 소프트웨어 공학의 사실과 오해 - 로버트 L.글래스
- Professional 소프트웨어 개발 - 로버트 L.글래스
- 프로그래밍 심리학 - 제럴드 M.와인버그
- 맨먼스 미신 - 프레더릭 브룩스
- 피플웨어 - 드마르코와 리스터
- 소프트웨어 크리에이티비티 2.0 - 로버트 L.글래스
- 소프트웨어 공학 - 로저 S. 프레스맨
- 소프트웨어 공학 - 이안 썸머빌
- ACM Computing Revies - 미국 컴퓨터 협회 간행물
- Construx Software 의 “Professional Development Ladder(www.construx.com/ladder/)
## 35.3 정기 간행물
- Software Development - www.sdmagazine.com
- Dr.Dobb’s Journal - www.ddj.com
- IEEE Software - www.computer.org/software
- IEEE Computer - www.computer.org/computer
- Communication of ACM - www.acm.org/cacm
- 유명 간행물

    ![[codeComplete96.png]]
## 35.4 소프트웨어 개발자의 독서 계획
- 입문자 수준
	- 아이디어 대폭발 - 제임스 애덤스
	- 생각하는 프로그래밍 - 존 벤틀리
	- 소프트웨어 공학의 사실과 오해 - 로버트  L.글래스
	- 소프트웨어 프로젝트 생존 전략 - 스티브 맥코넬
	- Code Complete - 스티브 맥코넬
- 중급자 수준
	- Software Configuration Management Patterns: Effective Teamwork, Practical Integration - 스티븐 P. 베르주크
	- UML DISTILLED 표준 객체 모델링 언어 입문 - 마틴 파울러
	- 소프트웨어 크리에이티비티 2.0 - 로버트 L.글래스
	- Testing Computer Software - 셈 카너, 잭 포크, 흥 Q 응우옌
	- UML과 패턴의 적용 - 크레이그 라먼
	- 프로젝트 쾌속 개발 전략 - 스티브 맥코넬
	- Software Requirements - 칼 위거스
- 전문가 수준
	- Software Architecture in Practice - 랜 베스, 폴 크렐멘츠, 릭 캐즈먼
	- 리팩토링 : 코드 품질을 개선하는 객체지향 사고법 - 마틴 파울러
	- Gof의 디자인 패턴 - 에릭 감마
	- Principles of Software Engineering Management - 톰 길브
	- Writing Solid Code : 버그 안녕 - 스티브 맥과이어
	- 오브젝트 디자인 - 베르트랑 메이어
## 35.5 전문가 단체에 가입하기