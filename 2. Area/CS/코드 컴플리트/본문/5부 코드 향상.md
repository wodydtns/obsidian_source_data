# 20장 소프트웨어 품질

## 20.1  소프트웨어 품질의 특성

- 소프트웨어 품질 특성
	- 외적인 특성
		- 정확성 : 시스템의 사양과 설계, 구현에 오류가 없는 정도
		- 사용성 : 사용자가 시스템을 배우고 사용하는 데 있어서의 용이함
		- 효율성 : 메모리와 실행 시간 같은 시스템 리소스의 최소 사용
		- 신뢰성 : 정해진 상황에서 언제든지 필요한 기능을 수행할 수 있는 시스템의 능력, 고장 사이의 시간
		- 무결성 : 시스템이 프로그램이나 데이터에 대해 허용되지 않거나 잘못된 접근을 막는 정도, 무결성의 기본 개념에는 데이터를 적절한 접근을 보장하는 것뿐만 아니라 권한이 없는 사용자의 접근을 제한 기능이 포함
		- 적응성 : 시스템을 변경하지 않고 설계된 환경뿐만 아니라 다른 응용 프로그램이나 환경에서 사용될 수 있는 정도
		- 정밀성 : 특히 양적 결과 면에서 구성된 시스템에 오류가 없는 정도
		- 견고성 : 시스템이 잘못된 입력이나 악조건에서도 기능을 계속해서 수행할 수 있는 정도
- 내적인 특성
	- 유지보수성 : 소프트웨어 시스템의 기능을 변경하거나 기능을 추가하거나 성능을 향상시키거나 결함을 수정하기 위해 시스템을 변경할 때의 편의성
	- 유연성 : 시스템이 설계된 환경이 아닌 다른 목적이나 환경으로 변경할 수 있는 정도
	- 이식성 : 시스템이 설계된 환경이 아닌 다른 환경에서 작동할 수 있도록 시스템을 변경할 때의 편의성
	- 재사용성 : 시스템의 일부분을 다른 시스템에서 사용할 수 있는 정도나 편의성
	- 가독성 : 시스템의 소스코드를 상세한 명령문 수준에서 읽고 이해할 때의 편의성
	- 테스트 용이성 : 시스템을 단위 테스트나 시스템 테스트할 수 있는 정도. 시스템이 요구사항을 충족하는지 검증할 수 있는지에 대한 정도
	- 이해 용이성 : 시스템 구성과 코드 수준에서 시스템을 이해할 때의 편의성
	- 서로 상충하는 목적 사이에서 가장 바람직한 방법을 찾는 것은 소프트웨어 개발을 진정한 공학 훈련으로 만드는 활동
	- ***어떤 특성에 초점을 맞추는 것이 항상 다른 특성과의 트레이드오프를 의미하지는 않는다***
## 20.2 소프트웨어 품질을 향상시키기 위한 기법들
- 소프트웨어 품질 향상 프로그램의 요소
	- ***소프트웨어 품질의 목표***
		- 외적인 특성과 내적인 특정 중 명확한 품질의 목표 설정
	- ***명확한 품질 보증 활동***
		- 어떤 조직에서는 빠르지만 지저분한 프로그래밍을 예외적인 것이 아닌 당연한 것으로 여긴다. 결함이 있더라도 프로그램을 빨리 “완료” 하는 개발자들이 훌륭한 프로그램을 작성하고 프로그램을 출시하기 전에 쓸모 있는지 확인하는 개발자보다 더 많은 보수를 받는다
        - ***그런 조직은 개발자에게 품질이 우선순위에 있어야 한다는 것을 알려줘야 한다***
	- ***테스트 전략***
	        - 테스트 수행은 제품의 신뢰성에 대한 상세한 평가를 제공할 수 있다
	- ***소프트웨어 공학 가이드라인***
		- 가이드라인은 개발 당시 소프트웨어의 기술적인 특성을 관리해야 한다
		- 문제 정의, 요구사항 개발, 아키텍처, 구현, 시스템 테스트를 포함한 모든 소프트웨어 개발 활동에 적용
	- ***비형식적인 기술적 검토***
		- 설계나 코드를 책상에서 검사하거나 동료와 함께 코드를 살펴보는 방법
	- ***절차에 따르는 기술적 검토***
		- “최저 비용” 단계 찾기
		- 개발자들은 이를 찾기 위해 품질 관문이나 주기적인 테스트, 검토를 통해 제품의 품질이 다음 단계로 넘어가기에 충분한지 판단
		- “관문”은 아키텍처나 요구사항이 100% 완벽하지 않으면 안 된다는 것을 의미하는 것이 아니라, 요구사항이나 아키텍처가 실제 코드 개발을 진행할 수 있을 정도로 충분한지 결정하기 위한 관문이라는 의미
- 외부 감사
	- 개발 중인 프로젝트의 상태나 제품의 품질을 결정하기 위해 사용하는 특정한 형태의 기술적 검토
- 개발 프로세스
	- 변경 관리 과정
	- 결과 측정
	- 프로토타이핑
		- 실질적인 모델 개발
		- 개발자가 사용성을 결정하기 위해 사용자 인터페이스이 일부를 프로토타이핑
		- 수행 시간을 결정하기 위해 핵심적인 부분을 계산하거나 필요한 메모리의 크기를 결정하기 위해 전형적인 데이터 집합을 프로토타이핑할 수 있음
- 목표 설정
	- 품질 목표를 명확히 설정하라
## 20.3  품질 향상 기법의 상대적 효과성
- 발견된 결함의 비율
	- 결함 감지 기법을 평가하는 한 가지 방법은 프로젝트에 그 당시 존재하는 전체 결함의 수를 기준으로 이 기법을 사용해 발견한 결함의 비율을 결정하는 것
	- 인간의 처리 과정은 특정한 종류의 오류를 찾는 데 컴퓨터 기반의 테스트보다 우수한 경향이 있고, 다른 오류에서는 그 반대의 경우도 있다고 지적
	- 여러 결함 감지 기법들을 복잡적으로 사용했을 때 더 좋은 결과를 가져온다
- 결함 발견 비용
	- 정밀 검토가 테스트보다 비용이 더 저렴하다
		- 코드를 읽는 것이 테스트하는 것보다 시간당 약 80%의 결함을 더 발견한다
- 결함 수정 비용
	- 오류를 초기에 찾아내는 감지 기법이 결과적으로 더 낮은 수정 비용이 든다
	- 평균 이상의 품질을 얻기 위한 조합
		- **모든 요구사항, 모든 아키텍처, 시스템의 주요 부분의 설계에 대한 형식적인 정밀 검토**
		- **모델링이나 프로토타이핑**
        - **코드 읽기나 정밀 검토**
        - **수행 테스트**
## 20.4  품질 보증 활동 시기
- 소프트웨어에 오류가 더 일찍 삽입될수록 소프트웨어의 다른 부분과 더 많이 얽히고 오류를 제거하는 데 더 큰 비용이 든다
- **요구사항과 아키텍처에 있는 오류를 잡아내는 것이 좋다**
## 20.5 소프트웨어 품질의 일반적인 원칙
- 품질의 일반적 원칙
	- 생산성과 품질을 향상시키기 위한 가장 좋은 방법은 수정 작업이 요구사항의 변경이나 설계상 변경, 디버깅으로 인한 것인지에 **상관없이 코드를 재작성하는 데 걸리는 시간을 줄이는 것**
	- 대부분의 프로젝트에서 가장 큰 활동은 정상적으로 작동하지 않는 코드를 디버깅하고 수정하는 것
		- 오류를 예방하고 디버깅을 줄이면 생산성이 향상된다
# 21장 협력 구현
## 21.1 협력 개발 방법 개요
- 다른 품질 보증 기법을 보완하는 협력 구현
	- 협력 구현 → 개발자들이 코드 작성과 제품 개발에 관련된 다른 작업에 대한 책임을 공유하는 데 사용하는 기법
	- 협력 기법이 오류를 잡는 데 테스트보다 훨씬 효과적일 뿐만 아니라 테스트와는 다른 종류의 오류를 찾을 수 있음을 보여주었다
- 협력 구현은 협동 문화와 프로그래밍 경험을 제공한다
	- 검토는 개발자들에게 코드에 대한 피드백을 제공하는 중요한 메커니즘
	- 개발자들은 표준을 얼마나 잘 따르는지에 대한 피드백 뿐만 아니라 형식 설정, 주석, 변수 이름, 지역 변수와 전역 변수의 사용, 설계 방법, 개발 관행 등 더 주관적인 측면에 대한 피드백이 필요하다
	- 검토는 경험이 많고 적은 개발자들이 기술적인 문제에 대해 대화할 수 있는 기회를 만들어준다 ⇒ 검토는 현재, 미래의 품질 향상을 도모하는 좋은 기회이다
- 공동 소유권을 협력 구현의 모든 형태에 적용한다
	- 공동 소유권의 혜택
		- 여러 사람이 코드를 보고 코드를 다루면 코드의 품질이 좋아진다
		- 여러 사람이 코드에 대해 잘 알고 있기 때문에 누군가가 프로젝트를 그만두더라도 그 충격이 덜하다
		- 모든 개발자가 동등하게 버그를 수정할 수 있기 때문에 결함 수정 주기가 전체적으로 짧아진다
- 협력을 구현 전 만큼이나 구현 후에도 적용한다
## 21.2 짝 프로그래밍
- 짝 프로그래밍의 성공 조건
	- 짝 프로그래밍의 지침
		- ***코드 작성 표준으로 짝 프로그래밍을 지원하라***
	- 코드 작성 방식을 표준화를 통해 코드 작성 방식을 표준화
        - ***짝 프로그래밍이 감시가 되지 않도록 하라***
		- 키보드가 없는 사람이 프로그래밍에 적극적으로 참여해야 한다
		- 그 사람은 코드를 분석하고 다음에 어떤 코드가 작성될 것인지 미리 생각하고 설계를 평가하고 코드를 테스트하기 위한 방법을 계획해야한다
        - ***짝 프로그래밍을 강요하지 마라***
		- 부분적으로 짝 프로그래밍을 사용
        - ***정기적으로 짝과 작업을 교대하라***
		- 상승효과를 얻기 위해 짝끼리 정기적으로 작업을 교대하라
        - ***짝이 서로의 속도에 맞출 수 있도록 하라***
		- 속도가 빠른 파트너가 천천히 진행하거나 짝을 분리해 다른 파트너와 짝을 재구성해야 한다
        - ***파트너 모두 모니터를 볼 수 있게 하라***
        - ***사이가 좋지 않은 사람을 짝으로 만들지 말라***
        - ***초보자끼리 짝을 짓지 않는다***
		- 파트너 중 적어도 한 명이 이전에 짝을 지어본 경험이 있을 때 가장 잘 진행된다
        - ***팀의 리더를 선정하라***
	- 짝 프로그래밍의 혜택
		- 혼자서 개발할 때보다 압박을 더 잘 견딘다. 짝은 코드를 빠르고 엉망으로 작성하게 만드는 압력이 있을 때도 코드의 품질을 높게 유지할 수 있도록 서로를 격려한다
	        - 코드의 품질을 향상시킨다
	        - 일정을 단축시킨다.짝 프로그래밍은 더 빠르면서도 오류가 적은 코드를 작성하게 해주는 경향이 있다
	        - 협력 문화 보급과 신참 개발자의 교육, 공동 소유 장려와 같은 협력 구현의 다른 모든 혜택을 제공한다
    - 체크리스트        ![[codeComplete38.png]]
## 21.3 공식적인 정밀 검토
- 정밀 검토의 핵심적인 방법
	- 체크리스트는 과거에 문제가 있었던 영역에 정밀 검토자가 주의를 기울이게 해준다
	- 정밀 검토는 결함의 수정이 아니라 발견에 중점을 둔다
	- 정밀 검토자는 미리 정밀 검토 회의를 준비하고 그들이 발견한 문제점 목록을 준비해 참석
	- 모든 참석자에게 명료한 역할을 할당한다
	- 정밀 검토의 중재자는 정밀 검토 중인 제품의 작성자가 아니다
	- 중재자는 정밀 검토의 중개를 위한 특정한 훈련을 받은 사람이다
	- 정밀 검토 미팅은 모든 참석자가 적합하게 준비한 경우에만 개최한다
	- 데이터를 정밀 검토마다 모으고 다음 번 정밀 검토에 제공해 결과를 향상시킨다
	- 프로젝트 일정이나 경영자 관련 사항을 정밀 검토하지 않는다면 일반 경영자는 정밀 검토 미팅에 참석하지 않는다
- 정밀 검토로부터 어떤 결과를 기대할 수 있는가?
	- 설계 정밀 검토 및 코드 정밀 검토를 조합하면 제품 결함의 70~85% 이상을 제거
	- 정밀 검토는 오류가 발생하기 쉬운 클래스를 초기에 규명
- 정밀 검토에서의 역할
	- ***중재자***
		- 정밀 검토의 진행 속도를 생산적일 만큼 빠르고 가장 많은 오류를 찾을 수 있는 수준으로 느리게 유지하는 역할을 담당
		- 기술적으로 유능해야한다
		- 정밀 검토를 받고 있는 설계나 코드에 대한 전문가일 필요는 없다. 하지만 관련된 세부 사항을 이애할 수 있어야 한다
		- 검토될 설계, 코드의 분배, 정밀 검토 항목의 분배, 회의실 준비, 정밀 검토 결과 보고, 정밀 검토 회에서 진행된 지난 회의록 검토와 같은 정밀 검토의 다른 측면을 관리
	- ***작성자***
		- 설계나 코드가 분명하지 않은 것으로 밝혀지면 작성자에게 설계나 코드를 분명히 하기 위한 일이 할당됨
	- ***검토자***
		- 설계나 코드에 대해 직접적 관심이 있지만 작성자는 아닌 사람
		- 설계의 검토자는 설계를 구현할 개발자일 수 있다
		- 결함을 찾는 역할
	- ***서기***
		- 발견된 오류와 정밀 검토 회의 중에 있었던 조치 항목을 기록
		- 작성자나 중재자는 서기가 될 수 없다

	- ***관리자***
		- 정밀 검토에 관리자가 참여하는 것은 일반적으로 좋은 생각이 아니다
		- 소프트웨어 정밀 검토의 요점을 순수한 기술적 검토라는 것
		- 관리자는 정밀 검토의 결과를 알아야 할 권한이 있으며 관리자가 알 수 있도록 정밀 검토 보고서를 준비해야 한다
- 정밀 검토에는 적어도 세 명 이상의 참여자가 있어야 한다(6명 이하)
- 세 명보다 적으면 중재자, 작성자, 검토자가 겹치지 않게 있어야한다
- 정밀 검토의 일반적인 절차
	- ***계획***
		- 작성자가 설계나 코드를 중재자에게 전달
		- 중재자는 설계나 코드, 정밀 검토의 관심의 대상이 되는 체크리스트를 분배
	- ***개요***
		- 검토자는 프로젝트에 익숙하지 않을 때는 작성자가 설계나 코드가 작성된 기술적 환경을 1시간 정도 설명할 수 있다
		- 설계나 코드는 그 자체만으로 설명이 되어야하며, 개요가 그것을 설명해서는 안 된다
	- ***준비***
		- 각 검토자는 설계나 코드에 오류가 있는지를 정밀하게 조사하기 위해 혼자 일한다
		- 검토자는 검토 대상을 상기하고 파악하기 위해 체크리스트를 사용
		- 가장 효과적인 검토 비율은 매우 다양하기 때문에 환경에 따른 가장 효과적인 비율을 결정하기 위해 자신이 일하는 조직에서의 준비율을 기록
	- ***정밀 검토 회의***
		- 중재자는 설계를 설명하거나 코드를 읽기 위해 작성자 이외의 누군가를 선택
	        - 논리적인 구조의 세부 항목을 프레젠테이션하고, 서기는 오류를 발견하면 기록, 오류에 대한 논의는 오류로 인식하면 곧바로 기록 중지
	        - 서기는 오류의 유형과 심각성을 기록하고 정밀 검토를 계속 진행
	        - 설계나 코드를 검토하는 속도가 너무 빨라서도 너무 느려서도 안된다
- 너무 느리면 집중력이 떨어지고 회의가 비생산적이게 되고, 너무 빠르면 잡을 수 있는 오류를 지나칠 수 있다
- 회의 중에 해결책을 논의하지 않는다
	- 결함 식별에 초점
        - 일반적으로 회의는 2시간 넘게 지속하지 않아야한다
- ***정밀 검토 보고***
	- 정밀 검토 회의를 진행한 당일에 중재자는 결함의 유형과 정도를 포함한 결함 목록을 정리한 정밀 검토 보고서를 작성해야 한다
        - 정밀 검토 보고서는 모든 결함의 수정을 돕고 조직에 중요한 문제를 강조하는 체크리스트를 만드는 데 사용
        - 정밀 검토에 소요한 시간과 발견한 오류의 수를 기록해 둔다면 정밀 검토의 효험에 대한 질문에 적절하게 답할 수 있다
- ***재작업***
	- 중재자는 결함을 수정하기 위해 누군가(일반적으로 작성자)에게 할당
        - 결함을 할당받은 사람은 목록에 있는 결함을 해결
- ***후속 조치***
	- 중재자는 정밀 검토가 진행되는 중에 할당된 모든 수정 작업을 지켜볼 책임이 있다
- ***추가 회의***
	- 공식적인 정밀 검토가 끝나고 난 후 관심 있는 사람들이 해결책을 논의할 수 있도록 비공식적인 추가 회의를 열 수 있다
- ***정밀 검토의 정밀 조정***
	- 정밀 검토 시 특정한 종류의 오류가 다른 종류보다 더 빈번하게 발생한다
	- 이런 오류를 조심하도록 체크리스트를 만들면 검토자가 그것을 중점적으로 확인
- 정밀 검토에서의 자존심
	- 설계나 코드를 작성한 사람을 비판해서는 안된다
	- 정밀 검토는 작성자로 하여금 회의에 참석하느 ㄴ것이 프로그램을 개선할 수 있다는 확신을 줄 수 있어야 하고 참여한 모든 사람들에게 무언가를 배울 수 있는 경험이 되는 긍정적인 효과를 가져와야 한다
	- 작성자는 언급된 모든 결함을 인정하고 계속해서 진행해야 한다
	- 검토자는 결함에 대해 무엇을 할 지에 대해 최종 결정권이 작성자에게 있음을 기억해야 한다
- 정밀 검토 요약
![[codeComplete39.png]]
## 21.4 여러 가지 협력 개발 방법
- 워크스루(work-throughs)
	- 일반적으로 검토 중인 코드나 설계의 작성자에 의해 진행되고 조절된다
	- 기술적인 문제에 초점을 맞춘다. 워크스루는 업무 회의다
	- 모든 참석자는 설계나 코드를 읽고 오류를 찾음으로써 워크스루를 준비한다
	- 워크스루는 수석 개발자가 신입 개발자에게 자신의 경험과 협력 문화를 전달할 수 있는 기회다. 신입 개발자에게는 새로운 방법론을 제시하고 진부하고 더 이상 사용할 수 없는 가정에 이의를 제기할 수 있는 기회
	- 워크스루는 30~60분 동안 진행
	- 오류에 대한 수정이 아니라 발견을 중시한다
	- 경영진은 참여하지 않는다
	- 워크스루 개념은 유연하며 그것을 사용하는 조직의 요구에 맞게 수정될 수 있다
	- 워크스루로부터 어떤 결과를 기대할 수 있는가?
	        - 대규모의 검토 그룹을 갖고 있다면 검토 항목에 대해 다양한 관점을 가질 수 있기 때문에 워크스루가 좋은 방법
	        - 다른 조직에 있는 검토자가 참여하는 경우에도 워크스루가 좋을 수 있다
- 코드 읽기
	- 정밀 검토와 워크스루의 대안
	- 소스코드를 읽고 오류를 찾는다
	- 설계나 방식, 가독성, 유지보수 편의성, 효율성과 같이 코드의 질적인 측면에 대해 의견을 제시한다
	- 코드 읽기 진행 방법
		- 회의를 준비할 때 코드 작성자는 소스코드를 검토자에게 전달한다. 코드는 1000~ 10000만줄 사이. 보통 4000줄
		- 두 명 이상의 사람이 코드를 읽는다. 검토자끼리 경쟁을 유발하기 위해서 최소 두 명이 필요하다. 두 명 이상의 사람을 쓴다면 나머지 사람들이 얼마나 기여했는지 알 수 있도록 모든 사람의 기여도를 측정한다
		- 검토자는 코드를 개별적으로 읽는다. 하루에 약 1000줄 정도 평가한다
		- 검토자가 코드 읽기를 마쳤을 때 작성자에 의해 코드 읽기 회의가 주최된다. 회의는 한두 시간 정도 진행되고 검토자가 발견한 문제를 집중적으로 다룬다.
		- 코드의 작성자는 검토자가 규명한 문제를 수정한다
	- **개별적인 검토에 중점**
	- 각자 회의 시간의 일부에만 참여하고 대부분의 작업이 그룹을 중재하는 것이므로 회의로 보내는 시간이 줄어든다.
	- 검토자가 거리상 떨어져 있는 상황에서 특히 유용하다

- 데모(Dog-and-pony show)
	- 소프트웨어 제품을 고객에게 보여주는 검토
	- 제품의 기술적인 품질 개선을 위해 데모에 의존하지 않는다
	- 기술적인 품질 개선을 위해서는 정밀 검토나 워크스루, 코드 읽기에 의존
- 협력 구현 기법 비교
	![[codeComplete40.png]]
# 22장 개발자 테스트
- 테스트 수행 주체
	- 단위테스트는 한 명의 개발자나 팀이 작성한 클래스나 루틴, 작은 프로그램을 실행하는 것으로, 완성된 시스템과는 별개로 테스트한다
	- 컴포넌트 테스트는 여러 개발자나 개발팀이 참여하는 클래스, 패키지, 소형 프로그램, 다른 프로그램의 요소를 실행하는 것으로 , 더 완전한 시스템과 별개로 테스트한다
	- 통합 테스트는 여러 개발자나 개발팀이 만든 클래스나 패키지, 컴포넌트, 서브시스템을 두 개 이상 결합해 실행하는 것. 이와 같은 테스트는 클래스가 두 개가 되는 순간 시작해서 전체 시스템 개발이 완료될 때까지 지속적으로 수행
	- 회귀 테스트는 이전에 통과했던 테스트 집합을 가지고 소프트웨어에 있는 결함을 찾기 위해 이전에 실행했던 테스트 케이스를 반복하는 것
	- 시스템 테스트는 다른 소프트웨어와 하드웨어 시스템과의 통합을 포함한 최종 환경에서 소프트웨어를 실행하는 것. 이 테스트는 보안과 성능, 자원 손실, 시간 문제, 저수준 통합에서는 테스트할 수 없는 문제를 테스트한다
- 테스트
	- 블랙박스 테스트
	        - 테스터가 테스트하는 항목의 내부 동작을 볼 수 없는 테스트
	- 화이트박스 테스트
	        - 테스터가 테스트하는 항목의 내부 동작을 볼 수 있는 테스트
## 22.1 소프트웨어 품질에서 개발자 테스트의 역할
- 테스트가 개발자에게 어려운 활동인 이유
	- 테스트의 목표는 다른 개발 활동의 목표와 상반된다. 테스트의 목표는 오류를 찾는 것이다. 성공적인 테스트는 소프트웨어를 부수는 것이다. 다른 모든 개발 활동의 목표는 오류를 예방하고 소프트웨어가 부서지지 않도록 하는 것이다
	- 테스트가 오류가 없다는 것을 완벽하게 증명할 수는 없다. 오류가 없다는 것은 소프트웨어가 완벽하다는 의미일 수도 있지만, 그에 못지않게 테스트 케이스가 비효과적이고 불완전하다는 의미일 수도 있다
	- 테스트 자체는 소프트웨어의 품질을 향상시키지 않는다. 테스트 결과는 품질의 지표지만,그 자체로서 품질을 향상시키지는 않는다.
	- 테스트에는 코드에서 오류를 발견할 거라는 가정이 필요하다. 오류를 발견하지 못할 거라고 가정하면 아마 발견하지 못할 것이다.
- 일반적인 프로젝트에서 개발자 테스트에 얼마나 많은 시간을 보내야 하는가?
	- 전체의 50%
		- 테스트와 디버깅 시간을 합친 것
		- 일반적으로 걸리는 시간을 표현
		- 개발자 테스트 + 독자적인 테스트도 포함
- 개발자 테스트 결과로 무엇을 할 것인가?
	- 개발 중인 제품의 신뢰성 평가
	- 테스트 결과는 소프트웨어 수정 작업에 대한 가이드 역할
	- 오랜 시간 테스트를 통해 발견한 결함을 기록하면 가장 자주 발생하는 오류의 종류를 알아내는 데 도움이 된다
- 구현 중의 테스트
	- 클래스를 테스트할 때는 클래스를 클래스의 입/출력 뿐만 아니라 클래스의 내부 소스코드까지 볼 수 있는 글래스(Glass) 박스로 취급하는 것이 좋다. 상자 안에 무엇이 있는지 알면 클래스를 더 철저하게 테스트할 수 있다
	- 통합 전략이나 시스템 테스트 전략과 상관없이 다른 부분과 결합하기 전에 각 유닛을 철저하게 테스트해야 한다
	- 여러 개의 루틴을 작성하고 있다면 한 번에 하나씩 테스트해야 한다
	- 테스트의 문제는 테스트가 제대로 수행되지 않는 경우가 있다는 것에 있다. 개발자가 수백 개의 테스트를 수행해도 전체 코드의 일부만 테스트하기 때문
## 22.2 개발자 테스트에 대한 바람직한 접근 방법

>[!important] 💡 아무리 개발자 테스트가 훌륭하다고 하더라도 그것만으로는 적절한 품질 보증을 제공하기에 충분하지 않기 때문에 독립적인 테스트, 협력적인 구현 기법을 포함한 다른 기법으로 보완해야한다
- 개발자 테스트에 대한 체계적 접근 방법
	- 각 연관된 요구사항을 테스트해 요구사항이 구현되었는지 확인하라. 이 단계에 대한 테스트 케이스를 요구사항 단계나 가능한 한 일찍(되도록 테스트할 유닛을 작성하기 전에) 계획하라.
	- 요구사항에서 자주 빠뜨리는 사항에 대한 테스트를 고려하라. 보안 수준, 저장소, 설치 절차, 시스템 신뢰성이 테스트하기에 좋은 대상이며 요구사항 시점에서 간과되기 쉬운 것들이다
	- 각각 연관된 설계 사항이 구현되었는지를 보장하기 위해서 테스트하라. 설계 단계나 가능한 한 일찍(테스트할 루틴이나 클래스를 상세하게 작성하기 전) 이 단계의 테스트 케이스를 계획하라
	- 요구사항과 설계를 테스트하는 테스트 케이스에 상세 테스트 케이스를 추가하는 데 “기초 테스트”를 사용하라. 최소한 코드의 모든 줄을 테스트 해야한다
	- 현재 또는 이전 프로젝트에서 발견한 오류에 대한 체크리스트를 사용하라
- 테스트를 먼저 할 것인가, 나중에 할 것인가?
	- 테스트 케이스를 먼저 작성해야 하는 이유
		- 코드를 작성하기 전에 테스트 케이스를 작성해도 코드를 작성한 후 테스트 케이스를 작성하는 것보다 더 많은 노력이 들지는 않는다. 단순히 테스트 케이스 작성 작업의 순서를 재배치하는 것이다
		- 테스트 케이스를 먼저 작성하면 결함을 미리 발견하고 더 쉽게 수정할 수 있다
		- 테스트 케이스를 먼저 작성하면 코드를 작성하기 전에 요구사항과 설계에 대해 적어도 좀 더 생각하게 되며 그것이 더 좋은 코드를 만든다
		- 테스트 케이스를 먼저 작성하면 코드가 작성되기 전에 요구사항에 있는 문제를 미리 노출한다.요구사항이 잘못되어 있으면 테스트 케이스를 작성하기가 어렵기 때문이다
		- 수행해야 하는 테스트 케이스를 저장해 놓으면 처음뿐만 아니라 나중에도 테스트할 수 있다
- 개발자 테스트의 한계
	- ***개발자 테스트는 “깨끗한 테스트”가 되기 쉽다***
		- 코드가 깨지는 다양한 상황의 테스트(더러운 테스트)보다 코드가 작동하는지 보기 위해서 테스트(깨끗한 테스트)하는 경향이 있다
		- 더러운 테스트를 25배 더 해야한다
	- ***개발자 테스트는 테스트 커버리지를 낙관적으로 바라보는 경향이 있다***
	- ***개발자 테스트는 좀 더 정교한 테스트 커버리지를 건너뛰는 경향이 있다***
## 22.3 여러 가지 교묘한 테스트 방법
- 불완전한 테스트
	- 테스트 계획을 수립할 때 새로운 것을 말해주지 않는 테스트는 제거한다
	- 유사한 다른 데이터가 오류를 생산하지 않을 때 오류를 내지 않을 것 같은 새로운 데이터에 대한 테스트를 제거한다
- 구조적인 기초 테스트
	- 프로그램에 있는 각 명령문을 적어도 한 번은 테스트해야한다
	- 프로그램의 실행 경로의 수를 계산해 프로그램의 각 경로를 살펴볼 수 있는 최소한의 테스트 케이스를 개발하는 것
- 기초 테스트에 필요한 최소 케이스의 수를 계산하는 방법
	- 루틴의 직선 경로에 대해 1로 시작
	- if, while, repeat, for, and, or또는 이와 동등한 키워드에 대해서 1을 더한다
	- case 문에서 각 케이스마다 1을 더한다
- 데이터 흐름 테스트
	- 데이터 사용이 적어도 제어 흐름만큼 오류를 유발할 수 있다는 개념에 기반
	- 데이터의 상태
		- 정의 : 데이터는 초기화 되었지만, 아직 사용되지 않았다
		- 사용 : 데이터가 루틴의 인자로서 계산되거나 다른 무언가를 위해서 사용되었다
		- 삭제: 데이터가 정의되었지만 어떤 방식으로 정의가 해제되었다.
        - 들어감 : 제어 흐름이 변수가 사용되기 바로 전에 루틴이 들어간다. 예를 들면 작업 변수가 루틴의 앞부분에서 초기화된다
        - 빠져나옴 : 제어 흐름이 변수가 사용되고 나서 바로 다음에 루틴을 떠난다. 예를 들면 리턴 값이 루틴의 끝에서 상태 변수에 할당된다
- 데이터 상태의 조합
	- 정의-정의 : 값이 유지되기 전에 한 변수를 두 번 정의해야 한다면 더 나은 프로그램이 아니라 더 좋은 컴퓨터가 필요하다. 이것은 실제로 잘못되지 않았더라도 불필요하고 오류를 유발할 가능성이 있다
	- 정의-빠져나옴 : 변수가 지역변수라면 정의한 다음 사용하지 않고 빠져나오는 것은 이치에 맞지 않는다. 루틴 매개변수나 전역 변수라면 문제는 없었을 것이다
	- 정의-삭제 : 변수를 정의한 다음 삭제한다는 것은 변수가 불필요하거나 변수를 사용하기로 되어 있던 코드가 빠져있다는 것을 의미한다
	- 들어감-삭제 : 해당 변수가 지역 변수 일때 문제가 된다. 정의되거나 사용되지 않았다면 삭제될 필요가 없을 것이다. 반면에 루틴 매개변수나 전역 변수인 경우에는 변수가 삭제되기 전에 다른 곳에서 정의되었으면 문제가 없다
	- 들어감-사용 : 이번에도 해당 변수가 지역 변수일 때 문제가 된다. 변수는 사용되기 전에 정의되어야 한다. 반면에 루틴 매개변수는 전역 변수인 경우에는 변수가 사용되기 전에 다른 곳에서 정의되었다면 문제가 없다
	- 삭제-삭제 : 변수가 두 번 삭제되어서는 안된다.
	- 삭제- 사용 : 삭제된 변수를 사용하는 것은 논리적 오류이다
	- 사용-정의 : 변수를 사용하고 나서 정의하는 것은 해당 변수가 사용되기 전에 정의되었는지에 따라 문제가 될 수도 있고 아닐 수도 있다
	- 모든 정의 : 모든 변수의 모든 정의를 테스트한다. 즉, 변수가 값을 받는 모든 곳에서 테스트한다. 모든 소스코드를 조사하려고 하면 이 작업을 기본적으로 수행해야 하므로 이는 강력한 전략이 아니다
	- 모든 정의-사용 조합 : 변수를 정의하고 다른 곳에서 사용하는 모든 조합을 테스트한다. 이는 모든 코드를 실행하는 것만으로는 모든 정의-사용 조합이 테스트된다는 것을 보장하지 못하기 때문에 모든 정의를 테스트하는 것보다 강력한 전략이다
- 등가 분할
	- 서로 다른 테스트 케이스가 정확하게 같은 오류를 제거한다면 그 하나만 남기면 된다
- 오류 추측
	- 프로그램이 오류를 가지고 있을 것 같은 위치를 추측해 테스트 케이스를 작성하는 것
- 경계 분석
	- 경계 조건을 조사하는 테스트 케이스를 작성하는 것
- 복합 경계
	- 나쁜 데이터
		- 너무 적은 데이터
		- 너무 많은 데이터
		- 틀린 종류의 데이터
		- 잘못된 크기의 데이터
		- 초기화되지 않은 데이터
	- 좋은 데이터
		- 명목상 케이스, 일반적이고 예상된 값
		- 최소한의 정상적인 구성
		- 최대한의 정상적인 구성
	        - 예상된 값의 집합으로부터 최댓값의 집합
	- 이전 데이터와의 호환성
		- 프로그램이나 루틴이 이전 프로그램이나 루틴을 대체할 때 필요
- 수동 점검이 편리한 테스트 케이스를 사용하라
- 직접 계산하기 편한 테스트 케이스를 사용하라
## 22.4 전형적인 오류
- 어떤 클래스가 가장 많은 오류를 포함하고 있는가?
	- 오류와 코드 사이의 일반적인 관계
		- 오류의 80%는 프로젝트 클래스나 루틴의 20%에서 발견된다
		- 오류의 50%는 프로젝트 클래스의 5%에서 발견된다
	- 프로젝트 루틴의 20%가 개발 비용의 80%를 차지한다.
	- 결함이 많은 루틴은 매우 비싸다
	- 개발 비용이 높은 루틴을 수정하는 것이 개발 일정을 향상시키고 개발 비용을 줄인다
	- 유지보수 활동은 오류가 있는 것으로 알려진 루틴을 식별하고 재설계하며 다시 작성하는 데 초점을 맞춰야한다
- 오류의 분류
	- ***대부분의 오류가 발생하는 범위는 상당히 제한되어 있다***
	- ***많은 오류가 구현 범위 밖에 있다***
        - 가장 일반적인 오류의 세 가지 원인이 응용 프로그램 도메인에 대한 빈약한 지식, 요구사항의 변동과 모순, 의사소통과 협동의 실패하는 것
	- ***대부분의 구현 오류는 프로그램의 잘못이다***
	- ***오타는 뜻밖에 많이 발생하는 문제다***
	- ***설계를 잘못 이해하는 것은 프로그램의 오류에 대한 연구에서 계속해서 나타나는 주제다***
	- ***대부분의 오류는 수정하기 쉽다***
	- ***자신이 속한 조직의 오류에 대한 경험을 측정하는 것은 좋은 생각이다***
- 결점이 있는 구현으로부터 발생하는 오류 비율
	- 작은 프로젝트에서는 구현 결함이 모든 오류의 상당 부분을 차지한다
	- 구현 결함은 프로젝트 크기에 상관없이 전체 결함의 최소 35%를 차지한다
	- 구현 오류가 요구사항이나 설계 오류보다는 싸겠지만, 그래도 여전히 비싸다
- 얼마나 많은 오류를 발견할 것으로 예상해야 할까?
	- 업계의 평균적인 경험으로는 출시된 소프트웨어에 1000줄당 약 1개에서 25개의 오류가 존재한다
	- 품질이 떨어지는 소프트웨어를 개발해 수정하는 비용보다 고급 소프트웨어를 개발하는 데 드는 비용이 더 싸다
- 테스트 자체의 오류
	- 테스트 케이스는 신중한 설계와 구현 프로세스를 거치기보다 즉각적으로 만들어지기 쉽다. 그리고 종종 한 번만 테스트하고 버리는 것을 만드는 정도의 노력만 들여 개발한다
	- 테스트 케이스의 오류를 줄이는 방법
		- ***작업을 점검하라 - 코드를 개발하는 것처럼 테스트 케이스를 주의 깊게 개발하라***
		- ***소프트웨어 개발할 때 테스트 케이스를 계획하라***
		- ***테스트 케이스를 유지하라***
		- ***단위 테스트를 테스트 프레임워크에 연결하라***
		- 통합된 테스트 프레임워크를 통해 테스트 케이스가 버려지는 경향을 예방
## 22.5 테스트 지원 도구
- 개별 클래스를 테스트하는 비계 구축
	- 소프트웨어 비계(scaffolding)은 코드를 쉽게 조사하게 하는 것이 유일한 목적
	- 테스트되고 다른 클래스가 사용할 수 있게 아무것도 하지 않는 클래스를 목 객체, 스텁 객체라고 한다
	- 목 객체나 스텁 루틴을 조절 하는 방법
		- 아무것도 하지 않고 제어를 곧바로 리턴
		- 입력된 데이터를 테스트
		- 진단 메시지를 출력하고 입력 매개변수를 출력하거나 메시지를 파일에 기록
		- 대화식 입력으로부터 리턴 값을 얻는다
		- 입력에 상관없이 표준 결과를 리턴
		- 실제 객체나 루틴이 실행되는 것처럼 시간을 지연시킨다
		- 실제 객체나 루틴에 비해 느리거나 크거나 단순하거나 덜 정확한 버전의 기능을 수행한다
	- 드라이버, 테스트 장비가 하는 일
		- 정해진 입력의 집합으로 객체를 호출한다
		- 대화식 입력을 받아서 그 값으로 객체를 호출한다
		- 명령줄에서 인자를 받아서 객체를 호출한다
		- 파일에서 인자를 읽어 객체를 호출한다
		- 미리 정의한 입력 데이터 집합으로 여러 번 객체를 호출한다
	- 더미 파일
		- 작은 더미 파일의 장점
			- 크기가 작아 정확한 내요을 알 수 있고 파일 자체에 오류가 없다는 것을 확인할 수 있다
			- 테스트를 위해 특별하게 생성했기 때문에 사용하고 있는 오류를 알아보기 쉽게 내요을 설계할 수 있다
- 차이 분석 도구
	- 결과를 파일로 보낸 다음 예상 결과와 이전에 파일로 보낸 새로운 결과를 비교하기 위한 diff와 같은 파일 비교 도구 사용하기
- 테스트 데이터 생성기
	- 적절하게 설계된 임의의 데이터생성기는 생각치 못한 특이한 테스트 데이터의 조합을 생성할 수 있다
	- 임의의 데이터 생성기는 개발자가 할 수 있는 것보다 훨씬 철저하게 프로그램을 조사할 수 있다
	- 임의로 생성된 테스트 케이스가 현실적인 입력의 범위를 강조할 수 있도록 개량할 수 있다
	- 테스트하는 코드가 변경된다면 테스트 드라이버를 재사용할 수 있다
- 커버리지 모니터
	- 조사하고 있는 코드와 그렇지 않은 코드를 추적하는 도구
	- 커버리지 모니터는 테스트 케이스가 코드를 완전하게 조사하는지를 말해주기 때문에 체계적인 테스트에 특히 유용하다
- 데이터 기록/로깅
	- 중요한 이벤트를 파일에 기록함으로써 자신만의 데이터 레코더를 구축
	- 오류가 발생 전 시스템 상태와 오류가 발생한 정확한 상황에 대한 세부적인 상황 기록
- 심볼릭 디버거
	- 코드를 검토하고 정밀 검사하기 위한 기술적 도구
	- 디버거는 줄 단위로 살펴보고 변수의 이름을 추적하고 언제나 컴퓨터가 코드를 해석하는 방식과 같은 방법으로 해석하는 능력
- 시스템 교란기
	- 메모리 채우기
		- 초기화되지 않은 변수가 없다는 것을 확인하고 싶을 때 사용
	- 메모리 섞기
	        - 작업 시스템에서는 어떤 도구가 프로그램이 작동할 때 메모리를 재배치하여 상대적인 위치가 아닌 절대적인 위치에 있는 데이터 의존 코드가 작성되지 않게 해준다
- 선택적 메모리 실패
	- 메모리 드라이버가 부족해 메모리 요청에 실패하거나 실패하기 전에 임의의 횟수만큼 메모리 요청을 허용하거나 메모리 요청을 한 번 허용하기 전에 임의의 횟수만큼 요청에 실패하도록 메모리가 부족한 상황을 훙내낼 수 있다
- 메모리 접근 검사(경계 검사)
	- 포인터가 제대로 작동하도록 보장하기 위해서 포인터 연산을 감시
	- 초기화되지 않거나 허상 포인터를 감지하는 데 유용함
- 오류 데이터베이스
	- 바로 발생하는 오류를 검사하고 새로운 오류가 발견되고 수집되는 비율을 추적하고 열린 오류와 닫힌 오류의 상태와 심각도를 추적
## 22.6 테스트를 향상시키는 방법
- 테스트 계획 세우기
	- 반복적으로 수행 가능한 테스트 프로세스를 만드는 요소
	- 테스트를 반복적으로 할 수 없다면 향상시킬 수도 없다
- 다시 테스트하기(회귀 테스트)
	- 변경으로 인해 새로운 오류가 발생하지 않았다는 것을 확인하기 위해 테스트가 소프트웨어가 이전 상태로 돌아가지 않았는데 확인하는 테스트
- 자동 테스트
	- 테스트 자동화의 이점
		- 자동 테스트는 수동 테스트보다 잘못될 확률이 낮다
		- 테스트를 자동화하면 거의 아무런 노력을 들이지 않고 프로젝트의 나머지 부분에서 사용할 수 있다
		- 테스트가 자동화되면 코드를 체크인할 때 기존 코드에 어떤 영향을 주는지 살펴보기 위해 자주 실행할 수 있다. 테스트 자동화는 일일 빌드, 스모크 테스트, 익스트림 프로그래밍과 같이 테스트 집약적인 기법의 바탕을 이룸
		- 주어진 문제를 가능한 한 초기에 발견할 수 있도록 해주며, 이는 문제의 원인을 규명하고 수정하는 데 필요한 작업을 최소화하는 경향이 있다
		- 자동 테스트는 수정 중에 입력된 결함을 빠르게 발견할 가능성을 높여줘, 큰 규모의 변경을 위한 안전망을 제공
		- 자동 테스트를 새롭고 변하기 쉬운 기술 환경에서 특히 유용
## 22.7 테스트 기록을 보존하는 방법
- 프로젝트를 측정하기 위해 수집할 수 있는 데이터 종류
	- 결함에 대한 관리상의 설명(보고된 날짜, 보고한 사람, 제목, 설명, 빌드 번호, 수정된 날짜)
	- 문제에 대한 자세한 설명
	- 문제를 반복하기 위해 거치는 단계
	- 문제에 대해 제안된 해결책
	- 관련된 결함
	- 문제의 심각성
	- 결함의 원인, 요구사항, 설계 코드 작성, 테스트
	- 코드 작성 결함의 하위 분류
	- 수정 때문에 변경된 클래스와 루틴
	- 결함에 의해 영향을 받는 코드의 줄 번호
	- 결함을 찾는 데 걸린 시간
	- 결함을 수정하는 데 걸린 시간
- 개인 테스트 기록
	- 개인별로 테스트 기록을 유지하는 것이 유용하다
## 체크리스트 : 테스트 케이스
![[codeComplete41.png]]
# 23장 디버깅
## 23.1 디버깅 이슈 소개
- 소프트웨어 품질에서 디버깅의 역할
	- 디버깅은 본질적으로 소프트웨어의 품질을 향상시키는 방법이 아니라 결함을 진단하는 방법
	- **디버깅은 최후의 수단**
- 디버깅 성과의 차이
	- 디버깅은 통찰력을 제공할 뿐만아니라 품질을 향상시키는 것은 개발 비용을 줄이는 것
- 기회로서의 결함
	- 시행착오를 통해 프로그래밍하면 반드시 결함이 생긴다. 결함을 수정하는 방법을 배울 게 아니라 애초에 결함을 피하는 방법을 배워야한다
	- ***개발 중인 프로그램에 관해 배울 수 있다***
		- 프로그램에 결함이 있다면 거기에서 무언가를 배울 수 있다. 프로그램에 대해 완벽하게 알고 있다면 이미 프로그램에 있는 결함을 고쳐서 결함이 없을 것이기 때문이다

- ***자신이 저지른 실수에 관해 배울 수 있다***
	- 언제나 자신의 약점이 이렇게 눈에 띄게 노출되지는 않으니 그런 날을 기회로 삼고 잘 활용해야한다
	- 실수를 발견하면 자신에게 왜 그리고 어떻게 이런 실수를 저질렀는지 물어야 한다
- ***자신의 코드를 읽어야 하는 사람의 관점으로부터 코드 품질에 관해 배울 수 있다***
	- 결함을 찾으려면 코드를 읽어봐야 한다. 이것은 자신이 작성한 코드의 품질을 비판적으로 볼 수 있는 기회가
	- 가독성, 코드 품질 향상에 이용하라
- ***문제를 해결하는 방법을 배울 수 있다***
	- 디버깅 문제를 해결하기 위한 접근 방법에 확신이 드는가? 접근 방법이 효과가 있는가
	- 디버깅하는 방법을 분석하고 변경하는 시간을 갖는 것이 프로그램을 개발할 때 드는 전체 시간을 줄이는 가장 빠른 방법일 수도 있다
- ***결함을 수정하는 방법을 배울 수 있다***
- 비효과적인 접근 방법
	- 디버깅에 대한 악마의 지침
		- ***추측으로 결함을 찾아라***
		- ***문제를 이해하는 데 시간을 쓰지 말아라***
	- 그냥 문제를 찾는 것으로도 충분하다
        - ***가장 명백한 수정으로 오류를 수정해라***
		- 일반적으로 전체 프로그램에 영향을 미치는 크고 원대한 작업을 하는데 많은 시간을 낭비하는 것보다는 발견한 특정 문제를 수정하는 것이 좋다
	- 미신을 따르는 디버깅
		- 프로그램에 문제가 있다면 그것은 작성자의 잘못이지 컴퓨터나 컴파일러의 잘못이 아니다. 작성한 사람이 프로그램을 책임져야 한다
		- **오류가 처음에는 자신의 잘못이 아닌 것처럼 보여도 자신의 잘못일 거라고 가정하는 것이 매우 중요하다. 그러한 가정이 디버깅에 도움이 된다**
## 23.2 결함 발견
- 과학적인 디버깅 방법
	- 과학적인 방법을 사용하는 단계
		- 반복적인 실험을 통해 데이터를 수집
		- 관련 자료를 설명하기 위한 가설 세우기
		- 가설을 증명하거나 반증하기 위한 실험 구상
		- 가설을 증명하거나 반증
		- 필요한 만큼 반복
- 결함을 찾는 효과적인 접근 방법
	- 오류 재현
	- 오류의 원인 찾기
		- 결함을 만들어내는 데이터 수집
		- 수집한 데이터를 분석하고 결함에 대한 가설 설정
		- 프로그램을 테스트하거나 코드를 살펴봄으로써 가설을 증명하거나 반증할 방법 결정
		- 이미 규명한 절차를 사용해 가설을 증명하거나 반증
	- 결함 수정
	- 수정 내용을 테스트
	- 유사한 오류를 발견하기
	- 오류를 재현하라
		- 예측할 수 있게 발생하지 않는 오류는 일반적으로 초기화 오류나 시간 문제, 허상 포인터 문제
		- 테스트 케이스 단순화의 목표는 테스트 케이스를 변경하면 오류의 행위가 변경되도록 간단하게 만드는 것
		- 테스트 케이스를 주의 깊게 변경해 프로그램의 행위를 관찰함으로써 문제 진단 가능
		- 테스트 케이스의 단순화를 위해 과학적 방법 사용
	- 오류 발생시키는 것과 관련이 없는 요소가 무엇인지 가설 설정
		- 여전히 오류가 발생한다면 그 요소를 제거하고 테스트 케이스를 단순화
		- 테스트 케이스 단순화를 반복
	- 오류의 원인을 찾아라
		- 결함이 하나 차이로 인한 오류와 같이 특정한 문제인지 확인
		- 문제를 유발하는 것으로 의심이 드는 매개변수를 경계의 아래쪽, 경계 내, 경계 위쪽으로 변경해보고 가설이 옳은지 결정
- 결함을 찾는 데 도움이 되는 팁
	- ***가설을 세우기 위해서 사용할 수 있는 모든 데이터를 사용하라***
		- 결함의 원인에 대한 가설을 세울 때 가설에서 가능한 한 많은 데이터를 설명
	- ***오류를 만드는 테스트 케이스를 개선하라***
		- 오류의 원인을 찾을 수 없다면 기존에 가지고 있던 테스트 케이스를 개선해본다
	- ***단위 테스트에서 코드를 다루어라***
		- 결함은 통합된 큰 프로그램에서보다 작은 규모의 코드에서 더 쉽게 찾을 수 있다
	        - 단위 테스트를 사용해 코드를 고립된 환경에서 테스트한다
	- ***도구를 사용하라***
		- 대화식 디버거, 까다로운 컴파일러, 메모리 검사기, 구문 인식 편집기 등 디버깅 세션을 지원하는 도구를 사용하라

	- ***여러 가지 방법으로 오류를 발생시켜라***
		- 때로는 오류를 만드는 경우와 유사하지만 정확하게 같지는 않은 경우를 시도해 보는 것이 도움이 된다
	- ***더 많은 가설을 세우기 위해서 더 많은 데이터를 만들어라***
		- 이미 오류가 있는지 알고 있는 테스트 케이스와 다른 테스트 케이스를 선택한다

	- ***부정적 테스트의 결과를 사용하라***
		- 결함이 생각했던 영역에 있지 않다는 사실을 부정적 테스트를 통해 알게 된다.
		- 그러한 방법으로 찾아야 할 부분과 가능한 가설의 폭을 좁힌다

	- ***가능한 가설에 대해 브레인스토밍하라***
		- 첫 번째 가설에 자신을 국한하지 말고 여러가지 가설을 떠올려본다
		- 처음에는 분석하지 말고 몇 분 동안 가설을 마음껏 떠올려본 후 각 가설을 살펴보고 가설을 검증하고 부정하는 테스트 케이스를 생각해본다
	- ***연습장을 준비해서 시도해 볼 목록을 만들어라***
		- 시도해 볼 목록을 만들어 한 가지 접근 방법이 안 되면 다음 접근 방법으로 넘어간다

	- ***의심스러운 코드 영역을 좁혀라***
		- 전체 프로그램이나 클래스, 루틴을 테스트하고 있다면 그 대신에 더 작은 부분을 테스트 한다
		- 체계적으로 프로그램을 부분적으로 제거하면서 오류가 계속 발생하는 지 확인해보기
		- 이진 탐색
			- 코드 절반을 제거
			- 결함이 있는 절반을 결정하고 다시 나누고를 반복
	- ***이전에 결함이 있었던 클래스와 루틴을 의심하라***
		- 이전에 결함이 있었던 클래스는 계속해서 결함을 갖기 쉽다
	- ***최근에 변경한 코드를 검사하라***
	- ***의심스러운 코드 영역을 확장하라***
		- 자신이 의심하고 있는 영역을 확장하고 앞에서 설명한 이진 탐색 기법을 사용해 특정 부분에 집중하자
	- ***점진적으로 통합하라***
		- 시스템에 한 번에 한 부분만 추가한다면 디버깅이 쉬워진다
		- 시스템에 한 부분을 추가했을 때 새로운 오류가 발생한다면 해당 부분을 제거해 별도로 테스트
	- ***일반적인 결함을 검사한다***
		- 가능한 결함을 생각하는 데 도움을 얻기 위해 코드 품질 체크리스트를 사용한다
	- ***프로그램에 대해 다른 사람과 이야기를 나누어라***
		- 종종 다른 사람에게 결함을 설명해주는 과정에서 결함을 발견한다
	- ***문제로부터 떨어져 휴식을 취하라***
	- 무차별 대입을 통한 디버깅
		- 망가진 코드에 대해 전체적인 설계와 코드 검토를 수행
		- 문제가 발생한 코드 섹션을 버리고 처음부터 새로 설계하거나 새로 작성
		- 전체 프로그램을 버리고 처음부터 새로 설계하거나 새로 작성
		- 완전한 디버깅 정보를 이용해 코드를 컴파일
		- 코드를 가장 까다로운 경고 수준으로 컴파일하고 까다로운 컴파일러 경고를 모두 수정
		- 단위 테스트를 이용해 새로운 코드를 고립된 환경에서 테스트
		- 자동화된 테스트 도구를 작성해 밤새 실행
		- 오류 상황을 만날 때까지 디버거에서 큰 반복문을 직접 하나씩 실행
		- 코드에 프린트나 화면 출력, 다른 로깅 명령문을 추가
		- 다른 컴파일러로 컴파일
		- 다른 환경에서 프로그램을 컴파일하고 실행
		- 코드가 부정확하게 사용되었을 때 경고를 생성하는 특별한 라이브러리나 실행 환경에 코드를 링크하거나 실행
		- 사용자와 같은 컴퓨터 환경을 구성
		- 새로운 코드를 작은 부분에 통합하고 통합할 때 각 부분을 완전하게 테스트
		- 빠르고 지저분한 디버깅에 대한 최대 시간을 설정하라
			- 작성하는 데 30분밖에 안 걸린 코드를 두 시간 동안 디버깅한 경험이 얼마나 자주 있는가? 이는 일을 잘못 분배한 것이고 이런 나쁜 코드를 디버깅하는 것보다 코드를 다시 작성하는 편이 낫다
		- 짧은 시간에 문제를 해결하는 방법을 선택했다면 그 방법에 대해 최대 제한 시간을 정한다
		- ***무차별 대입 기법에 대한 목록을 작성하라***
			- 어려운 오류를 디버깅하기 전에 “ 이 문제를 디버깅하다가 막혀버리면 문제를 해결할 수 있는 다른 방법이 있을까?” 라고 자신에게 물어보도록 하라
- 구문 오류
	- ***컴파일러 메시지에 있는 줄 번호를 믿지 말라***
		- **진짜 결함을 찾으려면 컴파일러가 잘못된 명령문에 대한 메시지를 보고한 이유를 생각해본다**
	- ***컴파일러의 오류 메시지를 믿지 말라***
		- 컴파일러는 무엇이 잘못되었는지 정확하게 말해주려 하지만 종종 메시지가 실제로 무엇을 의미하는지 파악하기 위해 행간을 읽어야 할 때가 있다
	- ***컴파일러의 두 번째 오류 메시지를 믿지 말라***
		- 컴파일러가 연속적으로 오류 메시지를 만들어낼 때 두 번째나 세 번째 오류 메시지의 원인을 빨리 찾지 못한다고 걱정하지 마라
		- 첫 번째 오류를 수정하고 다시 컴파일 하라
	- ***분할 정복하라***
		- 귀찮은 구문 오류가 있다면 코드의 일부를 제거하고 다시 컴파일
	- ***잘못된 주석과 인용 부호(따옴표)를 찾아라***
		- 더 원시적인 환경에서는 잘못된 주석이나 인용 부호로 인해 컴파일러가 실수할 수 있다
## 23.3 결함 수정
- 결함 수정 시 오류의 발생 가능성을 줄이는 지침
	- ***수정하기 전에 문제를 이해하라***
		- 문제를 이해하지 않고 수정하는 것이 삶을 고달프게하고 프로그램의 품질을 떨어뜨리는 가장 좋은 방법
		- 문제를 수정하기 전에 핵심을 이해하라
	- ***문제만 이해하지 말고 프로그램을 이해하라***
		- 문제가 발생한 상황을 이해한다면 문제의 한 측면만이 아니라 전체를 완벽하게 해결할 수 있다
	- ***결함 분석을 확인하라***
		- 결함을 수정하기 전에 문제를 정확하게 분석한다
		- 자신의 가설을 증명하고 다른 가설을 부정하는 테스트 케이스를 실행해 보는 시간을 갖는다
	- ***긴장을 풀어라***
		- 자신의 해결책이 맞다는 것을 확인하기 위해서 휴식을 취하라

	- ***원본 소스코드를 저장하라***
		- 결함을 수정하기 전에 나중에 현 상태로 돌아올 수 있도록 현재 작업 중인 코드를 저장해야 한다

	- ***증상이 아니라 문제를 해결하라***
		- 증상도 해결해야 한다. 하지만 문제를 임시로 코드로 막는 것보다는 근본적인 문제를 해결하는 데 집중해야 한다
	- ***타당한 이유가 있을 때만 코드를 변경하라***
		- 증상 수정과 관련해 작동하는 것처럼 보일 때까지 임의로 코드를 변경하는 기법이 있다
		- 코드를 변경하기 전에 작동할 것이라는 확신이 있어야 한다
	- ***한 번에 한 가지만 변경하라***
		- 변경은 한 번에 하나만 수행되어야 할 정도로 신중히 해야한다
		- 단순하게, 한 번에 한 가지만 변경한다
	- ***수정한 내용을 검사하라***
		- 자신이 프로그램을 검사하거나 다른 동료가 검사하게 하거나 다른 사람과 함께 검토한다
    - ***결함을 노출하는 단위 테스트를 추가하라***
    - ***유사한 결함을 찾아라***
		- 결함 하나를 찾았을 때 그와 유사한 다른 결함을 찾아본다
		- 결함은 그룹으로 발생하는 경향이 있으므로 결함의 종류에 주의를 기울인다면 그와 같은 종류의 모든 결함을 수정할 수 있다
## 23.4 디버깅에서 심리학적으로 고려해야 할 사항
- 심리적 고착이 디버깅 실명에 미치는 영향
	- 좋은 프로그래밍 습관의 중요성
		- 좋은 형식화, 주석 작성, 변수 이름, 루틴 이름을 비롯한 프로그래밍 상식의 다른 요소가 결함을 보이도록 하는 프로그램의 바탕을 구성하는 데 도움을 준다
- 오류를 발견했을 때 프로그램에서 조사할 부분을 선택
	- 가장 효과적으로 디버깅하는 개발자들은 마음속으로 디버깅과 관련이 없는 부분을 제거한다
- “심리적인 거리”가 어떻게 도움을 줄 수 있는가?
	- 디버깅할 때는 유사한 변수 이름과 루틴 이름 사이의 심리적인 거리가 충분하지 않아서 발생하는 문제에 대해 마음의 준비를 해야 한다
## 23.5 디버깅 도구 - 분명한 도구와 그렇지 않은 도구
- 소스코드 비교 도구
	- Diff와 같은 소스코드 비교 도구는 오류에 대해 프로그램을 수정하고 있을 때 유용
- 컴파일러 경고 메시지
	- 컴파일러를 작성한 사람들이 자신보다 프로그래밍 언어에 대해 훨씬 많이 알고 있다고 가정하라
	- 컴파일러를 작성한 사람들이 자신보다 프로그래밍 언어에 대해 훨씬 많이 알고 있다고 가정하라
	- **컴파일러의 경고 수준을 가장 높고 까다로운 수준으로 설정한 다음, 컴파일러가 보고하는 오류를 수정하라**
	- ***경고를 오류로 취급하라***
	- ***컴파일 시간 설정에 대해 프로젝트 전반적인 표준을 제안하라***
        - 팀에 있는 모든 사람이 같은 컴파일러 설정을 사용해 코드를 컴파일할 수 있도록 표준을 정하라
- 확장된 문법과 논리 검사
	- 컴파일러보다 코드를 완벽하게 검사하는 추가적인 도구를 사용
- 실행 프로파일러
	- 프로그램 프로파일러를 몇 분 동안만 학습하면 몇 가지 놀라운(숨겨진)  결함을 발견할 수 있다
- 테스트 프레임워크/비계
	- 테스트 코드를 실행하는 것이 오류를 유발할 수 있는 프로그램에서 버그를 몰아내는 가장 효과적인 방법일 때가 있다
- 디버거
	- 훌륭한 디버거를 이용하면 구조적인 데이터와 동적으로 할당된 데이터를 포함한 데이터들을 완벽하게 조사할 수 있다
	- 가장 좋은 디버거는 디버깅되고 있는 프로그램에 대한 디버깅 요소(중단점, 조사 중인 변수 등)를 기억하고 있으므로 그 요소를 매번 생성할 필요가 없다
	- 시스템 디버거는 시간이나 잔여 메모리에 민감한 프로그램을 디버깅할 때 꼭 필요하다
	- 머리로 생각하고 디버거를 사용하는 것이 가장 효과적

## 체크리스트
![[codeComplete42.png]]
![[codeComplete43.png]]
# 24장 리팩터링
## 24.1 소프트웨어 진화의 종류
- 소프트웨어 진화의 철학
	- 소프트웨어 진화에 대한 개발자들의 접근 방법이 공통으로 갖는 약점은 진화가 무의식적으로 일어난다는 점 ⇒ 개발 중 진화는 불가피하고 중요한 현상이므로 그에 대한 계획을 세우라
	- 진화는 위험과 동신에 완벽함에 도달할 수 있는 기회
	- 코드를 변경해야 할 때 나중에 쉽게 변경할 수 있도록 향상시키려고 노력해야 한다
## 24.2 리팩터링 소개

>[!important] 💡 리팩터링 : 소프트웨어를 더 쉽게 이해하고 적은 비용으로 수정할 수 있도록 외부 동작의 변화 없이 내부 구조를 변경하는 것
- 리팩터링하는 이유
	- ***코드가 중복되어 있다***
		- 중복된 코드는 거의 처음부터 설계를 완전히 나누는 데 실패했다는 것을 의미
		- DRY(Don’t Repeat Yourself) 위반
	- ***루틴이 너무 길다***
		- 시스템을 개선하기 위한 한 가지 방법은 모듈화를 늘리는 것 ⇒ 한 가지 기능만 잘 처리하는 잘 정의되고 이름이 좋은 루틴의 수를 늘리는 것
	- ***루프가 너무 길거나 깊이 중첩되어 있다***
	- ***클래스의 응집력이 약하다***
	- ***클래스 인터페이스가 일관적인 추상화 수준을 제공하지 않는다***
	- ***매개변수가 너무 많다***
		- 잘 분리된 프로그램은 큰 매개변수 목록이 필요 없는 작고 잘 정의된 루틴 여러 개를 갖는 경향이 있다
	- ***클래스 내의 변경 사항이 상호 관계를 고려하지 않고 구분되는 경향이 있다***
		- 한 클래스가 두 개 이상의 분명한 책임을 지는 경우도 있다
		- 이는 클래스를 책임별로 여러 개로 나누어야 한다는 신호
	- ***변경할 때 여러 개의 클래스를 동시에 수정해야 한다***
	- ***상속 계층 구조가 병렬로 변경되어야 한다***
		- 한 클래스의 서브클래스를 만들 때마다 다른 클래스의 서브 클래스를 만드는 것은 특별한 종류의 병렬 수정이며 반드시 해결되어야 한다
	- ***CASE 문이 병렬로 변경되어야 한다***
		- 프로그램 여러 곳에서 유사한 CASE문을 병렬로 수정하고 있다면 상속이 더 좋은 접근 방법이 아닌지 물어야한다
	- ***함께 사용하는 연관된 데이터 항목이 클래스로 구성되지 않았다***
	- ***루틴이 자신이 포함된 클래스보다 다른 클래스의 기능을 더 많이 사용한다***
		- 이럴 때는 해당 루틴을 다른 클래스로 옮기고 이전 클래스로 호출해야한다
	- ***클래스가 많은 일을 수행하지 않는다***
		- 클래스가 중요하지 않은 것처럼 보인다면 해당 클래스의 책임을 다른 클래스에 넘기고 그 클래스를 삭제하는 것이 좋은지 물어본다
	- ***일련의 루틴이 뜨내기 데이터를 전달한다***
		- 데이터를 전달하는 루틴이 단순히 다른 루틴으로 데이터를 전달하는 역할만 할 때 그 데이터를 뜨내기 데이터라고 한다
	- ***중개 역할을 하는 객체가 아무것도 하지 않는다***
		- 클래스에 있는 대부분의 코드에서 단순히 다른 클래스에 있는 루틴을 호출하고 있다면 중개 역할을 하는 클래스를 제거하고 다른 클래스를 직접 호출할 수 없는지 고려
	- ***한 클래스가 지나치게 다른 클래스를 참견한다***
		- 훨씬 강력하게 캡슐화하라
	- ***루틴의 이름이 엉성하다***
		- 루틴이 호출된 모든 곳에서 이름을 변경한 다음 다시 컴파일
	- ***공개 데이터 멤버다***
		- 공개 데이터는 인터페이스와 구현 사이의 구분을 흐리게 하며 본질적으로 캡슐화를 위반하고 향후 유연성을 제한한다
	- ***서브클래스는 부모 클래스의 루틴의 일부만을 사용한다***
		- 서브클래스가 논리적으로 부모 클래스의 자손이어서가 아니라 부모 클래스가 우연히 서브클래스에서 필요한 루틴을 포함하고 있었기 때문에 서브 클래스가 생성되었다는 것을 의미
		- 서브클래스와 슈퍼클래스의 관계를 IS-A 관계에서 HAS-A 관계로 전환해 더 나은 캡슐화를 달성할 수 있는지 고려
	- ***주석을 이용해 어려운 코드를 설명한다***
		- 주석은 중요한 역할을 하지만, 나쁜 코드를 설명하기 위한 도구로 사용되어서는 안된다
    - ***전역 변수를 사용한다***
    - **루틴이 루틴을 호출하기 전에 설정 코드를 사용하거나 루틴을 호출한 다음에 분해 코드를 사용한다**
	- 예시 - 나쁜 예시

```java

// 이런 설정 코드를 주의
WithdrawalTransaction withdrawal;
Withdrawal.SetCustomerId( customerId);
Withdrawal.SetBalance( balance);
ProcessWithdrawal (withdrawal) ;

//이런 분해 코드를 주의해야 한다
customerId = withdrawal.GetCustomerId();
balance = withdrawal.GetBalance();

```

 - 수정
```java
ProcessWithdrawal( customerId, balance);
```

- ***프로그램이 언젠가 필요할 것 같은 코드를 포함하고 있다***
	- 미리 설계하는 방식의 문제
		- 미리 설계한 코드는 요구사항이 완벽하지 않고 따라서 개발자들이 미래의 요구사항을 잘못 추측했을 수 있다. 결국 미리 작성한 코드는 버려질 것이다
		- 개발자가 추측한 미래의 요구사항이 상당히 정확하더라도 일반적으로 미래의 요구사항이 갖는 모든 복잡함을 예상하지는 못한다
		- 미리 설계한 코드를 사용할 미래의 개발자들은 그 코드가 미리 설계한 코드인지 모르거나 그 코드가 보기보다 더 잘 작동한다고 가정한다. 그들은 미리 설계한 코드를 사용하는 코드를 작성하느라 많은 시간을 낭비하고 결국에는 미리 설계한 코드가 실제로는 작동하지 않는다는 것을 발견할 것이다
		- 불필요하게 미리 설계한 코드 때문에 코드가 더 복잡해져 추가적인 테스트와 추가적인 결함 수정을 해야할 수도 있다
- 체크리스트
![[codeComplete44.png]]
- 리팩터링하면 안 되는 이유
	- 일반적으로 리팩터링은 결함을 수정하고 기능을 추가하고 설계를 변경하는 것을 막연하게 가리키는 데 사용
	- 변경 그 자체는 미덕이 아니지만, 원칙이 적용된 목적이 있는 변경은 유지보수 중에 프로그램의 품질을 꾸준히 향상시킨다
## 24.3 구체적인 리팩터링
- 데이터 수준 리팩터링
	- ***매직 넘버를 이름 상수로 대체한다***
		- 3.14 같은 숫자나 문자 리터럴을 사용하고 있다면 해당 리터럴을 PI와 같은 이름 상수로 대체
	- ***변수 이름을 더 분명하고 많은 정보를 제공하는 이름으로 다시 짓는다***
		- 변수 이름, 상수, 클래스, 루틴의 이름이 분명하지 않다면 더 나은 이름으로 변경
	- ***표현식을 인라인화한다***
		- 표현식의 결과를 할당하는 중간 변수를 표현식 자체로 대체
	- ***표현식을 루틴으로 대체한다***
		- 일반적으로 표현식이 코드에서 중복되지 않게 하는 것이 목적
	- ***중간 변수를 사용한다***
		- 표현식을 표현식의 목적을 잘 요약한 이름을 붙인 중간 변수에 할당
	- ***여러 목적으로 사용되는 변수를 단일 목적을 갖는 변수 여러 개로 변환***
	- ***로컬에서 사용할 목적이라면 매개변수 대신 지역 변수를 사용한다***
	- ***기본형 데이터를 클래스로 변환한다***
	- ***형 선언 코드 집합을 클래스나 열거형으로 변환***
	- ***형 선언 코드 집합을 서브클르새를 갖는 클래스로 변환한다***
	- ***배열을 객체로 변경한다***
		- 각 요소가 형식이 서로 다른 배열을 사용하고 있다면 배열의 각 요소에 대한 필드를 갖는 객체를 생성
	- ***컬렉션을 캡슐화한다***
		- 클래스가 읽기만 가능한 컬렉션을 리턴하게 하고 컬렉션에 요소를 추가하고 제거하기 위한 로틴을 제공한다
	- ***전형적인 레코드를 데이터 클래스로 대체한다***
		- 레코드의 멤버를 포함하는 클래스를 생성
		- 클래스를 생성하면 오류 검사와 지속성, 레코드와 관련된 다른 연산에 집중할 수 있다
	- 명령문 수준 리팩터링
	- ***불린 표현식을 분해한다***
		- 표현식의 의미를 문서화하는 데 도움이 되는 중간 변수를 사용해 불린 표현식을 단순화한다
	- ***복잡한 불린 표현식을 명확한 이름의 불린 함수로 옮긴다***
		- 표현식이 너무 복잡하다면 리팩터링이 가독성을 향상시킬 수 있다
		- 표현식이 한 번 이상 사용된다면 리팩터링이 병렬 수정의 필요성을 제거하고 표현식 사용 시 오류 발생 가능성도 줄여준다
	- ***서로 다른 조건문 내에 중복으로 사용된 코드를 결합한다***
		- if 브록 끝에 있는 코드가 else 블록 끝에서도 반복되고 있다면 if-then-else 전체 블록 다음에 오도록 코드를 이동
	- ***루프 제어 변수 대신 break나 return을 사용한다***
	- ***중첩된 if-then-else 명령문 내에서 리턴 값을 할당하는 대신, 답을 알았을 때 곧바로 리턴***
		- 리턴 값을 알았을 때 곧바로 루틴을 탈출하는 경우에 코드가 가장 읽기 쉽고 오류가 발생할 확률이 가장 낮다
	- ***조건문(특히 반복되는 case문)을 다형성으로 대체한다***
	- ***널 값을 테스트하는 대신 널 객체를 생성해 사용한다***
	- 루틴 수준 리팩터링
	- ***루틴, 메서드를 추출한다***
		- 루틴에서 인라인 코드를 제거한 후 해당 코드를 별도의 루틴으로 변환한다
	- ***루틴의 코드를 인라인화한다***
	- ***긴 루틴을 클래스로 변환한다***
		- 루틴이 너무 길다면 때로는 루틴을 클래스로 변환하고 이전 루틴을 여러 개의 루틴으로 분해하는 것이 가독성을 향상시킨다
	- ***복잡한 알고리즘 대신 간단한 알고리즘을 사용한다***
	- ***매개변수를 추가한다***
	- ***매개변수를 제거한다***
		- 루틴이 더 이상 매개변수를 사용하지 않는다면 제거한다
	- ***변경 연산과 쿼리 연산을 구분한다***
		- 상태를 변경하는 기능과 쿼리 기능을 분리하고 두 개의 개별 루틴을 제공한다
	- ***매개변수를 이용해 유사한 루틴을 결합한다***
		- 두 개의 유사한 루틴이 루틴 내에서 사용되는 상수값만 다른 경우, 그 루틴을 하나의 루틴으로 결합하고 사용되는 상수 값을 매개변수로 전달
	- ***전달되는 매개변수에 따라 행동하는 루틴을 분리한다***
		- 루틴이 입력 매개변수의 값에 따라 서로 다른 코드를 실행하고 있다면 해당 루틴을 특별한 입력 매개변수를 전달하지 않고 개별적으로 실행할 수 있는 루틴으로 나누는 것을 고려
	- ***특정한 필드 대신 전체 객체를 전달한다***
		- 같은 객체에 있는 여러 개의 값을 한 루틴에 전달하고 있다면 전체 객체를 받아들이도록 루틴의 인터페이스를 변경할 것을 고려
	- ***전체 객체 대신 특정한 필드만 전달한다***
	- ***다운캐스팅을 캡슐화한다***
		- 루틴이 객체를 리턴하고 있다면 일반적으로 루틴이 알고 있는 가장 구체적인 객체의 형을 리턴
		- 특히 이터레이터, 컬렉션, 컬렉션의 요소 등을 리턴하느 루틴에 적용
	- 클래스 구현 리팩터링
	- ***값 객체를 참조 객체로 변경한다***
		- 크거나 복잡한 객체의 복사본을 많이 생성해 관리하고 있다면, 하나의 마스터 객체(값 객체)만 존재하도록 객체의 사용법을 변경하고 나머지 코드에서는 해당 객체의 참조만 사용
	- ***참조 객체를 값 객체로 변경한다***
		- 작고 간단한 객체에 대해 수많은 참조 코드를 수행하고 있다면 모든 객체가 값 객체가 되도록 객체의 사용법을 변경
	- ***가상 루틴을 데이터 초기화로 대체한다***
		- 리턴 값만 다른 서브클래스가 있다면 파생 클래스에서 멤버 루틴을 오버라이드하는 대신 파생 클래스에서 적절한 상수 값으로 클래스를 초기화한 후 그 값을 사용할 수 있는 일반적인 코드를 기본 클래스에 넣기
	- ***멤버 루틴이나 데이터의 위치를 변경한다***
		- 상속 계층 구조에서 여러 가지 일반적인 변경을 고려
			- 루틴을 슈퍼클래스로 이동시킨다
			- 필드를 슈퍼클래스로 이동시킨다
			- 생성자 코드를 슈퍼클래스로 이동시킨다
		- 파생 클래스에서 특수화를 지원하는 방법
			- 루틴을 파생 클래스로 이동시킨다
			- 필드를 파생 클래스로 이동시킨다
			- 생성자 코드를 파생 클래스로 이동시킨다
	- ***특화된 코드를 서브클래스로 추출한다***
	- ***유사한 코드를 슈퍼클래스로 결합한다***
		- 두 서브클래스가 유사한 코드를 갖고 있다면 코드를 결합해 슈퍼클래스로 이동
	- 클래스 인터페이스 리팩터링
	- ***루틴을 다른 클래스로 이동시킨다***
		- 대상 클래스에 새로운 루틴을 생성하고 원본 클래스에 있는 루틴의 코드를 대상 클래스로 이동
	- ***한 클래스를 두 개로 변환한다***
        - 클래스가 두 개 이상의 별개의 책임 분야를 갖고 있다면 해당 클래스를 여러 클래스로 나누어 각 클래스가 분명하게 정의된 책임을 갖도록 한다
	- ***클래스를 제거한다***
		- 클래스가 많은 일을 하지 않는다면 해당 클래스의 코드를 더 응집력이 있는 다른 클래스로 이동시킨 후 클래스를 제거
	- ***위임을 숨긴다***
	- ***중개자를 제거한다***
		- 클래스 A가 B를 호출하고 B가 C를 호출한다면 A가 C를 직접 호출하도록 하는 것이 더 좋을 수도 있다
		- 클래스에 B에 대한 위임 여부는 무엇이 클래스 B의 인터페이스의 무결성을 최적으로 유지할 것인지에 달려있다
	- ***상속을 위임으로 대체한다***
		- 클래스가 다른 클래스를 사용해야 하지만 클래스의 인터페이스를 제어하고 싶다면 슈퍼클래스를 서브클래스의 필드로 만들고 응집력 있는 추상화를 제공하도록 일련의 루틴을 노출
	- ***위임을 상속으로 대체한다***
		- 클래스가 멤버 클래스의 모든 공개 로틴을 노출하고 있다면 클래스를 사용하는 대신 위임 클래스로부터 상속받는다
	- ***외부 루틴을 도입한다***
		- 클래스가 추가적인 루틴이 필요하지만 그러한 기능을 제공할 수 있게 클래스를 수정할 수 없다면 그런 기능을 제공하는 클라이언트 클래스 내에 새로운 루틴을 생성
	- ***확장 클래스를 도입한다***
		- 클래스가 여러 개의 추가적인 루틴이 필요하지만 해당 클래스를 수정할 수 없다면 수정 불가능한 클래스의 기능과 추가적인 기능을 결합해 새로운 클래스를 작성할 수 있다
	- ***노출된 멤버 변수를 캡슐화한다***
		- 멤버 데이터가 공개라면 멤버 데이터를 비공개로 변경하고 대신 루틴에 통해서 멤버 데이터의 값을 노출
	- ***변경할 수 없는 필드에 대한 Set() 루틴을 제거한다***
		- 필드가 객체의 생성 시간에만 설정되고 그 후로는 변경될 수 없다면 오해의 소지가 있는 Set() 루틴을 제공하는 대신 객체의 생성자에서 그 필드를 초기화
	- ***클래스 외부에서 사용하면 안 되는 루틴을 숨긴다***
		- 만약 클래스 인터페이스가 어떤 루틴이 없을 때 응집성이 강해진다면 해당 루틴을 감춘다
	- ***사용되지 않는 루틴을 캡슐화한다***
		- 클래스의 특정 인터페이스 부분만 일상적으로 사용한다면 필요한 루틴만 노출하는 새로운 클래스 인터페이스를 생성한다
	- ***슈퍼클래스와 서브클래스의 구현이 매우 유사하다면 이 둘을 결합한다***
		- 시스템 수준 리팩터링
	- ***제어할 수 없는 데이터에 대해 명확한 참조 소스를 생성한다***
	- ***단방향 클래스 관계를 양방향 클래스 관계로 바꾼다***
	- ***양방향 클래스 관계를 단방향 클래스 관계로 바꾼다***
		- 실제로 한 클래스만 다른 클래스를 알 필요가 있다면 오직 한 클래스만 다른 클래스를 알도록 클래스를 변경한다
	- ***간단한 생성자 대신 팩토리 메서드를 제공한다***
		- 형 선언 코드를 기반으로 객체를 생성해야 하거나 값 객체가 아닌 참조 객체를 다루어야 할 때 팩터리 메서드를 사용한다
	- ***오류 코드를 예외로 대체하거나 그 반대로 한다***
- 체크리스트
    ![[codeComplete45.png]]
    ![[codeComplete46.png]]
    ![[codeComplete47.png]]
## 24.4 안전한 리팩터링 방법
- 리팩터링 실수 예방하는 방법
	- ***리팩터링을 시작하기 전에 코드를 저장한다***
		- 리팩터링을 시작하기 전에 언제든지 원본 코드로 되돌릴 수 있도록 준비
	- ***리팩터링을 작게 유지한다***
	- ***리팩터링은 한 번에 하나만 수행한다***
	- ***수행할 단계에 대한 목록을 만든다***
		- 단계 목록을 만들고 상황에 맞게 변경
	- ***주차장을 만든다***
		- 지금 당장 필요하지 않은 변경 사항에 대해서는 “주차장”을 만들어 놓는다
		- 주차장은 지금 당장 변경할 필요는 없지만, 어느 시점에서 변경해야 하는 사항에 대한 목록
	- ***체크포인트를 자주 설정한다***
		- 리팩터링을 하면서 여러 곳에 체크포인트를 저장해 막다른 골목에 다다랐을 때 작동하는 프로그램으로 돌아올 수 있도록 한다
	- ***컴파일러 경고를 활용한다***
		- 컴파일러 경고 수준을 가장 까다롭게 설정해 오류를 해결
	- ***다시 테스트한다***
	- ***테스트 케이스를 추가한다***
		- 이전 테스트로 다시 테스트하는 것과 더불어 새로운 코드를 검증할 새로운 단위 테스트를 추가
	- ***변경 사항을 검토***
		- 간단한 변경을 복잡한 것처럼 취급
	- ***리팩터링의 위험 수준에 따라 접근 방법을 조절한다***
	- 리팩터링에 좋지 않은 시기
	- ***코드를 작성하고 수정하는 것을 감추는 용도로 리팩터링을 사용하지 않는다***
	- ***코드를 재작성하는 대신 리팩터링하지 않는다***
		- 중요한 리팩터링을 하고 있다면 해당 코드를 재설계해 처음부터 다시 구현해야 하는 것이 아닌지 자신에게 물어본다
## 24.5 리팩터링 전략
- 리팩터링 중요도를 결정하는 지침
	- ***루틴을 추가할 때 리팩터링 한다***
		- 루틴을 추가할 때 관련된 루틴이 잘 구성되었는지 검사
		- 잘 구성되지 않았다면 그것을 리팩터링
	- ***클래스를 추가할 때 리팩터링한다***
		- 클래스를 추가하면 종종 기존 코드에 있던 문제가 눈에 띄므로 이를 리팩터링할 기회로 활용
	- ***결함을 수정할 때 리팩터링한다***
	- ***오류를 유발할 가능성이 있는 모듈을 대상으로 삼는다***
	- ***복잡도가 높은 모듈을 대상으로 삼는다***
	- ***유지보수 환경에서는 자신이 맡은 부분을 개선한다***
		- 절대로 변경되지 않는 코드는 리팩터링할 필요가 없다하지만 특정한 코드를 다룰 때는 자신이 맡았을 때보다 더 좋은 상태가 되도록 한다
	- ***정돈된 코드와 엉성한 코드 사이의 인터페이스를 정의한 후 인터페이스를 통해 코드를 이동한다***
	        ![[codeComplete48.png]]

- 체크리스트
	![[codeComplete49.png]]
# 25장 코드 튜닝 전략
## 25.1 성능이란?
- 품질의 특성과 성능
	- 사용자는 코드의 품질보다 구체적인 프로그램의 특성에 더 많은 관심을 둔다
	- 성능과 코드 속도는 어느 정도만 관련이 있다. 코드의 속도를 개선하려고 쓰는 시간만큼 다른 품질 특성에 대한 작업은 하지 않게 된다
	- 속도에 대한 작업이 전체적인 성능에 도움을 주기보다 해를 입힐 수 있다
	- 성능과 코드 튜닝
	- 프로그램 요구사항
		- 성능은 실제보다 훨씬 더 자주 요구사항으로 여겨진다
		- 성능 문제를 해결하는 데 시간을 투자하기 전에 먼저 해결해야 할 문제를 해결하고 있는지 확인해야한다
- 프로그램 설계
	- 프로그램의 크기와 속도가 중요하다는 것을 알고 있다면 크기와 속도의 목표를 합리적으로 달성할 수 있게 아키텍처를 설계
	- 성능 중심적인 아키텍처를 설계한 다음 개별적인 서브시스템과 기능, 클래스에 대한 리소스 목표를 설정
		- 개별적인 리소스의 목표를 설정하면 시스템의 궁극적인 성능을 예측할 수 있다. 목표를 달성하는 데 문제가 있는 서브시스템을 초기에 규명해 다시 설계하거나 코드 튜닝을 대상으로 설정
		- 목표를 분명하게 만드는 단순한 행위는 목표가 성취될 가능성을 높인다. 개발자들은 목표가 무엇인지 알 때 목표 지향적으로 일한다
		- 효율화를 직접 달성하는 것이 아니라 장기적으로 효율화를 촉진하는 목표를 설정해도 된다. 효율화는 종종 다른 문제가 있는 상황에서 가장 잘 처리된다.
- 클래스와 루틴 설계
	- 클래스와 루틴의 내부 설계는 성능에 도움이 될 수 있도록 설계하는 또 다른 기회를 제공
	- 이 수준에서 성능을 위해 할 수 있는 핵심 활동은 데이터형과 알고리즘을 선택하는 것, 대개 프로그램의 메모리 사용과 실행 속도에 여향을 미친다
		- 버블 정렬 대신 퀵 정렬 | 선형 검색 대신 이진 검색
- 운영체제 상호작용
	- 프로그램이 운영체제와 상호작용하고 있다는 것을 알아차리지 못할수도 있다
- 코드 컴파일
	- 좋은 컴파일러는 고급 프로그래밍 언어 코드를 최적화된 기계어 코드로 변환
	- 올바른 컴파일러는 선택하면 속도 최적화에 대해 더 생각하지 않아도 된다
- 하드웨어
	- 때로는 프로그램의 성능 향상을 위한 가장 저렴하면서도 좋은 방법이 새로운 하드웨어를 구입하는 것일 때가 있다
	- 이 방법은 초기 성능 개선 비용을 절약하고 성능 개선으로 인해 발생하는 유지보수 문제의 비용을 절약한다
- 코드 튜닝
	- 코드가 더 효율적으로 작동하도록 정확하게 수정하는 방법
	- 튜닝은 단일 클래스나 단일 루틴, 더 일반적으로 몇 줄의 코드에 영향을 미치는 작은 규모의 변경
## 25.2 코드 튜닝 소개

>[!important]
>💡 코드 튜닝의 문제점은 효율적인 코드가 항상 “더 나은” 코드는 아니라는 점

- 파레토 법칙
	- 프로그램의 20%에 해당하는 루틴이 실행 시간의 80%를 소비
	- 커누스는 줄 계수 프로그램을 프로파일링해 두 개의 루프에서 실행 시간의 절반을 사용한다는 사실을 발견 ⇒ 코드를 측정해 hot spot을 찾은 다음, 가장 많이 사용되는 몇 퍼센트를 최적화하는 데 노력을 집중해야 한다
- 노부인들의 이야기
	- ***고급 언어에서 코드를 줄이면 결과적으로 기계어 코드의 속도나 크기를 향상시킨다- 거짓!***
	- ***어떤 연산이 아마 다른 것보다 빠르거나 작을 것이다-거짓!***
	- 프로그램을 이식 가능하게 만들고 싶을 때 어떤 환경에서 성능을 향상시켰던 기법이 다른 환경에서는 성능을 떨어뜨릴 수 있다
	- 컴파일러를 변경하거나 업그레이드하면 그 새 컴파일러가 수동으로 했던 방법처럼 자동으로 코드를 최적화할 것이고 지금까지 했던 일은 쓸모 없어질 것이다
	- 더 나쁜 것은 코드 튜닝 때문에 직관적인 코드를 다루도록 설계된 더 강력한 컴파일러 최적화를 못할 수도 있다
	- 코드를 튜닝할 때 암시적으로 컴파일러 상표와 버전, 라이브러리 버전 등을 변경할 때마다 최적화를 다시 측정해야 한다
- ***코드를 작성하면서 최적화해야 한다-거짓!***
	- 코드를 작성하면서 최적화할 때의 문제점
		- 프로그램이 완벽하게 작동하기 전까지는 성능 병목을 규명하기가 거의 불가능하다. 개발자들은 실행 시간의 50%를 차지하는 4%의 코드를 거의 추측하지 못하기 때문에 코드를 작성하면서 초기화하는 개발자들은 최적화할 필요가 없는 코드를 최적화 하느라 시간을 낭비한다
            - 개발자들이 병목을 정확하게 파악한 드문 경우에도 알아낸 병목을 지나치게 없애서 다른 부분을 위태롭게 만들기도 한다 ⇒ 성능이 떨어지는 결과 발생
            - 개발 초기에 최적화에 초점을 맞추면 프로그램의 다른 목표를 달성하기가 어려워진다. 성능이 다른 것보다 나중에 향상시키기 더 쉬운 부분임에도 불구하고 정확성, 정보 은닉, 가독성 같은 중요 부분이 부차적인 목표가 된다
        - 프로그램이 완성되기 전에 최적화해야 한다면 프로세스에 대해 전망함으로써 위험을 최소화한다
		- 해결하는 방법은 기능에 대한 크기와 속도 목표를 명시한 다음 작업을 수행함으로써 그 목표를 달성하기 위해 최적화하는 것
	- ***빠른 프로그램은 정확한 프로그램만큼 중요하다-거짓!***
- 튜닝 시점
	- 고급 설계를 사용하고, 프로그램을 제대로 만들어라
	- 나중에 작업하기 쉽게 모듈화하고 변경하기 쉽게 만들어라
	- 제대로 완성되었을 때 성능을 검사하라
	- 프로그램을 못 쓰게 하고 싶다면 빠르고 작게 만들어라
	- 최적화가 필요하다는 것을 알게 될 때까지 최적화하지 마라
- 컴파일러 최적화
	- 컴파일러는 교묘한 코드를 최적화하는 것보다 직관적인 코드를 최적화하는 데 능숙하다
	- 루프의 인덱스를 가지고 노는 것보다 “교묘한” 짓을 하면 컴파일러가 이 코드를 최적화하는 데 어려움을 겪게 되어 결국 프로그램이 손해를 볼 것이다
	- 루틴의 버전 사이의 유일한 차이점은 첫 번째 컴파일에서는 컴파일러의 최적화 기능을 사용하지 않았고 두 번째는 사용했다는 점
	- 어떤 컴파일러는 다른 것보다 최적화를 더 잘하고 어떤 컴파일러는 처음부터 최적화 없이도 더 좋은 성능을 제공한다
## 25.3 느리고 비대한 부분
- 비효율성의 공통적인 원인
	- ***입력/출력 연산***
		- 비효율성의 가장 중요한 원인 중 하나는 불필요한 I/O
		- 메모리에 있는 파일과 디스크나 데이터베이스, 네트워크에 있는 파일 중 어느 하나를 선택할 수 있으며 공간이 중요하지 않다면 인메모리 데이터 구조를 사용한다

	- ***페이징(paging)***
		- 운영체제가 메모리 페이지를 교체하게 하는 연산은 메모리 페이지 하나에서 작동하는 연산보다 훨씬 느리다. 때때로 간단한 변경이 매우 큰 차이를 만든다
		- 예제
			- 4K 페이지를 사용하는 시스템에서 페이지 오류가 자주 발생하는 초기화 루프
```java

for ( column = 0; column < MAX_COLUMNS; column++ ) {
	for ( row = 0; row < MAX_ROWS;row++) {
		table[ row ][ column ] = BlankTableElement();
	}
}

```

- 테이블의 행이 아주 많다면 프로그램이 다른 열에 접근할 때마다 운영체제가 메모리 페이지를 바꿔야한다
- 페이지 오류가 적은 초기화 루프 예제

```java
for ( row= 0; row < MAX_COLUMNS; row ++ ) {
	for ( column = 0; column < MAX_ROWS; column++) {
		table[ row ][ column ] = BlankTableElement();
	}
}
```

- ***시스템 호출***
	- 시스템 루틴을 호출하면 문맥 전환(context switching)이 발생한다. 따라서 프로그램의 상태를 보관하고 커널의 상태를 복구한 다음 그 반대의 작업이 발생
	- 성능이 문제가 된다면 시스템 호출이 얼마나 비싼지 알아보기 - 대안
		- 자신만의 서비스를 작성한다. 시스템 루틴이 제공하는 기능의 일부만 필요한 경우가 종종 있고 그런 경우 저수준 시스템 루틴을 직접 작성하면 된다
		- 시스템으로 가는 것을 피한다
		- 시스템 루틴 호출을 더 빠르게 만들기 위해 시스템 벤더와 적압한다
- ***인터프리트 언어***
	- 기계어 코드를 생성하고 실행하기 전 각 프로그래밍 언어 명령을 처리해야 하므로 상당한 성능 손해를 보는 경향이 있다

- ***오류***
	- 코드에 있는 오류
	- 코드에 남겨진 디버깅 코드(예 : 파일에 추적 정보 기록), 메모리 할당 해제 잊음, 부적절한 데이터베이스 테이블으 ㅣ설계ㅡ 존재하지 않는 장치를 정해진 시간 동안 살펴보는 것 등
- 공통적인 연산의 상대적인 성능 비용
	- 공통적인 연산의 비용
![[codeComplete50.png]]
![[codeComplete51.png]]
![[codeComplete52.png]]
## 25.4 측정
- 경험은 최적화에 큰 도움을 주지 못한다. 개인의 경험은 오래된 장비나 언어, 컴파일러로부터 얻은 것이기 때문에 그러한 것이 변하면 경험도 필요 없어진다
- 측정은 정확해야 한다
	- 성능 측정은 정확해야 한다
	- 프로파일링 도구가 유용하고, 아니면 시스템 시간과 연산을 수행하는 데 걸린 시간을 기록하는 루틴을 사용해도 좋다
	- 튜닝하는 코드의 실행 시간만 측정해야 한다
	- 측정 오버헤드와 프로그램의 구동 오버헤드를 분리해 원래 코드와 튜닝 시도가 부당하게 불리해지지 않도록 한다
## 25.5 반복
- 최적화의 역사 - 반복하기
    ![[codeComplete53.png]]!
## 25.6 코드 튜닝 단계 요약
- 코드 튜닝의 단계
	1. 이해하고 변경하기 쉬운 잘 설계된 코드를 사용해 소프트웨어를 개발한다
	2. 성능이 좋지 않다면
		1. 나중에 “마지막으로 좋았던 상태”로 돌아올 수 있도록 작동하는 버전의 코드를 저장
		2. 과열지점을 찾기 위해서 시스템을 측정한다
		3. 성능이 취약한 것이 부적절한 설계 때문인지, 데이터형이나 알고리즘 때문인지를 판단하고 코드 튜닝이 적절한지 판단한다.  코드 튜닝이 적절하지 않다면 1단계로 돌아간다
		4. c 단계에서 규명된 병목을 튜닝한다
		5. 한 번에 하나씩 성능을 측정한다
		6. 코드의 성능이 향상되지 않았다면 a 단계에서 저장했던 코드로 되돌아 간다
	3. 2단계를  반복한다
# 26장 코드 튜닝 기법

## 26.1 논리 구조

- 답을 알고 있을 때는 테스트를 중단하라
	- 답을 알고 난 후 멈추는 코드 예제

```java

negativeInputFound = false;
for ( i = 0; i< count; i++) {
	if ( input[i] < 0 ) {
		negativeInputFound  = true;
		// 검색 중단하는 방법      
		// 1. break; 추가하기
		// 2. for를 while문으로 변경하고 반복문 카운터의 증가 값이 count를 지났는지 검사하고 negativeInputFound를 검사
		// 3.
	}
}

```
- 빈도에 따른 테스트 정렬
	- 잘 정렬된 논리 테스트 - 자바에서는 큰 이점이 없다
```java

// 자바에서는 switch보다 if-then-else문이 빠르다

switch(inputCharacter){
	Case A to Z, a to z
		processAlpha(inputCharacter)
	Case " "
		processSpace(inputCharacter)
	Case ",", ".", ":", ";","!","?"
		processpunctuation(inputCharacter)
	Case "0" to "9"
		processDigit(inputCharacter)
	Case "+","="
		processMatcSymbol(inputCharacter)
	Case else
		ProcessError(inputCharacter)
}
```

- 유사한 논리 구조의 성능을 비교하라
	- 어떤 언어에서는 case 문이 if-then-sle에 비해 엄청나게 뛰어나지만, 다른 언어에서는 if-then-else 문이 case 문보다 훨씬 더 뛰어나다. 다른 언어에서는 그 차이가 크지 않다
- 복잡한 표현식을 테이블 참조로 대체하라
	- 어떤 환경에서는 복잡한 논리 구조를 상세하게 따지는 것보다 테이블 참조가 더 빠를 수 있다
- 복잡한 논리 구조로 작성한 예제

```java

if ( ( a && !c ) || ( a && b && c) ) {
	category = 1;
}

else if ( ( b && !a ) || ( a && b && c) ) {
	category = 2;
}

else if ( c && !a && !b ) {
	category = 3;
}

else {
	category = 0;
}
```
- 복잡한 논리 구조를 대체하기 위해 테이블 참조 사용

```java

int categortyTable[ 2 ][2][2] = {
	// !b!c !bc b!c bc
  0, 3, 2, 2 // !a
  1, 2, 1, 1 // a
};
cateogry = categortyTable[a][b][c];

```

- 소극적 평가를 사용하라
	- 프로그램이 소극적 평가를 사용하면 작업이 필요해질 때까지 어떠한 작업도 하지 않는다
	- 소극적 평가는 필요한 순간에 작업하는 JIT 전략과 유사하다
## 26.2 반복문
- 스위칭 해제
	- 스위칭은 반복문이 실행될 때마다 반복문 내에서 무언가를 결정하는 것
	- 반복문이 실행되는 동안 그 결정이 변하지 않는다면 반복문 밖에서 결함으로써 불필요하게 스위칭하지 않게 할 수 있다
	- 스위칭 되는 반복문

```java

for ( i = 0 < i< count; i++) {
	if ( sumType == SUMTYPE_NET) {
		netSum = netSum + amount[i];
	}else{
		grosssSum = grosssSum + amount[i];
	}
}

```

- 스위칭을 해제한 반복문
```java
if ( sumType == SUMTYPE_NET) {
	for ( i = 0 < i< count; i++) {
		netSum = netSum + amount[i];
	}
}else {
	for ( i = 0 < i< count; i++) {
		netSum = netSum + amount[i];
	}
}
```
- C++, 자바, 파이썬에는 효과가 있었지만 비주얼 베이직은 효과 X ⇒ 어떤 최적화의 효과를 확인하려면 반드시 그 효과를 측정해야 한다
- 결합
	- 같은 요소의 집합을 다루는 두 개의 반복문을 결합한 결과
```python

for i in range(len(lest) - 1 ):
	employeeName[i] = ""
	employeeEarnings(i) = 0

```
- 코드 풀어쓰기
	- 반복문을 완전히 풀어쓰는 것이 가장 빠른 해결책이고, 요소의 수가 작을 때는 효과적이지만 요소의 수가 많거나 얼마나 많은 요소를 가질지 미리 알 수 없을 때는 그 방법을 사용할 수 없다
	- 코드를 풀어쓸 수 있는 반복문

```java
int i = 0;
while ( i < count) {
	a[ i ] = i;
	i += 1;
}
```

- 한 번 풀어쓴 반복문

```java

int i = 0;

while ( i < count - 1 ) {
	a[ i ] = i;
	a[ i + 1 ] = i + 1;
	i += 2;
}

if ( i == count ) {
	a[ count -1 ] = count - 1
}

```

- 다섯줄 → 9줄로 늘어나고 코드가 눌어나 유지보수가 하기 어려움
	- 속도 면에서는 이득을 보았지만, 품질은 나빠졌다
	- **어떤 설계 규칙이든 트레이드오프가 따른다**
	- **반복문을 풀어쓰면 더 많은 시간을 절약할 수 있지만, 자바의 경우 반드시 그렇지 않다. 여기서 핵심은 코드를 풀어쓸 때마다 코드가 더 복잡해진다는 점**
- 반복문 내부 작업 최소화
	- 처음 코드를 작성할 때부터 코드의 속도를 걱정하지 말고 더 읽기 쉬운 코드를 작성할 수 있는 방법을 사용하라
- 감시 값
	- 감시 값 : 검색 범위의 끝을 지났을 때 검색이 종료되게 하려고 입력하는 값
```java
// 실제 테스트 시 반복문이 반복할 때마다 세 번의 테스트 수행
found = false;
int i = 0;
while ( ( !found ) && ( i < count ) ) {
	if ( item[ i ] == testValue ) {
		found = true;
	}else{
		i++;
	}
	}
if ( found ) {

...

```
- 반복문 속도 향상을 위해 감시값 사용
```java

// 감시 값을 설정한다. 원래 값을 보관한다

initialValue = item[ count ];
item[ count ] = testValue;
int i = 0;
while( item[ i ] != testValue) {
	i++;
}

// 값이 발견되었는지 검사
if(i < count ) { ...}

```

- 가장 비번하게 실행되는 반복문을 안쪽에 작성한다
	- 반복문을 개선하는 데 가장 중요한 사항은 바깥쪽에 있는 반복문이 안족에 있는 반복문보다 훨씬 자주 실행된다는 것
```java

for i in range(0, 100):

	for j in range(0, 5):
	
		// i는 100번 , j는 5 * 100 번 수행
	
		// for j in range 쪽을 수정해야한다
	
		sum = sum + table[ i] [j];

```
- 연산 줄이기
	- 곱셉과 같이 시간이 오래 걸리는 연산을 덧셈과 같이 시간이 적게 걸리는 연산으로 대체하는 것
## 26.3 데이터 변환
- 부동 소수점 수 대신 정수를 사용하라
	- 정수의 덧셈과 곱셈은 부동 소수점의 덧셈과 곱셈보다 더 빠른 경향이 있다
- 가능한 가장 적은 차수의 배열을 사용하라
	- 2차원이나 3차원 배열 대신 1차원 배열로 구성할 수 있다면 어느 정도 시간을 절약할 수 있다
- 배열에 대한 참조를 최소화하라
	- 반복문 내부에서 불필요하게 배열을 참조하는 예제
```java

for i in range(len(list1)):
	for j in range(len(list2)):
		rate [ j ] = rate[j] * list1[i]

```
- 배열에 대한 참조를 반복문 외부로 이동

```java

for i in range(len(list1)):
	thisDisCount = list1[i]
	for j in range(len(list2)):
		list2[j] = list2[j] * thisDisCount

```
- 보조 인덱스를 사용하라
	- 문자열 길이 인덱스
		- C에서 문자열의 길이를 결정하려면 프로그램이 문자열의 처음부터 시작해 0으로 설정된 바이트를 찾을 때까지 각 바이트의 수를 세어아햠
	- 독립적인 병렬 인덱스 구조
		- 때로는 데이터형 자체를 다루는 것보다 데이터형에 대한 인덱스를 다루는 것이 더 효율적
		- 데이터형에 있는 항목이 크거나 이동시키기 어렵다면 인덱스 참조를 정렬하고 검색하는 것이 데이터를 직접 다루는 것보다 빠르다
		- 각 항목이 크면 상세한 정보에 대한 키 값과 포인터로 구성된 보조 구조를 만들 수 있다
	- 캐싱을 사용하라
        - 시간을 많이 소요하는 계산을 피하기 위해 캐시 사용 예제
```java

private double cachedHypoTenuse = 0;

private double cachedSideA = 0;

private double cachedSideB = 0;

public double Hypotenuse (  double sideA, double sideB){

	// 계산하고자 하는 삼각형이 이미 캐시에 있는지 확인

	if ( ( sideA == cachedSideA ) && ( sideB == cachedSideB ) ) {

		return cachedHypoTenuse;

	}

	// 새로운 빗변의 길이를 구하고 그 값을 캐싱

	cachedHypoTenuse = Math.sqrt( ( sideA * sideA ) + ( sideB * sideB ) );

	cachedSideA = SideA;

	cachedSideB = SideB;

	return cachedHypoTenuse;

}

```
- 이 방법은 복잡하고 많은 공간을 차지하므로 이를 정당화하려면 속도가 빨라야한다
- 캐시의 사용 빈도, 새로운 요소를 저장 시의 비용 등이 캐시의 가치를 결정한다
## 26.4 표현식
- 대수 항등식을 사용하라
```

not a and not b

not ( a or b) => 하나의 연산을 줄일 수 있고 속도 증대도 꾀할 수 있다

```
- 연산 줄이기
	- 비싼 연산을 대체하는 방법
		- 곱셉을 덧셈으로 대체한다
		- 지수를 곱셉으로 대체한다
		- 삼각법 루틴을 삼각법 항등식으로 대체한다
		- longlong 정수를 long이나 int로 대체한다(하지만 네이티브 길이를 갖는 정수와 네이티브 길이가 아닌 정수의 성능 문제를 주의한다)
		- 부동 소수점 수를 고정 소수점 수나 정수로 대체한다
		- 배정도 부동 소수점을 단정도 부동 소수점 수로 대체한다
		- 정수에 2를 곱하거나 2를 나누는 계산을 시프트 연산으로 대체한다
- 컴파일 시간에 초기화하라
	- 컴파일 시간에 초기화 예시

```java

public class SystemInitializer {

	// 컴파일 시간 상수 초기화
	private static final String SYSTEM_CONSTANT = "MyConstantValue";

	// 정적 초기화 블록을 통한 시스템 루틴 초기화
	static {
		initializeSystemRoutines();
	}

	private static void initializeSystemRoutines() {
		// 시스템 루틴 초기화 코드를 여기에 작성
		System.out.println("Initializing system routines...");
	}

	public static void main(String[] args) {
		System.out.println("System constant: " + SYSTEM_CONSTANT);
	}
}

```
- 시스템 루틴을 주의하라
	- 시스템 루틴은 비싸고 종종 쓸데없이 정확하다. 그 정도의 정확성이 필요하지 않다면 그 값을 계산하기 위해 시간을 낭비할 필요도 없다
- 상수의 정확한 타입을 사용하라
	- 값을 할당하고자 하는 변수와 같은 타입의 이름 상수와 리터럴을 사용한다
	- 상수와 관련 변수가 서로 다른 타입일 때는 컴파일러가 상수를 변수에 할당하기 위해 타입 변환을 수행해야 한다

- 결과를 사전에 계산하라
	- 가장 간단한 수준으로 반복문 내부에 있는 표현식의 일부를 외부에서 계산하는 방법
	- 좀 더 복잡한 수준으로는 프로그램이 실행될 때 참조 테이블을 한 번 계산한 다음, 그 다음부터는 항상 참조 테이블을 사용하거나 결과를 데이터 파일에 저장하거나 프로그램에 포함시키는 방법
	- 최적화 방법
		- 프로그램을 실행하기 전에 결과를 계산하고 그 값을 컴파일 시간에 상수 값으로 결합
		- 프로그램을 실행하기 전에 결과를 계산하고 그 값을 실행 시간에 사용될 변수에 직접 입력
		- 프로그램을 실행하기 전에 결과를 계산하고 그 값을 실행 시간에 읽히는 파일에 저장
		- 프로그램이 시작할 때 결과를 한 번만 계산하고 필요할 때마다 참조
		- 반복문이 시작되기 전에 가능한 한 많이 계산해 반복문 내에서 처리되는 작업을 최소화
		- 처음 필요할 때 결과를 계산하고 다시 필요할 때 가져올 수 있도록 저장
	- 공통적인 하위 표현식을 제거하라
		- 여러 번 반복되는 표현식을 발견하면 그 표현식을 여러 곳에서 다시 계산하는 대신 변수에 할당해 그 변수를 참조
		- 공통 하위 표현식을 제거한 예제

```java

monthlyInterest = interestRate / 12.0;
payment = loanAmount / ( ( 1.0 , Math.pow( 1.0 + monthlyInterest, -months )) 
				/ monthlyInterest );
			
```
## 26.5 루틴
- 루틴을 인라인으로 재작성하라
	- 프로그래밍 초기 시절, 어떤 장비에서는 루틴을 호출하면 성능이 크게 떨어졌다. 루틴을 호출하면 OS가 프로그램을 대기시키고 루틴 디렉터리로 바꾼 다음, 특정한 루틴으로 바꾸고 해당 루틴을 실행한다. 그 다음 해당 루틴을 대기시키고 원래의 호출 루틴으로 돌려놓는다. 이 모든 교체 작업이 자원을 손상시키고 프로그램을 느리게 마들었다
	- 최신 컴퓨터는 루틴 호출 비용이 상당히 적다. 어떤 경우에는 C++의 inline 키워드와 같은 언어의 기능을 이용해 루틴에 있는 코드를 프로그램의 필요한 위치에 곧바로 놓음으로써 수십억 분의 몇 초를 절약할 수 도 있다
	- 인라인을 직접 지원하지 않지만, 매크로 전처리기를 지원하는 언어에서 작업하고 있다면 코드를 매크로에 입력한 다음 필요할 때마다 넣거나 뺄 수 있다
## 26.6 저급 언어를 이용한 재구성

- 저급 언어로 최적화하는 전형적인 접근 방법
	1. 고급 언어로 응용 프로그램을 100% 작성한다
	2. 응용 프로그램을 완전히 테스트하고 정확한지 검증한다
	3. 그 다음에 성능 개선이 필요하다면 응용 프로그램을 분석해 문제가 발생하는 지점을 파악한다. 일반적으로 프로그램의 약 5%에 해당하는 부분이 실행 시간의 50%를 차지하므로 프로그램의 작은 부분이 문제가 발생하는 부분임을 파악할 수 있다
	4. 전체적인 성능을 개선하기 위해 작은 부분을 저급 언어로 재작성한다
	- 잘 정리된 이 방법을 따를 것인지는 자신의 저급 언어 실력과 프로그램이 얼마나 어셈블러에 적합한지, 그리고 개발자의 노력에 달려있다
- 체크리스트
    ![[codeComplete54.png]]

## 26.7 변경이 많을수록 상태는 그대로
- 코드 튜닝은 항상 복잡성과 가독성, 단순성, 유지보수성, 그리고 다른 측면에서 성능을 개선하기 위한 노력과 트레이드오프를 수반한다. 코드를 튜닝하면 모든 코드를 다시 분석해야 하므로 유지보수의 부담이 커진다
- 측정 가능한 개선을 강요하는 것이 서둘러 최적화하려는 유혹을 뿌리치고 직관적이고 분명한 코드를 작성할 수 있는 좋은 방법