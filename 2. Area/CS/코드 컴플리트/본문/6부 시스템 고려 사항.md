
# 27장 프로그램의 크기가 구현에 미치는 영향
>[!important]  
>💡 작은 프로젝트에서 작업하는 데 익숙한 사람이 처음 진행하는 프로젝트가 중간 이상 규모라면 생각했던 기본 좋은 성공 대신 제어 불가능한 야수가 되어 미친 듯이 날뛰는 경험을 하게 될 것이다

## 27.1 의사소통과 크기
- 의사소통의 크기
	- 프로젝트에 참여하는 사람의 수가 증가할수록 의사소통 경로의 수도 증가한다
	- 프로젝트 인원에 따른 의사소통 경로
		- 두 사람이면 하나
		- 다섯 사람이면 10개의 경로
		- 한 팀원이 모든 팀원과 이야기를 나눈다고 하면 열 사람이 참여하는 프로젝트는 45개의 경로
		- 50명 이상의 프로젝트의 10%는 최소 1200개의 경로
	- **의사소통 경로가 증가할수록 의사소통에 더 많은 시간을 보내게 되고 의사소통 실수가 발생할 확률도 높아진다**
	- **크기가 큰 프로젝트는 의사소통을 능률적으로 진행하거나 현명한 방법으로 제한하는 조직적인 기법이 필요하다**
	        ![[codeComplete56.png]]
## 27.2 프로젝트 크기의 범위
- 프로젝트 크기를 계산하는 방법
	- 프로젝트의 팀 크기 고려
		![[codeComplete57.png]]
    - 다양한 크기의 프로젝트에서 작업하는 전체적인 개발자의 백분율
	    ![[codeComplete58.png]]
        ![[codeComplete59.png]]
## 27.3 프로젝트의 크기가 오류에 미치는 영향
- 프로젝트의 크기가 오류에 미치는 영향
	- 오류의 양과 종류는 모두 프로젝트 크기의 영향을 받는다
	- 작은 프로젝트에서는 구현 시 발생하는 오류가 전체 오류의 약 75% 차지
		- **방법론은 코드의 품질에 큰 도움을 주지 못하지만, 프로그램을 작성하는 개인의 능력이 종종 프로그램의 품질에 가장 큰 영향을 미친다**
	- 큰 프로젝트에서는 구현 시 발생하는 오류가 전체 오류의 약 50%를 차지 | 요구사항과 아키텍처 오류가 나머지
	- 결함의 종류가 크기에 따라서 변할 때 결함의 수도 변한다
		![[codeComplete60.png]]
## 27.4 프로젝트의 크기가 생산성에 미치는 영향
- 프로젝트의 크기가 생산성에 미치는 영향
	- 생산성은 프로젝트 크기에 있어 소프트웨어 품질과 공통점이 많다
		- 작은 크기에서는 생산성에 가장 큰 영향을 미치는 요소는 개발자의 능력
		- 프로젝트의 크기가 증가함에 따라 팀의 크기와 조직이 생산성에 더 많은 영향을 미친다
- 작은 프로젝트에서의 생산성은 큰 프로젝트보다 2~3배 높을 수 있으며 생산성은 가장 작은 프로젝트와 가장 큰 프로젝트 사이에 5~10배 정도 차이가 날 수 있다
		![[codeComplete61.png]]
## 27.5 프로젝트의 크기가 개발 활동에 미치는 영향
- 활동 비율과 크기
	- 프로젝트의 크기가 증가하고 형식적인 의사소통의 필요성이 증가함에 따라 프로젝트가 필요로 하는 활동의 종류도 크게 변한다
		- 작은 프로젝트에서는 구현 활동이 큰 비중을 차지한다
		- 큰 프로젝트가 성공하려면 더 많은 아키텍처, 통합 작업, 시스템 테스트가 필요하다

            ![[codeComplete62.png]]
- 프로젝트의 크기가 증가함에 따라 구현 활동(상세 설계, 코드 작성, 디버깅, 단위 테스트)도 그에 비례해 증가하지만, 다른 많은 활동이 더 빠르게 증가하기 때문에 구현이 차지하는 비중이 작아진다
- 프로젝트의 크기가 증가함에 따라 선형 비율 이상으로 증가하는 활동 목록
	- 의사소통
	- 계획 수립
	- 관리
	- 요구사항 개발
	- 시스템 기능 설계
	- 인터페이스 설계와 명세
	- 아키텍처
	- 통합
	- 결함 제거
	- 시스템 테스트
	- 문서 제작
- 프로그램, 제품, 시스템, 시스템 제품
	- 가장 간단한 종류의 소프트웨어는 그 프로그램을 작성한 사람이나 비공식적으로 몇몇 다른 사람만 사용하는 단일 “프로그램”이다
	- 더 정교한 프로그램의 종류는 프로그램 개발자가 아닌 다른 사람들이 사용할 목적으로 만든 소프트웨어 제품이다
	- 소프트웨어 제품은 소프트웨어 프로그램보다 개발하는 데 약 3배의 비용이 더 든다
	- 소프트웨어 시스템은 함께 작동하는 프로그램 그룹
		- 시스템 개발은 통합되는 부분 사이에 인터페이스를 개발하는 데 따른 복잡성과 주의가 요구되기 때문에 간단한 프로그램을 개발하는 것보다 3배 정도 비용이 더 든다
		- 시스템 제품을 간단한 프로그램보다 9배 정도 비용이 더 든다
	- 프로젝트 크기가 커질수록 프로젝트에 들어가는 전체 노력에서 구현이 차지하는 비중은 작아진다
	- 구현 경험만을 바탕으로 견적을 낸다면 견적 오류가 증가할 것이다
- 방법론과 크기
	- 작은 프로젝트에서는 방법론이 격식이 없고 본능적
	- 큰 프로젝트의 방법론은 엄격하고 주의 깊게 계획
	- 문서화 자체를 위해 문서를 작성하지 않는다. 계획을 작성하는 핵심은 구현 관리에 대해 더 신중하게 생각하고 그 계획을 다른 사람에게 설명하기 위한 것이다. 문서화는 소프트웨어 시스템을 계획하고 구성할 때 수행하는 실제 업무의 실질적인 부산물
# 28장 구현 관리
## 28.1 훌륭한 코딩 장려
- 표준을 정할 때 고려할 사항
- 조직에 따라 표준이 더 유용하게 쓰이기도 한다
- 그룹에서 엄격한 표준 채용을 거부한다면 유연한 지침이나 지침이 아닌 제안 모음, 가장 좋은 습관을 구체화한 예제 모음 등 대안을 고려
- 좋은 코딩을 장려하는 기법
	- ***프로젝트의 모든 영역에 두 사람을 할당하라***
		- 두 사람이 모든 코드를 함께 작업해야 한다면 두 사람은 그 코드가 작동하고 읽을 수 있다고 보장할 수 있다
	- 짝 프로그래밍, 지도자-훈련생 시스템, 2인 1조 검토 방식 등을 고려
	- ***모든 코드를 검토하라***
		- 코드 검토는 전형적으로 한 명의 개발자와 적어도 두 명의 검토자가 참여
		- 검토는 코드를 작성한 코드를 다른 사람이 읽으리라는 것을 알고 있어 코드의 품질도 향상된다
	- ***코드에 서명하라***
	- ***검토를 위해 좋은 예제 코드를 돌려보라***
		- 좋은 관리자가 되기 위해서는 목표를 분명하게 전달해야 한다
		- 목표를 알리는 한 가지 방법은 좋은 코드를 개발자들에게 회람시키거나 공공 게시판에 붙여놓는 것
		- 코드 작성 표준 매뉴얼을 “가장 훌륭한 코드 소스”의 모음으로 구성해 작성하기
	- ***코드가 공용 자산이라는 것을 강조하라***
		- 코드는 프로젝트의 일부이며 그것이 필요한 다른 사람이 자유롭게 사용할 수 있어야 한다
	- ***좋은 개발 방식에 대한 보상을 하라***
		- 좋은 코드 작성 습관을 장려하는 데 조직의 보상 시스템을 이용한다
	- ***한 가지 쉬운 표준***

## 28.2 형상 관리
- 형상 관리란 무엇인가?
	- 형상 관리란 시스템이 무결성을 유지할 수 있도록 체계적으로 프로젝트의 부산물을 파악하고 변화를 처리하기 위한 행위
	- 형상 관리는 제시된 변경 사항에 대한 평가와 변경 추적, 다양한 시점에서 시스템의 복사본을 유지하는 기법도 포함
	- 향싱 관리가 가진 시스템적인 문제는 지나치게 제어한다는 점 ⇒ 그것이 신중하게 계획해 골칫거리가 되는 것이 아니라 자산이 될 수 있도록 해야 한다
- 요구사항과 설계의 변경

- 설계의 변경을 제어하기 위한 지침
	- ***체계적인 변경 관리 절차를 따르라***
		- 체계적인 절차를 확립함으로써 변경 사항이 전체적인 프로젝트 상황에 적합한 것인지 분명이 할 수 있다
	- ***변경 요구사항을 그룹으로 처리하라***
		- 변경을 처리할 때의 문제점은 길을 잃을 수 있다는 것
		- 이 문제의 해결책은 얼마나 쉽게 구현되는지 상관없이 모든 아이디어와 제안을 적어두고 처리할 시간이 날 때까지 보관해두는 것. 그리고 나서 그것들을 그룹으로 나누어 가장 유용할 것 같은 그룹을 선택
	- ***각 변경 비용을 산출하라***
		- 고객, 사장, 자신이 시스템을 변경하고 싶을 때마다 변경된 코드에 대한 검토와 전체 시스템을 다시 테스트하는 것을 포함해 변경하는 데 시간을 산출
		- 변경이 요구사항과 설계, 코드, 테스트, 요구사항 문서의 변경에 미치는 영향을 처리하는 데 드는 시간을 산출 시간에 포함
		- 아무리 단순한 거서럼 보여도 시간 산출이 필요하다는 것을 관련된 모든 사람에게 알린다
		- 변경이 처음에 제안되었을 때 아무리 낙관적이라도 즉흥적으로 예측하는 것을 삼가야한다
	- ***지나친 변경을 주의하라***
		- 어느 정도의 변경은 피할 수 없겠지만, 변경이 지나치게 많다는 것은 요구사항이나 아키텍처, 상위 수준의 설계가 충분하지 않아 구현을 효과적으로 진행할 수 없기 때문일 수도 있다
		- 요구사항이나 아키텍처에 대한 작업을 보완하는 작업이 많은 리소스가 드는 것처럼 보이겠지만, 필요하지도 않은 기능을 구현한 코드를 한 번 이상 구현하거나 버리는 것만큼 비싸지 않다
	- ***변경 관리 위원회나 프로젝트에 맞게 그와 비슷한 것을 결성하라***
		- 변경 관리 위원회의 역할은 가치 있는 것과 그렇지 않은 것을 구별하는 것
	- ***관료주의를 주의하되, 관료주의에 대한 두려움이 효과적인 변경 관리를 방해하지 않도록 한다***
		- 변경 관리 프로세스를 능률적으로 처리하는 방법을 찾는 것이 중요하다

- 소프트웨어 코드 변경
	- ***버전 관리 소프트웨어***
		- 버전을 관리하는 한 가지 방식은 어떤 파일을 한 번에 한 사람만 변경할 수 있도록 소스 파일을 잠그는 것
		- 여러 사람이 같은 파일을 동시에 작업하고 코드를 체크인할 때 변경 사항을 통합하는 문제를 처리해주는 것
			- 이점
				- 다른 사람이 작업중인 파일을 작업함으로써 다른 사람의 영역에 침범하는 일이 없다
				- 일반적으로 하나의 명령으로 프로젝트의 모든 파일에 대한 복사본을 최신 버전으로 쉽게 갱신할 수 있다
				- 버전 관리에 체크인한 적이 있는 파일을 어떤 버전으로든 복구할 수 있다
				- 모든 파일의 모든 버전에 대한 변경 목록을 얻을 수 있다
				- 버전 관리 복사본이 안전장치 역할을 해서 개인적인 백업을 걱정할 필요가 없다
	- 도구 버전
		- 컴파일러, 링커, 코드 라이브러리를 포함해 해당 소프트웨어의 특정한 버전을 생성하는 데 사용된 것과 같은 환경을 구성할 필요가 있다. 그런 경우 이 도구들도 버전 관리에 추가해야한다
	- 하드웨어 구성
		- 표준 구성을 갖추고 있으면 약간 다른 구성 설정과 사용하는 도구의 버전 차이 등과 연관된 문제를 피하는 데 도움이 된다
		- 표준화된 디스크 이미지는 각 소프트웨어를 개별적으로 설치하는 것에 비해 새 컴픁어의 환경을 능률적으로 설정할 수 있다
	- 백업 계획
		- 작업을 주기적으로 백업한다는 개념
	- 작업을 안전하게 보호하기 위한 단계를 밟아라
	- 백업 계획을 세우면서 자주 간과하는 한 가지 측면은 백업 절차에 대한 테스트

- 체크리스트
    ![[codeComplete63.png]]
## 28.3 구현 일정 예측
- 예측 방법
	- 프로젝트의 크기와 프로젝트를 완료하는 데 필요한 노력은 다양한 방법으로 예측
		- 예측 기능이 있는 소프트웨어를 사용한다
		- 배리 보엠의 예측 모델인 Cocomo 2와 같은 알고리즘적 방법을 사용한다
		- 외부의 측정 전문가가 프로젝트를 예측하게 한다
		- 예측을 위한 워크스루 회의를 한다
		- 프로젝트의 부분별로 예측해 각 부분에 대한 예측을 모두 합한다
		- 사람들이 자신의 작업을 예측하게 하고 각 작업에 대한 예측을 모두 합한다
		- 이전 프로젝트에 대한 경험을 참조한다
		- 이전 예측을 보관하고 그것이 얼마나 정확한지 본다
	- ***목표를 수립하라***
	- ***예측을 위한 시간을 내서 계획하라***
		- 큰 프로젝트를 예측하고 있다면 예측을 하나의 작은 프로젝트로 취급해 잘할 수 있도록 계획을 수립하는 시간을 갖도록 한다
	- ***소프트웨어 요구사항을 자세히 적어라***
        - 예측하기 전에 요구사항을 정의하거나 사전 조사 단계를 계획한다
	- ***하위 수준의 세부 사항을 예측하라***
	        - 일반적으로 조사가 자세할수록 예측은 더 정확해진다
	- ***여러 가지 예측 기법을 사용하고 그 결과를 비교하라***
	- 서로 다른 접근 방법에서 얻은 서로 다른 결과를 연구한다
	- 서로 다른 예측 기법으로부터 어떻게 다른 결과를 얻을 수 있는지 확인해본다
	- ***주기적으로 다시 예측하라***
		- 소프트웨어 프로젝트에 관련된 요인은 초기 측정 후에도 변하기 때문에 주기적으로 예측을 갱신하기 위한 계획을 수립한다
	- 구현의 양에 대한 예측
	- 구현이 프로젝트 일정에 미치는 영향의 정도는 상세한 설계, 코드 작성 및 디버깅, 단위 테스트와 같은 구현이 프로젝트에서 차지하는 비중에 달려있다
	- 일정에 미치는 영향
		- 소프트웨어 프로젝트의 일정에 가장 큰 영향을 미치는 것은 만들 프로그램의 크기
	- 다른 요소 역시 소프트웨어 개발 일정에 영향을 미친다
        ![[codeComplete64.png]]
- 일정에 미치는 요인들
	- 요구사항 개발 경험과 능력
	- 개발자의 경험과 능력
	- 팀의 동기
	- 관리 품질
	- 재사용된 코드의 양
	- 인원 교체율
	- 요구사항의 변동성
	- 고객과의 관계의 품질
	- 요구사항에서의 사용자 참여
	- 응용 분야에 대한 고객의 경험
	- 개발자가 요구사항 개발에 참여하는 정도
	- 컴퓨터와 프로그램, 데이터에 대한 보안 환경
	- 문서의 양
	- 프로젝트 목표
- 예측과 관리
	- 초기 예측의 정확성은 일정을 맞추기 위한 자원 제어에 성공하는 것보다 훨씬 덜 중요
- 일정에 뒤처졌을 때 해야 할 일
	- ***일정을 맞출 수 있다는 희망을 품어라***
	- ***팀을 키워라***
        - 일정이 늦은 소프트웨어 프로젝트에 사람을 추가하는 것은 프로젝트의 일정을 더 늦춘다
		- 새로운 사람이 무언가를 생산하기 전에 프로젝트에 익숙해지기 위한 시간이 필요
        - 프로젝트의 작업을 나눌 수 있다면 프로젝트 마지막 단계에서 사람들을 투입해 프로젝트를 나누어 다른 사람에게 일을 할당할 수 있다
	- ***프로젝트의 범위를 축소하라***
		- 제품을 초기에 계획할 때 제품의 능력을 “반드시 갖추어야 할 것”, “가지면 좋은 것”, “선택적인 것”으로 분류
		- 일정이 늦어지면 “선택적인 것”과 “가지면 좋은 것”에 대한 우선순위를 매겨 가장 덜 중요한 것을 뺀다
## 28.4 측정

- 프로세스를 측정해야 하는 이유
	- ***어떤 프로젝트 속성이든 측정하는 것이 측정하지 않는 것보다 낫다***
		- 측정 결과가 완벽하게 정확하지 않고 측정하기 어려울 수도 있으며 계속 개선되어야 할지도 모르지만, 측정은 측정하지 않고는 가질 수 없는 지침을 소프트웨어 프로젝트 프로세스에 제공할 수 있다
	- ***측정의 부수 효과를 주의하라***
		- 측정할 것을 신중하게 선택
		- 측정은 동기를 부여하는 효과가 있다
	- ***측정을 반대하는 것은 실제로 프로젝트에서 무슨 일이 일어나고 있는지 모르는 게 낫다고 주장하는 것이다***
- 유용한 소프트웨어 개발 측정들
	![[codeComplete65.png]]
## 28.5 개발자를 사람으로 대우하기

- 개발자들은 어떻게 시간을 보내는가?
	![[codeComplete66.png]]
- 성능과 품질의 다양성
	- 개인 차이
		- 최고의 개발자와 최악의 개발자 간
			- 초기 코드 작성 시간은 20:1
			- 디버깅은 25 : 1
			- 프로그램의 크기는 5:1
			- 프로그램의 수행 속도는 10:1
			- 그들 사이의 경험, 코드의 품질, 생산성 사이에는 아무 연관성이 없다
	- 팀별 차이
		- 프로그래밍팀도 소프트웨어 품질과 생산성에서 큰 차이를 보인ㄷ아
		- 프로그래밍 팀에 대한 초기 연구에서는 프로그램의 크기는 5:1, 같은 프로젝트를 완료하는 데 팀에 필요한 시간은 2.5:1
		- 하위 10%에 해당하는 개발자가 아니라 상위 10%에 해당하는 개발자를 고용하기 위해 더 큰 비용을 지급해야 한다면 기꺼이 그렇게 하라
		- 훌륭한 개발자는 서로 모이는 경향이 있으므로 조직의 다른 다른 개발자의 질과 생산성에서도 부차적인 효과를 얻게 된다
- 신앙적인 문제
	- 신앙적인 문제
		- 프로그래밍 언어
		- 들여쓰기 방식
		- 중괄호의 위치
		- IDE의 선택
		- 주석 작성 방식
		- 효율성과 가독성 간의 트레이드오프
		- 방법론의 선택( 스크럼, 익스트림 프로그래밍 등)
		- 프로그래밍 유틸리티
		- 이름 규약
		- goto의 사용
		- 전역 변수 사용
		- 측정, 특히 하루에 작성한 코드의 줄 수 같은 생산성 측정
	- 신앙적인 부분에서 개발자를 제어할 때 고려해야하는 것
		- ***자신이 민감한 영역을 다루고 있다는 것을 인식하라***
		- ***해당 영역에 대한 “제안”이나 “지침”을 사용하라***
			- 엄격한 규칙이나 표준을 정하지 말라
		- ***분명한 지시를 피함으로써 문제를 능숙하게 처리하라***
			- 들쓰기 방식이나 중괄호의 위치에 대한 문제를 처리하려면 작업이 끝나기 전에 소스코드에 대해 프리티 프린터 사용
		- ***개발자들이 자신만의 표준을 개발하게 하라***
- 물리적인 환경
    - 물리적인 환경은 생산성에 큰 차이를 만든다
		![[codeComplete67.png]]
## 28.6 관리자 관리
- 관리자를 다루는 방법
	- 자신이 원하는 것에 대한 아이디어를 정리한 다음, 고관리자가 그 아이디어를 수행하는 것에 대해 생각할 때까지 기다린다
	- 작업을 수행하기 위한 올바른 방법에 대해 관리자에게 교육하라
	- 관리자가 자신에게 바라는 것을 처리하면서 관리자의 흥미에 초점을 맞추고 관리자가 불필요한 구현 세부 사항으로 방해받지 않게 하라
	- 관리자가 지시하는 것을 거부하고 자기 일을 올바른 방식으로 계속 진행하라
	- 다른 직업을 찾아라
# 29장 통합
## 29.1 통합 접근 방법의 중요성
- 신중한 통합의 이익
	- 더 쉬운 결함 진단
	- 더 적은 결함
	- 더 적은 비계
	- 첫 번째 제품 완성 시간 단축
	- 전체적인 개발 일정 단축
	- 더 나은 고객과의 관계
	- 의욕 고취
	- 프로젝트 완성 기회 향상
	- 더 신뢰할 수 있는 일정 측정
	- 더 정확한 상황 보고
	- 향상된 코드 품질
	- 더 적은 문서
## 29.2 통합 빈도-단계별 또는 점증적 접근 방법
- 단계별 통합
	- 단계별 통합 단계
		1. 각 클래스를 설계하고 작성하고 테스트하고 디버깅한다 ⇒ 단위 개발
		2. 클래스를 하나의 큰 시스템으로 결합한다
		3. 전체 시스템을 테스트하고 디버깅한다 ⇒ 시스템 분해
- 단계별 통합이 가진 한 가지 문제는 시스템에 있는 클래스가 처음 통합될 때 불가피하게 새로운 문제점이 발생하고 그 문제점의 원인이 발생한 곳을 예상할 수 없다
	- 작은 프로그램에서는 단계별 통합이 최고의 접근 방법
	- 대부분의 경우 다른 접근 방법이 낫다
- 점증적 통합
	- 점증적 통합 단계
		1. 시스템에서 크기가 작고 기능적인 부분을 개발한다. 그런 부분을 전체적으로 테스트하고 디버깅
		2. 클래스를 설계하고 코드를 작성하고 테스트하고 디버깅
		3. 새로운 클래스를 뼈대에 봉합.뼈대와 새로운 클래스를 결합하는 것을 테스트 하고 디버깅. 작업이 남았다면 2단계부터 다시 반복

	- 점증적 통합의 이점
		- ***오류를 찾기가 쉽다***
			- 점증적 통합에서 새로운 문제점이 발생할 때, 새로운 클래스가 분명히 오류와 관련이 있다
		- ***시스템이 프로젝트 초기부터 작동한다***
			- 시스템을 사용할 수는 없을지라도 코드를 통합하고 결과물이 작동하면 시스템도 정상적으로 작동할 것이 분명해진다
		- ***진행 상황을 좀 더 잘 관찰할 수 있다***
			- 자주 통합하면 현재 지원되는 기능과 그렇지 않은 기능이 분명해진다
		- ***고객과의 관계가 향상될 것이다***
			- 고객은 무언가를 진행되는 것을 좋아하며 증분 빌드는 빈번하게 진행되고 있다는 신호를 제공한다
		- ***시스템 요소를 더 완전히 테스트한다***
			- 통합은 프로젝트 초기 단계에 시작한다
			- 각 클래스는 단계별 통합보다는 점증적 통합을 사용할 때 전체 시스템의 일부로 더 자주 사용
		- ***더 짧은 개발 일정으로 시스템을 만들 수 있다***
			- 통합을 신중하게 계회갛면 한 부분을 작성하는 동안 시스템의 다른 부분을 설계할 수 있다
			- 이것이 완전한 설계와 코드를 개발하는 데 필요한 전체 작업 시간이 줄지는 않지만, 작업을 병렬로 처리할 수 있어 일정이 무엇보다 중요할 때 도움이 된다
## 29.3 점증적 통합 전략
- 하향식 통합
	- 계층 구조의 상위에 있는 클래스를 먼저 작성하고 통합
	- 하향식 통합의 중요한 특징은 클래스 사이의 인터페이스를 신중하게 명시해야한다는 것
	- 장점
		- 하향식 접근 방법은 시스템의 제어 논리 구조를 비교적 일찍 테스트할 수 있다
		- 제대로만 계획한다면 프로젝트 초기 단계부터 부분적으로 작동하는 시스템을 완성할 수 있다
		- 하향식 점증적 통합을 통해 하위 수준 설계 세부사항이 완성되기 전에 코드 작성을 시작할 수 있음
	- 단점
		- 순수한 하향식 통합에서는 까다로운 시스템 인터페이스를 마지막깢 사용해볼 수 없다
		- 하위 수준에서의 문제점이 시스템의 상위 수준까지 영향을 미쳐 상위 수준을 변경해야 하는 바람에 초기 통합 작업으로 얻은 이득을 반감시키는 경우가 많다
			- 초기 단계부터 주의 깊게 개발자 테스트를 진행하고 시스템 인터페이스를 다루는 클래스의 성능을 분석하고 최소화할 것
		- 하향식으로 통합하기 위해 엄청나게 많은 스텁 코드가 필요하다
		- 이론대로 진행하기 거의 불가능하다
		- 클래스 집합에 최상위라는 개념이 없으면 하향식 통합을 사용할 수가 없다. 많은 대화식 시스템에서는 “상위”의 위치가 주관적
- 상향식 통합
	- 계층 구조의 맨 아래부터 클래스를 작성하고 통합
	- 저수준 클래스를 한 번에 하나씩 추가
		![[codeComplete68.png]]
	- 장점
		- 상향식 통합에서는 오류의 원인을 통합하는 단일 클래스로 제한하기 때문에 오류를 찾기 쉽다
		- 통합을 프로젝트 초기 단계에서 시작할 수 있음
		- 시스템 인터페이스를 초기에 사용
	- 단점
		- 마지막에 가서야 고수준 시스템 인터페이스를 통합할 수 있다
		- 시스템이 상위 수준에서 개념적인 설계상 문제점을 갖고 있다면 모든 세부 작업이 처리될 때까지 구현 과정에서 그런 문제점을 발견할 수 없을 것이다
		- 통합을 시작하기 전에 전체 시스템 설계를 마쳐야한다. 그렇지 않으면 설계 시 다루지 않았던 가정이 저수준 코드에 깊게 포함되게 될 것이며 결국 저수준 코드에서 발생한 문제점을 해결하려고 상위 수준 클래스를 설계해야 하는 문제가 발생한다
	- 샌드위치 통합
		- 상위 수준에서 고수준 비지니스 객체 클래를 통합한 후 장치-인터페이스 클래스와 하위 수준에서 널리 사용되는 유틸리티 클래스를 통합
		- 중간클래스는 마지막으로 통합
		- 이런 접근 방법은 순수한 상향식이나 하향식 통합의 엄격함을 피해하고 자주 문제가 되는 클래스를 우선 통합해 피룡한 비계의 양을 최소화할 수 있다
	- 위험 지향적인 통합
		- 어려운 부분 우선 통합
		- 각 클래스와 연관된 위험 수준을 규명하고 가장 어려운 부분이 무엇인지 결정해 그 부분을 먼저 구현
		- 경험적으로 최상위 인터페이스에 위험 요소가 많기 때문에 일반적으로 최상위 인터페이스가 위험 요소 목록의 상위에 오른다. 하위 요소도 마찬가지
		- 쉬운 부분은 나중까지 기다려도 된다
			![[codeComplete69.png]]

- 기능 지향적인 통합
	- 한 번에 하나의 기능을 통합
	- 점증적 통합 전략을 사용해 기능을 구성하는 작은 부분을 반복적으로 통합하고 점증적으로 기능을 통합해 하나의 시스템을 구성
		![[codeComplete70.png]]

	- 장점
		- 저수준 라이브러리 클래스를 제외하고 실질적으로 어떠한 기능에도 비계가 필요없다
			- 각 기능에 골격이 붙으면 추가적인 비계가 필요 없다. 각 기능이 독립적이기 때문에 자신에게 필요한 모든 코드를 담고 있다
		- 새로 통합되는 기능을 점증적으로 추가한다는 점
			- 프로젝트가 꾸준히 앞으로 나가고 있다는 증거
		- 기능 지향적인 통합이 객체지향 설계에서 잘 작동한다는 점
- T-자형 통합
    - 초기 개발과 통합을 위해 특정한 수직적인 부분이 선택. 그 부분은 시스템을 구석구석 사용해야하며 시스템의 설계 시 가정한 중요한 문제점을 제거해야한다
    - 일단 수직적인 부분이 구현되고 연관된 문제점이 수정되면 시스템의 전체적인 부분을 개발
		![[codeComplete71.png]]
## 29.4 일일 빌드와 스모크 테스트

- 일일 빌드와 스모크 테스트
	- 스모크 테스트의 장점
		- 실패하거나 문제가 있는 통합 위험과 관련된 위험인 품질 저하의 위험을 줄여준다
			- 매일 스모크 테스트하면 품질 문제가 프로젝트를 장악하는 것을 예방할 수 있다
		- 더 쉽게 결함을 진단할 수 있다
		- 빈번한 통합이 가져오는 부수적인 효과 중 하나는 통합을 함으로써 프로젝트 마지막에 가서야 갑자기 나타날 때까지 숨겨진 채 쌓일 수 있는 작업을 겉으로 드러나게 한다는 점

	- 일일 빌드의 장점
		- ***매일 빌드한다***
			- 빌드의 주기를 짧게 유지하면 전체적으로 개발자가 동기화에 어긋나는 것을 예방할 수 있다
		- ***깨진 빌드를 확인한다***
			- 좋은 빌드란?
				- 모든 파일과 라이브러리, 다른 컴포넌트를 성공적으로 컴파일해야한다
				- 모든 파일과 라이브러리, 다른 컴포넌트를 성공적으로 링크해야 한다
				- 프로그램이 실행되지 못하게 하거나 실행하기 위험하게 만드는 심각한 버그를 포함하지 않아야 한다.즉, 좋은 빌드는 스모크 테스트를 통과해야 한다
		- ***매일 스모크 테스트한다***
			- 스모크 테스트는 전체 시스템을 처음우버 끝까지 실행해야 한다. 완전할 필요는 없지만, 중요한 문제점을 노출할 수 있어야 한다

	- ***스모크 테스트를 최신으로 유지한다***
		- 스모크 테스트가 최신으로 유지되지 않는다면 일일 빌드는 테스트 케이스 일부가 품질에 대한 잘못된 자신감을 느끼게 해 자기기만에 빠질 수 있는 작업이 될 수 있다
	- ***일일 빌드와 스모크 테스트를 자동화한다***
	- ***빌드 그룹을 만든다***
		- 대부분의 프로젝트에서는 일일 빌드하고 스모크 테스트를 최신으로 유지하는 일이 누군가가 전담해야 할 정도로 큰 일이다

	- ***타당한 경우에만 빌드에 수정된 내용을 추가한다***
		- 많은 양의 코드를 작업한 다음 안정된 코드가 모였을 때 통합해야 한다.
		- 일반적으로 며칠에 한 번 이 작업을 수행
	- ***하지만 수정된 내용을 추가하는 데 너무 오래 기다리지는 않는다***
		- 개발자가 변경된 사항을 검사하지 않고 이틀 이상 개발을 진행했다면 그가 작성한 코드는 위험하다고 간주
	- ***개발자가 작성한 코드를 시스템에 추가하지 전에 스모크 테스트하게 한다***
		- 개발자들은 빌드에 코드를 추가하기 전에 자신이 작성한 코드를 테스트할 필요가 있다
	- ***빌드에 추가되는 코드를 보관할 장소를 만든다***
		- 큰 프로젝트나 정교하지 않은 버전 관리 소프트웨어를 사용하는 프로젝트에서는 보관 장소 기능을 직접 처리
		- 빌드 그룹이 개발자가 새로운 소스 파일을 올려놓을 수 있도록 파일 서버에 체크인 공간을 만든다. 그러면 빌드 그룹은 새로운 코드가 빌드를 망가뜨리지 않는다는 것을 검증하고 난 후 새로운 코드를 버전 관리에 추가
	- ***빌드를 망치는 사람을 위한 벌칙을 정한다***
		- 처음부터 확실하게 빌드를 완전하게 유지하는 것을 프로젝트의 최우선 순위로 둔다
		- 망가진 빌드는 규칙이 아니라 예외가 되어야 한다
        - ***아침에 빌드를 배포한다***
		- 아침에 배포하면 새로운 빌드로 그날 테스트할 수 있다
		- 아침에 빌드를 완성하면 빌드에 문제가 생겼을 때 개발자들에게 좀 더 의지할 수 있다

	- ***일정의 압박이 있더라도 빌드와 스모크 테스트를 진행한다***

- 어떤 종류의 프로젝트에 일일 빌드 프로세스를 사용할 수 있는가?
	- 프로젝트의 시작, 중간단계에서 사용할 수 있다

  

## 체크리스트
![[codeComplete72.png]]  

# 30장 프로그래밍 도구

## 30.1 설계 도구
- 설계 도구
	- 설계 다이어 그램을 만드는 그래픽 도구
	- 그래픽 표기법(UML이나 아키텍처 블록 다이어그램, 계층적 차트, ERD, 클래스 다이어그램)
## 30.2 소스코드 도구
- 편집
	- 통합 개발 환경(IDE)의 기능
		- 편집기 내에서 컴파일과 오류 검출
		- 소스코드 제어와 빌드, 테스트, 디버깅 도구와 통훕
		- 프로그램에 대한 집약적 뷰나 개략적인 뷰
		- 클래스와 루틴, 변수 정의로 이동
		- 클래스나 루틴, 변수가 사용된 모든 위치로 이동
		- 언어에 따른 형식화
		- 편집 중인 언어에 대한 상호작용하는 도움말
		- 괄호 일치
		- 공통적인 언어 구현에 대한 템플릿
		- 똑똑한 들여쓰기
		- 자동화된 코드 변형이나 리팩터링
		- 친숙한 프로그래밍 언어로 프로그래밍할 수 있는 매크로
		- 자주 사용되는 문자열을 재입력할 필요가 없도록 검색 문자열을 나열하는 기능
		- 찾고 바꾸기의 정규 표현식
		- 여러 파일에서 찾아 바꾸기
		- 여러 개의 파일 동시에 편집하기
		- 파일의 차이점 비교
		- 여러 단계의 실행 취소
- 다중 파일 문자열 검색 및 바꾸기
```cpp

grep "\[ *[0.9]+ *\" *.cpp

```

- 차이 비교 도구
	- diff 같은 도구
- 병합 도구
	- 소스코드 정돈 도구
		- 소소코드를 입력으로 받아들여 원본 소스코드를 변경하지 않고 더 좋은 소스코드를 출력
		- 들여쓰기를 표준화하고 매개변수 목록을 형식화하는 등 소스코드 자체를 변경
- 인터페이스 문서화 도구
	- 소스 파일에 있는 코드는 추출될 텍스트를 명시하는 데 @tag 필드와 같은 단서 사용
	- .javadoc와 같은 도구
- 템플릿
	- 참조 도구
	- 클래스 계층 구조 생성기
		- 상속 트리에 관한 정보 생성
		- 디버깅 시 유용하지만 , 프로그램의 구조를 분석하거나 프로그램을 패키지나 서브 시스템으로 모듈화할 때 자주사용

- 코드 품질 분석
	- 까다로운 문법 및 의미 검사기
	- 메트릭 보고 도구
		- 코드의 품질 검사
- 소스코드 리팩터링
	- 리팩터링 도구
		- 일반적인 코드 리팩터링 지원
	- 재구성 도구
	- 코드 변환 도구
        - 어떤 도구들은 코드를 다른 언어로 변환한다
- 버전 관리가 다룰 수 있는 것
	- 소스코드 제어
	- UNIX의 make 유틸리티가 제공하는 의존성 제어
	- 프로젝트 문서 버전 관리
	- 프로젝트와 관련된 결과물
- 데이터 사전
	- 많은 경우 데이터 사전은 주로 db 스키마로 다룸
## 30.3 실행 가능한 코드 도구
- 코드 생성
	- 컴파일러와 링커
		- 컴파일러는 소스코드를 실행 가능한 코드로 변환
		- 표준 링커는 컴파일러가 소스코드로부터 생성한 하나 이상의 객체 파일과 실행 가능한 프로그램을 만드는 데 필요한 표 준 코드를 연결
			- 링커는 여러 언어로 만든 파일을 서로 연결할 수 있어 통합 관련 세부 사항을 직접 처리하지 않고도 프로그램의 각 부분에 가장 잘 맞는 언어로 코드를 작성할 수 있다
- 빌드 도구
	- ant, maven
- 코드 라이브러리
	- 오픈소스를 통해 코드를 사용하는 것
- 코드 생성 마법사
	- db와 사용자 인터페이스, 컴파일러를 위한 코드 작성
	- 코드 생서기는 제품 코드의 프로토타입을 만드는 데도 유용
	- 코드 생성기의 일반적인 단점은 읽기가 거의 어려운 코드를 생성하는 경향이 있다
- 설정과 설치
	- 전처리기
		- 전처리기와 전처리기 매크로 함수는 개발 코드와 제품 코드를 전환하는 작업을 쉽게 해주기 때문에 디버깅에 유용
- 디버깅에 도움을 주는 도구
	- 컴파일러 경고 메시지
	- 테스트 비계
	- Diff
	- 실행 프로파일러
	- Trace 모니터
	- 소프트웨어와 하드웨어적인 대화식 디버거
- 테스트
	- JUnit과 같은 자동화된 테스트 프레임워크
	- 자동화된 테스트 생성기
	- 테스트 케이스 기록과 실행 유틸리티
	- 커버리지 모니터
	- 심볼릭 디버거
	- 시스템 교란기
	- Diff
	- 비계법
	- 결함 주입 도구
	- 결함 추적 소프트웨어
- 코드 튜닝
	- 실행 프로파일러
		- 실행 프로파일러는 프로그램이 실행되는 동안 코드를 감시한 후 각 명령문의 실행 횟수나 각 명령문을 실행하는 데 걸린 시간 또는 실행 경로를 말해준다
		- 프로파일러는 프로그램이 어떻게 작동하는지, 가장 문제가 될 만한 곳이 어딘지, 어느 코드를 집중적으로 튜닝해야 하는지 알려준다
	- 어셈블리 소스와 디스어셈블러
		- 어셈블리 언어에 익숙하지 않고 간단한 소개를 원한다면 고급 언어 명령문을 컴파일러에 의해 생성된 어셈블러 명령과 비교하는 것보다 좋은 방법은 없다
## 30.4 도구 지향적인 환경
- 도구 지향적인 환경
	- 몇몇 환경은 다른 환경보다 도구 지향적인 프로그래밍에 적합하다
		- unix의 grep, diff, sort, make, crypt, tar, lint,  ctags, sed, awk, vi와 같이 서로 함께 잘 작동하는 재밌는 이름의 작은 도구를 모아 놓은 것으로 유명
## 30.5 자신만의 프로그래밍 도구 개발

- 프로젝트에 특화된 도구
	- 대부분 중간 크기 이상의 프로젝트는 프로젝트에 특화된 도구가 필요하다
	- 프로젝트의 계획을 세울 때는 필요한 도구를 생각하고 그러한 도구를 작성하는 데 걸리는 시간을 할당해야한다
- 스크립트
	- 스크립트는 반복적인 작업을 자동화하는 도구
	- 예시
```

crypto c:\word\journal.* %1 /d /Es /s

word c:\word\journal.doc

crypto c:\word\journal.* %1 /d /Es /s

```
## 30.6  프로그래밍 도구에 대한 환상
>[!important]
> 💡 프로그래밍 도구가 끊임없이 발전하는 이유는 프로그래밍이 어렵기 때문이다

# 체크리스트
![[codeComplete73.png]]