- 최고 수준의 개발자가 되기 위해서는 단위 테스트를 기능 테스트를 비롯한 다른 테스트와 구분할 수 있어야 한다

## 5.1 단위 테스트를 하는 이유
- 단위 테스트 수행 시 장점
	- 기능 테스트만 수행했을 때보다 테스트 커버리지를 높일 수 있다
	- 팀 생산성이 향상된다
	- 회귀(regression)를 사전에 발견해 디버깅 작업을 줄일 수 있다
	- 소스를 리팩터링하거나 변경할 때 개발자에게 확신을 준다
	- 애플리케이션 기능 구현에 도움을 준다
	- 코드의 예상 동작을 문서화할 수 있다
	- 코드 커버리지를 비롯해 다양한 지표를 측정하게 해 준다
### 5.1.1 테스트 커버리지를 높일 수 있다
- 단위 테스트 작성과 기능 테스트 작성 중 하나만 해야 한다면 기능 테스트를 작성해야 하지만, 경험적으로 기능 테스트로는 애플리케이션 코드의 약 70%를 커버할 수 있다
- 기능 테스트로 커버하는 수준보다 더 높은 테스트 커버리지를 얻어야 한다면 단위 테스트를 작성하는 것이 좋다
- 단위 테스트는 기능 테스트로는 수행이 어렵거나 불가능한 오류 조건에 대해서도 쉽게 테스트할 수 있다

### 5.1.2 팀 생산성이 향상된다
- 단위 테스트를 활용하면 다른 컴포넌트가 준비될 때까지 기다리지 않고도 질적으로 우수한 코드(즉 테스트 코드)를 전달할 수 있다

### 5.1.3 회귀를 사전에 발견해 디버깅 작업을 줄일 수 있다
- 통과하는 단위 테스트 묶음은 코드가 제대로 동작하는지 확인해 주고 기존 소스를 리팩터링하거나 새로운 기능을 추가 또는 수정할 때 개발자에게 확신을 준다
- 단위 테스트 묶음을 사용하면 어디에 문제가 있는지 알 수 있고 애플리케이션을 일일이 디버깅할 필요도 줄어든다

### 5.1.4 자신 있게 리팩터링할 수 있다
- 단위 테스트가 없으면 리팩터링을 정당화하기 어렵다. 소스를 고치는 일에는 항상 오류를 만들 위험이 내포되어 있기 때문이다
- 단위 테스트를 통해 리팩터링에 대한 확신을 주고 안전망을 제공할 수 있다

### 5.1.5 기능 구현에 도움이 된다
- 단위 테스트는 테스트가 필요한 코드의 가장 중요한 클라이언트
- 단위 테스트는 테스트 중인 API를 유연하게 만들고 격리된 상태에서 테스트가 가능하게끔 만들어준다
- 단위 테스트를 만들고 수정할 때는 단위 테스트를 잘 관찰하는 것이 중요.
	- 단위 테스트가 너무 길고 다루기 힘들다면, 일반적으로 테스트 대상 코드에 설계에 문제가 있는 것이며 리팩터링이 필요

### 5.1.6 코드의 예상 동작을 문서화할 수 있다
- 단위 테스트는 그 자체로 API 사용 예제가 된다. 따라서 테스트 그 자체로 개발자에게 훌륭한 설계 문서가 될 수 있다

### 5.1.7 코드 커버리지 및 다양한 지표를 측정할 수 있게 해 준다
- 단위 테스트는 버튼만 누르면 모든 프로그램이 여전히 잘 동작하는지를 알려 준다
- 단위 테스트는 라인별로 테스트가 실행 되었는지 되지 않았는지 보여 주는 코드 커버리지 지표도 제공한다
- 도구를 사용해 진행한 빌드에서 다음 빌드까지 테스트 통과/실패의 진행 상황도 추적할 수 있다

## 5.2 테스트 유형
- 테스트 유형
	- 단위 테스트
	- 통합 테스트
	- 시스템 테스트
	- 인수 테스트

### 5.2.1 단위 테스트
- 단위 테스트는 소스 코드의 개별 단위(메서드나 클래스)를 테스트해 해당 코드를 사용할 수 있는지를 결정하는 소프트웨어 기법
- 단위 테스트는 개발 과정에서 발생할 수 있는 잠재적 오류로부터 개발자를 보호하는 안전망 역할
- 단위 테스트는 개별 단위를 격리해 테스트하는 것이 중요

### 5.2.2 통합 테스트
- 통합 테스트는 대상 환경에서 실행 가능한 컴포넌트 간의 상호작용을 테스트 하는 것

| 상호작용   | 테스트 설명                                                                                                                                                                                      |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 객체     | 테스트는 객체를 인스턴스화하고 다른 객체의 메서드를 호출한다. 통합 테스트를 통해 다른 클래스에 속한 객체 간에 어떻게 협력해서 문제를 해결할 수 있는지 확인할 수 있다                                                                                              |
| 서비스    | 통합 테스트는 컨테이너가 애플리케이션을 관리하는 동안 실행된다. 그동안 애플리케이션은 데이터베이스와 연동되어 있거나 다른 외부 리소스, 장치와 통신할 수 있다. 컨테이너에 배포되는 애플리케이션을 개발할 때 통합 테스트를 활용할 수 있다                                                         |
| 서브 시스템 | 계층적 애플리케이션에서는 화면을 관리하는 프론트엔드와 비지니스 로직을 수행하는 백엔드로 구분된다. 통합 테스트를 가지고 프론트엔드를 통과한 요청이 백엔드에서 적절한 응답을 반환하는지 확인할 수 있다. 웹 인터페이스와 같은 프론트엔드와 비지니스 로직을 수행하는 백엔드가 구분된 아키텍처를 가진 애플리케이션은 통합 테스트를 활용할 수 있다 |
- 이상적으로는 애플리케이션 코드를 작성하기 전에 통합 테스트부터 정의해야 한다
- 통합 테스트 코드 작성은 개발자가 올바르게 동작하는 객체를 만드는 능력을 향상시키는 데 도움이 된다

### 5.2.3 시스템 테스트
- 시스템 테스트는 시스템이 구체화된 요구 사항을 만족하는지 평가하기 위해 완전히 통합 환경에서 수행하는 테스트
- 시스템 테스트의 목표는 통합되어 있는 단위 간의 불일치를 찾아내는 것
- test double이나 mock object 는 복잡한 실제 객체의 동작을 모사할 수 있으므로, 컴포넌트를 테스트에 통합하는 것이 불가능하거나 지금 당장은 사용할 수 없을 때 유용하게 사용할 수 있다
- 개발팀에서 프로그램에 모의 데이터베이스 사용 가능

### 5.2.4 인수 테스트
- 인수 테스트는 최종 수준의 테스트 단계
- 애플리케이션이 고객이나 이해관계자가 정의한 목표를 달성하는지 확인하기 위해 사용
- 최상위 수준의 테스트
- 인수 테스트를 활용하면 애플리케이션이 비지니스 목표를 달성하고 기획한 작업을 제대로 하고 있는지와 같은 필수적인 질문에 답할 수 있다

## 5.3 블랙박스 테스트 대 화이트박스 테스트
### 5.3.1 블랙박스 테스트
- black-box test
	- 시스템의 내부 상태나 동작에 대한 지식이 없을 때 수행하는 테스트
	- 정확성을 검증하기 위해 외부적인 시스템 인터페이스를 사용
	- 시스템을 블랙박스 취급
	- 일반적으로 프로젝트 초기에 기능 명세를 작성하므로 비교적 일찍 시작할 수 있다
	- 가장 단순한 형태는 사용자 인터페이스에서 수동으로 직접 작업해보는 것
	- 조금 더 정교한 방법은 HttpUnit, HtmlUnit, Selenium과 같은 도구를 사용하는 방법이 있다
### 5.3.2 화이트박스 리스트
- white-box testing
	- glass-box testing(유리 상자 테스트)라고도 한다
	- 구현에 관한 해박한 지식을 바탕으로 테스트를 만들고 테스트 프로세스를 진행
	- 테스트 프로세스가 다른 구성 요소와 상호작용하는 방식을 알아야한다 -> 화이트박스 테스트를 실행하는 데는 개발자가 적격
	- GUI를 사용할 수 있을 때까지 기다릴 필요가 없으므로 화이트박스 테스트는 프로젝트 초기 단계에서 구현 가능

### 5.3.3 장단점 비교
- 블랙박스 & 화이트박스 장점 비교

| 블랙박스 테스트                               | 화이트박스 리스트                      |
| -------------------------------------- | ------------------------------ |
| 사용자 중심적이며 설계 명세와 다른 부분이 무엇인지 바로 알 수 있다 | 프로젝트 초기부터 테스트를 구현할 수 있다        |
| 테스터가 비개발자여도 상관없다                       | GUI가 필요하지 않다                   |
| 개발자와 독립적으로 수행할 수 있다                    | 개발자가 제어하므로 다양한 실행 경로를 커버할 수 있다 |
- 블랙박스 & 화이트박스 단점 비교

| 블랙박스 테스트                                                       | 화이트박스 리스트                      |
| -------------------------------------------------------------- | ------------------------------ |
| 입력할 수 있는 경우의 수가 제한적이다                                          | 프로그래밍 지식이 있는 사람만 테스트를 구현할 수 있다 |
| 커버되지 않은 실행 경로가 많을 수 있다                                         | 구현을 변경하려면 테스트를 다시 작성해야 한다      |
| 테스트가 중복될 수 있다. 세부 정보가 없다는 것은 동일한 실행 경로를 여러 번 커버할 수 있다는 것을 의미한다 | 테스트와 구현이 밀접하게 결합되어 있다          |
- 사용자 중심 접근
	- 블랙박스 테스트는 먼저 사용자 요구 사항을 해결
- 테스트의 어려움
	- 블랙박스 테스트는 웹 브라우저 혹은 데스크톱 애플리케이션 혹은 프론트엔드를 구현해야 하므로 테스트 작성과 실행이 더 어렵다
	- 화면에 나타난 결과가 예상한 바와 동일해도 그것이 애플리케이션이 항상 정확하게 작동했다는 것을 보장하지는 않는다
	- 화이트박스 테스트는 일반적으로 블랙박스 테스트보다 테스트 작성과 실행이 더 쉽지만 개발자가 직접 구현해야 한다는 불편함이 있다
- 테스트 커버리지
	- 화이트박스 테스트를 이용하면 블랙박스 테스트보다 더 나은 테스트 커버리지를 얻을 수 있다
	- 블랙박스 테스트는 화이트박스 테스트보다 더 많은 비지니스적 가치가 있을 수 있다


