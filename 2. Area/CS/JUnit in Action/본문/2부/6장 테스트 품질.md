## 6.1 테스트 커버리지 측정하기
- 코드 변경으로 인해 테스트로 커버하지 못했던 기능이 동작하지 못할 수 있다
- 이를 해결하기 위해 사용자나 개발자가 테스트를 수행할 때 정확히 어떤 코드가 실행되고 어떤 코드가 실행 되지 않는지 알아야 한다
- 테스트 커버리지는 그 자체로 코드의 품질을 어느 정도 보증한다. 하지만 높은 테스트 커버리지가 테스트의 질을 보장하지는 않는다

### 6.1.1 테스트 커버리지란 무엇인가
- 테스트 커버리지 계산에 사용하는 지표
	- 테스트 묶음 실행 간 호출되는 애플리케이션의 메서드나 코드의 line 수를 가지고 나타낸 백분율
	- 테스트가 호출하는 메서드를 추적해서 집계
- 테스트 대상 메서드에 분기문이 있을 경우 각 분기마다 하나씩 단위 테스트를 작성해야 한다
- 일반적으로 화이트박스 테스트(단위 테스트)를 활용하면 더 높은 테스트 커버리지를 얻을 수 있다. 더 많은 메서드에 접근할 수 있고, 각 메서드에 대한 입력과 보조 객체의 동작을 제어할 수 있기 때문이다
- 블랙박스 테스트로 높은 코드 커버리지를 달성하지 못했다면, 보통은 더 많은 테스트가 필요하다는 의미이다. 혹은 비지니스 목표에 기여하지 않는 불필요한 로직이 있을 수 있다 => 실제 원인을 찾기 위해 분석이 필요한 부분이다

### 6.1.2 코드 커버리지를 측정하는 도구
- 코드 커버리지 도구는 JUnit과 잘 통합되어 있다
- IDE 에서 실행 가능

## 6.2 테스트하기 쉬운 코드 작성하기
### 6.2.1 public API는 정보 제공자와 정보 사용자 간의 계약이다
- 호출은 보통 외부의 다른 애플리케이션에서 일어난다. 이때 외부 애플리케이션은 해당 API의 클라이언트와 같은 역할을 한다
- public 메서드의 시그니처를 변경했다면 애플리케이션이나 단위 테스트의 메서드 호출을 전부 변경해야하므로 리팩터링 시 주의해야한다

### 6.2.2 의존성 줄이기
- 단위 테스트는 테스트 대상 클래스를 인스턴스화한 다음 테스트 대상 단위를 사용해 보고 정확성을 검증하므로, 테스트 케이스는 단순해야 한다
- 테스트하기 쉬운 코드를 작성하려면 의존성을 최대한 줄여야한다. 클래스가 인스턴스화되고 특정한 상태로 설정해야 하는 다른 클래스에 많이 의존하는 경우, 테스트하기 매우 복잡해 지고, 복잡한 모의 객체를 만들어야할 수도 있다
- 의존성을 줄이려면 메서드를 분리해야한다. 특히 객체를 인스턴스화하는 메서드(주로 팩터리 메서드)와 비지니스 로직을 갖고 있는 메서드를 분리하는 것이 중요하다 => **의존성 주입(dependency injection) 사용**

### 6.2.3 간단한 생성자 만들어 보기
- 각 테스트 케이스에서 일어나는 일들
	- 테스트할 클래스를 인스턴스화한다
	- 클래스를 특정 상태로 설정한다
	- 작업을 수행한다
	- 클래스의 최종 상태를 검증한다
- **클래스를 특정 상태로 설정하는 것은 별도의 작업으로 분리해야한다**
- 예시 - 생성자를 사용해 클래스를 특정 상태로 설정하기
```Java
class Car {
	private int maxSpeed;

	Car(){
		this.maxSpeed = 180;
	}

}
```
- 예시 - 새터 메서드 사용해 클래스를 특정 상태로 설정하기
```Java

class Car {
	private int maxSpeed;

	public void setMaxSpeed(int maxSpeed){
		this.maxSpeed = maxSpeed;
	}
}
```

### 6.2.4 데메테르 법칙 따르기
>[!note]
>데메테르의 법칙 : 최소 지식의 법칙
>클래스는 알아야 할 만큼의 정보만 가져야 한다

- 데메테르 법칙을 위반한 사례
```Java
class Car {
	private Driver driver;

	Car(Context context){
		this.driver = context.getDriver();
	}

}
```
	- Car 클래스가 context 객체에 getDriver 메서드가 있다는 것을 알아한다
	- 즉, Car 클래스의 생성자를 테스트하고 싶다면 생성자를 호출하기 전에 유효한 Context 객체를 가져오는 것이 선행되어야 한다
	- 만약 Context 객체가 다양한 변수와 메서드를 갖는다면 Context 객체를 모사한 모의 객체를 사용해야 할지도 모른다
- 해결 방안 - Driver 객체만 Car 생성자에 전달
```Java
class Car {
	private Driver driver;

	Car(Driver driver){
		this.driver = driver;
	}

}
```

### 6.2.5 숨은 의존성과 전역 상태 피하기
- 전역 상태는 매우 주의해서 관리해야 한다. 정말 많은 클라이언트가 전역 객체를 사용할 수 있기 때문이다
- 전역 상태를 공유하는 것은 때때로 의도하지 않은 결과를 만들어 낸다. 공유 접근을 고려하지 않는 코드에서 전역 객체가 사용되거나, 클라이언트가 전역 객체가 배타적일 거라 생각하고 접근할 때는 더욱 위험하다

### 6.2.6 제네릭 메서드 사용하기
- 팩터리 메서드와 같은 정적 메서드는 매우 유용하지만, 많은 정적 유틸 메서드에 문제가 있다
- **하나의 객체가 둘 이상의 IS-A 관계를 갖도록 만드는 다형성을 활용한다면 호출할 메서드가 컴파일 타임에 결정되지 않도록 만들 수 있다**
	- 다형성을 활용해 애플리케이션 코드를 테스트 코드로 대체해 특정한 코드를 테스트해 볼 수 있다
	- 정적 메서드만 사용한다면 절차적 프로그래밍을 수행할 때처럼 메서드 호출이 거의 항상 컴파일 타임에 결정된다. 코드를 유연하게 만드는 연결 지점이 사라지는 것
- 파라미터에 구체적인 타입을 명시해야 하는 정적 유틸 메서드가 있다면 반드시 제네릭을 사용해야 한다

### 6.2.7 상속보다는 합성 활용하기
- 상속보다는 합성이 테스트하기 쉽다. 런타임에 상속 구조를 변경할 수 없지만 객체를 다르게 합성하는 것은 가능하기 때문이다
- **결국 목표는 런타임 시 코드를 최대한 유연하게 만드는 것이다 **
- HAS-A 관계에서는 상속보다는 합성이 낫다

### 6.2.8 분기문보다는 다형성 활용하기
- 장황한 분기문이 들어가 있는 좋지 못한 코드
```Java
public class DocumentPrinter {
	[...]
	public void printDocument(){
		switch(document.getDocumentType()){
			case WORD_DOCUMENT:
				printWORDDocument();
				break;
			case PDF_DOCUMENT:
				printPDFDocument();
				break;
			case TEXT_DOCUMENT:
				printTextDocument();
				break;
			default:
				printBinaryDocument();
				break;
		}
	}
}
```
- 다형성을 활용해 복잡한 분기문 리팩터링 하기
```Java
public class DocumentPrinter {
	[...]
	public void printDocument(Document document){
		document.printDocument();
	}

	public abstract class Document {
		[...]
		public abstract void printDocument();
	}

	public class WordDocument extends Document {
		[...]
		public abstract void printDocument(){
			printWORDDocument();
		}
	}

	public class PDFDocument extends Document {
		[...]
		public abstract void printDocument(){
			printPDFDocument();
		}
	}

	public class TextDocument extends Document {
		[...]
		public abstract void printDocument(){
			printTextDocument();
		}
	}
}
```

## 6.3 TDD
>[!important]
>TDD
>개발자가 테스트를 먼저 작성한 다음 테스트를 통과하는 코드를 작성하는 프로그래밍 기법
>코드를 작성한 다음 코드를 검사하고 난잡한 부분을 정리하거나 코드의 질을 높이기 위해 리팩터링한다
>TDD의 목적은 '작동하는 클린 코드'를 만드는 것이다

### 6.3.1 개발 주기에 적용하기
- 통념적인 개발 주기
>[!note]  코드를 작성한다, 테스트 한다, (반복한다)
- TDD를 따르는 개발 주기
>[!note] 테스트 한다, 코드를 작성한다 , (반복한다)

- TDD
	- TDD의 테스트는 설계를 주도하고, 메서드의 첫 번째 클라이언트가 된다
	- 장점
		- 목적이 분명한 코드를 작성할 수 있고, 개발자는 애플리케이션이 필요로 하는 것을 정확하게 개발했다는 확신을 얻을 수 있다. 코드를 설계하는 테스트를 사용할 수 있다
		- 새로운 기능을 더 빨리 적용할 수 있다. 테스트는 개발자가 의도대로 코드를 구현하게 유도하는 힘이 있다
		- 테스트는 정상적으로 작동하는 기존 코드에 버그가 생기는 것을 방지할 수 있다
		- 테스트는 개발 문서의 역할을 한다. 테스트를 따르는 것은 소스 코드가 해결해야 하는 문제를 이해하는 것과 같다
	- 핵심 원리
		- 새 코드를 작성하기 전에 실패하는 테스트를 먼저 작성한다
		- 테스트를 통과하는 가장 단순한 코드를 작성한다

### 6.3.2 TDD 2단계 수행하기
- 실제 TDD의 진행
>[!note] 테스트한다, 코드를 작성한다, 리팩터링 한다, (반복한다)

- 리팩터링
	- 소프트웨어의 외적 동작을 바꾸지 않고 내부적인 구조만 개선함으로써 시스템을 변경하는 과정
	- 외적 동작이 바뀌지 않았다는 것을 증명하기 위해 테스트를 사용

## 6.4 행위 주도 개발(Behavior Driven Development)
- BDD의 철학
	- 비지니스 전략, 요구 사항, 목표가 개발을 주도하며, 이것들이 시나리오로 구체화된 다음에야 IT 솔루션이 만들어진다
	- 사용자의 문제를 직접적으로 해결하는 소프트웨어를 만드는 데 기여
- 소프트웨어에 비지니스적 가치를 제공하는 것은 동작하는 기능(feature)이다

## 6.5 돌연변이 테스트 수행하기
- 돌연변이 테스트
	- 어떻게 하면 테스트의 품질을 평가하고 테스트가 본연의 역할을 제대로 수행했는지 알 수 있는 방법
	- 자바에서 돌연변이 테스트 프레임워크 중 유명한 것은 Pitest
	- 수행 방법
		- 프로그램을 '조금' 수정하는 것
		- 효과적인 테스트는 돌연변이를 탐지하고 방지하는데 이를 돌연변이 죽이기(killing the mutant)라고 한다
		- 전체 돌연변이 숫자 중 죽은 돌연변이 비율로 테스트의 가치를 측정
		- 예시
```Java

// 정상
if(a){
	b = 1;
}else{
	b = 2;
}

//돌연변이 테스트
if(!a){
	b = 1;
}else{
	b = 2;
}
```
	- 훌륭한 돌연변이 테스트 프로세스
		- 테스트 로직이 돌연변이가 된 if 문을 수행
		- 테스트는 초기의 정확한 분기와는 전혀 다른 곳에서 수행
		- b값이 달라졌고 엉뚱한 결과 발생
		- 메서드는 잘못된 값을 반환하므로 테스트 실패
## 6.6 개발 주기 내에서 테스트하기
- 지속적 통합 원칙을 따르는 일반적인 애플리케이션 개발 주기
  ![[Pasted image 20241128134257.png]]
  - 개발 주기 구분
	  - 개발
		  - 개발은 주로 개발자의 작업 장소에서 이루어진다
		  - 한 가지 중요한 원칙은 git, SVN, CVS, ClearCase 같은 SCM(Source Control Management) 시스템에 하루에 여러 번 커밋하는 것이다
		  - 커밋한 작업물의 작동을 보장하기 위해 저장소의 현재 코드와 변경 내역을 먼저 합쳐야 한다
		  - 그 다음 Maven 이나 Gradle을 사용해 로컬에 필드
	  - 통합(integration)
		  - 다른 팀에서 개발한 컴포넌트까지 포함해 애플리케이션을 빌드하고 여러 컴포넌트가 함께 잘 작동하는지 확인
		  - 이 단계에서 많은 문제가 발생한다
		  - 지속적 통합은 애플리케이션을 자동으로 빌드해 달성할 수 있다
	  - 인수/부하 테스트(acceptance/stress test)
		  - 프로젝트에서 리소스가 얼마나 사용 가능한지에 따라 하나 또는 두 단계로 나눌 수 있다
		  - 부하 테스트 단계에서는 애플리케이션에 부하를 주어 애플리케이션이 적절하게 확장하는지 확인
		  - 인수 단계는 프로젝트의 고객이 시스템을 인수하는 단계
		  - 인수 단계에서는 가능한 한 자주 배포하는 것이 권장되는데, 사용자의 피드백을 받을 수 있기 때문
	  - 예비 운영(pre-production)
		  - 예비 운영 단계는 실제 운영 배포 직전에 수행하는 마지막 검증 단계
		  - 이 단계는 선택적으로 진행할 수 있으며, 프로젝트의 중요도에 따라 진행하지 않고 다음으로 넘어가도 무방



