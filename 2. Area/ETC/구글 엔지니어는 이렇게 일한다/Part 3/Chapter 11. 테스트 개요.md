- 테스트를 작성하는 이유
    - 테스트의 요소
        - 테스트하려는 단 하나의 행위
        - 특정한 입력값
        - 관측 가능한 출력 혹은 동작
        - 통제된 조건
        - 간단한 테스트가 수백에서 수천 개 모이면(테스트 스위트\<test suite>) 제품이 전체적으로 의도한 설계대로 잘 작동하는지 확인 가능
        - 테스트는 좋은 제품을 빠르게 만들 수 있게 해줄 뿐 아니라 제품과 서비스 안전 보장에 핵심적인 역할
    - 구글 웹 서버 이야기
        - 제품 결함 해결을 프로그래머의 능력에만 의존해서는 안된다
        - 팀원들의 집단 지성을 팀 전체의 이익으로 환원하는 방법 → 자동 테스트
    - 오늘날의 개발 속도에 맞는 테스트
    - 작성하고, 수행하고, 조치하라
        - 테스트 작성은 테스트 자동화 프로세스의 첫 단계
        - 자동 테스트의 핵심은 같은 동작을 끊임없이 반복
    - 테스트 코드가 주는 혜택
        - 디버깅 감소
            - 테스트 수행 후 submit 된 코드는 보통 결함이 적음
        - 자신 있게 변경
            - 좋은 테스트들은 코드 변경들을 리뷰하고 수용할 수 있으므로 →코드 리팩토링을 권장할 수 있음
        - 더 나은 문서자료
            - 테스트가 명확하고 간결하면 문서자료로써의 역할을 수행 가능
        - 더 단순한 리뷰
            - 정확성, 극단 상황, 오류 상황 등 다양한 측면에서 코드를 검사해주는 테스트가 있다면 리뷰어가 변경된 코드가 제대로 작동하는지 검증하는 시간을 줄여줌
        - 사려 깊은 설계
            - 새로 작성한 코드의 테스트를 작성하는 일은 실질적으로 해당 코드의 API가 잘 설계되어있는지 시험하는 행위
        - 고품질의 릴리스를 빠르게
            - 자동 테스트 스위트를 통해 릴리스의 안정성이 높아짐
- 테스트 스위트 설계하기
    - 테스트 크기
        - 테스트의 크기를 가늠하는 기준은 코드 라인 수가 아니고 어떻게 동작하고, 무엇을 하고, 얼마나 많은 자원을 소비하는지로 평가
        - 테스트 스위트의 품질은 속도와 결정성
        - 작은 테스트
            - 제약이 가장 엄격
            - 테스트가 단 하나의 프르세스(스레드)에서 실행 → 테스트도 테스트 대상 코드와 같은 프로세스에서 실행되어야한다
            - sleep, I/O 연산 같은 블로킹 호출을 사용해서는 안됨
            - 블로킹 호출을 수반하는 대상을 검사하는 테스트 코드는 테스트 대역을 사용해야한다 → 테스트 대역은 강한 의존성을 가벼운 인프로세스 의존성으로 대체하는 수단
        - 중간 크기 테스트
            - 여러 프로세스 & 스레드 & 로컬 호스트로의 네트워크 호출 같은 블로킹 호출 이용
            - 외부 시스템과의 통신 불허
            - 유연성이 커짐에 따라 테스트가 느려지고 비결정적이 될 수 있음
        - 큰 테스트
            - 테스트와 대상 시스템이 여러 대의 기기 활용
            - 네트워크 연결을 할 수 있게 됨에 따라 단일 기기에서 구동때보다 느려지거나 비결정성이 커질 가능성이 높아짐
            - 시스템의 종단간 테스트 → 코드 조각이 아닌 설정을 검증하는게 주된 목적
        - 테스트 크기와 무관한 공통 특성
            - 테스트는 셋업, 실행, 테어다운하는 데 필요한 모든 정보를 담고 있어야한다→ 모든 테스트는 밀폐되어야한다
            - 테스트 수행 순서 같은 외부 환경에 관해 가능한 한 아무것도 가정하지 않아야함→ EX) DB에 의존성 발생 X
            - 테스트가 검증하는 것이 명확해야함 → 조건문이나 반복문 같은 제어문을 쓰지 않은 게 좋음
    - 테스트 범위
        - 정의 : 테스트가 얼마나 많은 코드를 검증하는가
        - 좁은 범위 테스트 → 독립된 클래스나 메서드같이 코드베이스 중 일부 로직을 검증하도록 설계(== 단위 테스트)
        - 중간 범위 테스트 → 적은 수의 컴포넌트들 사이의 상호작용을 검증하도록 설계( 통합 테스트)
        - 넓은 범위 테스트 → 시스템의 서로 다른 부분들 사이의 상호작용, 클래스, 메소드 하나만 실행할 때 괜찮다가 여럿을 조합해 실행하면 나타나는 예기치 못한 동작 검증하도록 설계(==기능 테스트, 종단간 테스트, 시스템 테스트)
        - 단위 테스트 80%, 통합테스트 15%, 종단간 테스트 5%
    - 비욘세 법칙
        - 시스템이 특정 행위를 올바르게 수행하는지 확신하고 싶다면, 그 행위를 검증하는 자동 테스트를 작성하는 게 유일한 선택지 → 성능,행위 정확성, 접근성, 보안 모두 포함
    - 코드 커버리지
        - 정의 : 어느 테스트가 기능 코드의 어느 라인을 실행하는지를 측정하는 수단
        - 100라인짜리 코드가 있고 테스트가 90라인을 실행했다면 코드 커버리지는 90%
        - 큰 테스트는 커버리지 인플레이션을 일으키므로 커버리지는 작은 테스트에서만 측정 권장
        - 검사해야 할 행위에 focus를 맞출 것
- 구글 규모의 테스트
    - 열린 코드베이스 → 공동 소유 의식 고취
    - 리포지터리 브랜치를 사용하는 팀이 거의 없고, 모든 변경이 리포지터리 헤드에 직접 커밋되어 변경 즉시 모두 볼 수 있음
    - 대규모 테스트 스위트의 함정
        - 깨지기 쉬운 테스트 → 예상 결과를 너무 세세하게 표현하거나 광범위하고 복잡한 상용구를 덕지덕지한 테스트의 함정
        - 테스트 스위트가 커지면 수행 시간도 증가 → 느려질수록 수행 빈도가 낮아져 테스트의 가치 감소
        - sleep(), setTimeout() 같은 함수를 필요 없이 호출하느라 느려지기도 함
        - 테스트에 관심을 갖도록 장려하는 것이 중요
- 구글의 테스트 역사
    - 오리엔테이션 수업
        - 테스트가 주는 이점 → 생산성 향상, 더 나은 문서자료, 리팩터링 지원
        - 좋은 테스트를 작성하는 방법
    - 테스트 인증
        - 테스트 인증 프로그램
            - 총 5단계 레벨
                - 레벨 1 → 지속적 빌드 구축, 코드 커버리지 추적, 테스트 크기 구분, 불규칙한 테스트 식별, 바로 실행할 수 있는 빠른 테스트 스위트
                - 레벨이 높아질수록 **실패하는 테스트가 없어야 릴리스 가능, 비결정적인 테스트 모두 제거**
                - 레벨 5 → 모든 테스트를 자동화, 모든 커밋 전에 빠른 테스트 스위트가 수행되도록하고, 비결정성을 완전히 제거하고, 모든 행위를 테스트
    - 화장실에서도 테스트
        - 테스트 지향성
    - 오늘날의 테스트 문화
        - 테스트 인증 프로그램을 대체하고자 프로젝트 건실성(Project Health) 개념 유지
- 자동 테스트의 한계
    - 모든 테스트 자동화 불가
    - 창의력이 필요한 분야에서도 인간이 뛰어날 수 있음 → 보안 취약점 처리
    - 탐색적 테스팅 → 의외의 데이터를 입력하거나 예상치 못한 절차로 조작하는 시도 → 정상적이지 않았던 응답을 조사하며 점진적으로 문제 처리