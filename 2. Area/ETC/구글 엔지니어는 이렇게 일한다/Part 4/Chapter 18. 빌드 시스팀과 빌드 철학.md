- 빌드 시스템의 목적
    - 훌륭한 빌드 시스템의 두 가지 중요 속성
        - 속도 : 개발자가 명령 하나로 빌드를 수행하고 몇 초 안에 결과 바이너리를 얻을 수 있어야한다
        - 정확성 : 소스 파일과 기타 입력 데이터가 같다면 모든 개발자가 어떤 컴퓨터에서 빌드하더라도 항상 동일한 결과를 내어줘야 한다
- 빌드 시스템이 없다면?
    - 컴파일러로 충분하지 않나?
        - 컴파일러로 사용할 경우 다양한 언어나 여러 컴파일 단위로 구성된 코드를 다루기 시작하면 빌드를 진행할 수 없음
    - 셸 스크립트가 출동한다면?
        - 시스템의 복잡도가 올라가면 코딩에 들이는 시간만큼 빌드 스크립트에 시간을 써야한다
        - 빌드해야하는 부분만 검출해내는 로직을 구상하더라도 이를 직접 관리하는 것은 복잡하고 오류 발생 가능성이 높아짐
        - 저장된 하드 드라이브가 깨진다면→ 소스 코드는 관리하지만 라이브러리의 버전 관리에 문제
        - 한 사람에게 잘 되었던 것도 다른 사람이 진행하면 정상적으로 실행되지 않을 수 있음
        - 프로젝트가 커지면서 빌드가 느려진다
- 모던 빌드 시스템
    - 핵심은 의존성이다
        - 직접 작성한 코드 버전 관리는 쉽지만 외부 의존성 관리는 매우 어려움
    - 테스크 기반 빌드 시스템
        - 기본 단위는 task
        - 각 테스크는 어떤 로직을 수행할 수 있는 일종의 스크립트이며 다른 테스크와의 의존 관계를 명시해 반드시 먼저 수행하도록 할 수 있음
        - Ant, Maven, Gradle, Grant등이 있음
        - 표현 방식만 다를 뿐 빌드 파일은 빌드 스크립트와 본질적으로 크게 다르지 않음
        - 테스크 기반 빌드 시스템의 어두운 면 - 주요 단점 3가지
            - 빌드 단계들을 병렬로 실행하기 어렵다
                - 병렬로 실행해도 문제될 게 없어 보이는 태스크들마저 그렇게 하지 못할 경우가 있음
            - 증분 빌드를 수행하기 어렵다
                - 테스크는 무슨 일이든 할 수 있기 때문에 일반적으로 이미 실행됐는지 확인할 방법이 없으므로 추가 정보 없이는 빌드 시스템이 변경되지 않은 소스 파일을 컴파일해야한다 ⇒ 확실하게 하기 위해 빌드ㄷ 때마다 모든 테스크를 다시 실행해야한다
            - 스크립트를 유지보수하고 디버깅하기 어렵다
                - 빌드 스크립트 자체를 관리하기 어렵다
            - 성능, 정확성, 유지보수성 문제를 한꺼번에 해결하기 어려움
    - 아티팩트 기반 빌드 시스템
        - 빌드할 아티팩트들, 그 사이의 의존성, 빌드 방식에 영향을 주는 몇 가지 옵션을 설명하는 선언적 매니페스트 파일 설정 → 엔지니어가 빌드할 대상들을 명시하고 명령중에 Blaze를 실행하면 Blaze는 나머지 컴파일 단계들을 설정, 실행, 스케쥴링함
        - Bazel, Pants, Buck, Blaze 등이 있음
    - 기능적 관점
        - 함수형 프로그래밍과 유사성이 높음
        - 함수형 언어에서는 수행할 계산을 설명하지만 그 계산을 정확히 언제 어떻게 수행할지는 컴파일러에게 이임
    - 태스크 기반 빌드 시스템과의 핵심적인 차이
        - 실행 전략을 온전히 빌드 시스템에 맡겨 병렬 실행이 가능케함
        - 빌드 타깃이 최신 상태임을 감지하고 기존 결과를 재사용할 수 있으므로 최소한의 아티팩트만 다시 빌드해 전체 빌드를 문제없이 수행할 수 있음
    - Bazel의 또 다른 멋진 묘수들
        - 도구도 의존성으로 취급하기
            - 빌드에 필요한 도구를 선언하도록해 언제 어느 시스템에서 빌드하든 정확한 도구들이 먼저 갖춰지도록 함
            - 타깃들이 도구들에 직접 의존하지 않고, 특정한 툴체인에 의존
            - 툴체인 : 특정 플랫폼에서 각 타깃 유형을 빌드하는 데 이용하는 도구들과 속성들의 모음
        - 빌드 시스템 확장하기
            - 규칙 정의시 규칙이 요구하는 입력들과 규칙이 생성해야하는 결과물들을 선언
            - 규칙이 생성할 액션들도 선언 → 각 액션은 필요한 입력과 출력을 선언하고 특정 실행 파일을 수행하거나 파일에 특정 문자열을 기록 | 입력과 출력을 통해 다른 액션과 연결할 수 있음
            - 액션 : Bazel에서 가장 낮은 수준의 조합 가능한 단위
        - 환경 격리하기
            - 샌드박싱 기술로 액션들끼리 동일한 파일을 사용해서 상호간의 충돌하는 문제를 방지
        - 외부 의존성 명확히 드러내기
            - 외부 의존성 각각의 암호화 해시를 워크스페이스 차원의 매니페스트 파일에 기록 → 해시를 통해 전체 파일을 소스 관리하에 두지 않고도 고유하게 식별할 수 있도록 함
            - 만약 새로 다운로드한 파일의 해시가 매니페스트에 정의된 해시와 다르다면 매니페스트의 해시는 업데이트되기 전까지 빌드 실패 → 빌드가 새로운 의존성을 받아들이기 전에 해당 변경을 승인하고 소스 관리 시스템에 반영해야함 → 의존성이 변경된 시각이 항시 기록되며, 워크스페이스 소스가 적절히 수정되지 않은 채로 외부 의존성만 변경될 수 없다는 의미
    - 분산 빌드
        - 분산 빌드 : 단위 작업들을 여러 컴퓨터에 뿌려 빌드한 후 취합해 최정 결과를 만들어주는 기술
        - 원격 캐싱
            - 개발자 컴퓨터와 지속적 통합 시스템 모두 공통의 원격 캐시 서비스를 참조
        - 원격 실행
            - 빌드를 하는 실제 작업들을 여러 워커에 나눠 수행하는 기술
            - 빌드 마스터가 요청받은 빌드를 구성하는 액션들을 스케쥴링 → 워커 풀 내 개별 워커들이 마스터가 지정해준 액션을 사용자가 명시한 입력값을 사용해 수행하고 아티팩트 생성 → 이 아티팩트들을 최종 결과를 만들어 사용자에게 전달할 때까지 해당 아티팩트가 필요한 또 다른 액션을 수행하는 워커들에게 공유
            - 이런 시스템 구현 시 워커 & 마스터 & 사용자 컴퓨터 간의 커뮤티케이션 관리하는 부분이 가장 까다로움
    - 시간, 규모, 트레이드오프
        - 빌드 시스템 교체는 매우 비용이 많이 드는 작업 → 유연성을 트레이드오프로 삼아 범용 태스크를 작성하는 길을 막고 시스템이 허용하는 범위 내에서만 무언가를 할 수 있도록 함
- 모듈과 의존성 다루기
    - 작은 모듈 사용과 1:1:1 규칙
        - 언어마다 혹은 하나의 언어 안에서도 정확한 입자의 크기가 다르므로 태스크 기반 빌드 시스템에서의 일반적인 크기보다 작은 모듈 선호
    - 모듈 가시성 최소화
        - Bazel을 포함한 여러 빌드 시스템은 타깃이 가시성을 명시할 수 있게 함→ 가시성은 자신에게 의존할 수 있는 타깃의 범위를 지정하는 속성
        - 가시 범위는 가능한 한 좁히는 것이 좋음
- 의존성 관리
    - 내부 의존성
        - 큰 프로젝트를 작은 모듈들로 나누면 의존성 대부분이 내부 모듈 사이에서 발생
        - 의존하는 타깃 대부분이 같은 소스 리포지터리에서 정의되고 빌드됨
        - 하나의 타깃과 그 타깃이 만들어내는 모든 내부 의존성은 언제나 같은 커밋/리비전에서 빌드
        - 전이 의존성 문제 → A가 B를 의존하고 B가 C를 의존하면 A는 C가 정의한 클래스를 사용할 수 있는가?
        - 엄격한 전이 의존성 모드 도입 → 직접 의존하지 않는 심볼을 참조하는 타깃이 검출되면 빌드 fail
    - 외부 의존성
        - 자동 vs 수동 의존성 관리
            - 수동으로 관리시 아티팩트 리포지터리에서 다운로드할 버전을 빌드 파일에 명시
            - 자동으로 관리 시 소스 파일에 호환 버전의 범위를 명시하고, 빌드 시스템이 범위 안에서 가장 최신 버전을 다운로드하도록 함
            - 자동 관리 문제는 의존성의 버전이 언제 업데이트되는 지를 개발자가 통제할 수 없음
        - 원-버전 규칙
            - 서드파티 의존성들에 대한 원버전 규칙 강제
        - 전이 외부 의존성
            - Bazel은 전이 의존성을 자동으로 다운로드하지 않고 전역 파일 하나에 리포지터리의 외부 의존성 모두와 그 각각이 이용하는 의존성의 정확한 버전을 전부 기혹
        - 외부 의존성을 이용해 빌드 결과 캐시하기
        - 외부 의존성의 보안과 안정성
            - 서드파티의 위험성
                - 가용성 위험: 서드파이 아티팩트 리포지터리에 접속할 수 없게 되면 외부 의존성을 다운로드 할 수 없어 빌드 전체가 정지됨
                - 보안 위험 : 공격자가 서드파티 시스템을 점령해 개발자가 참조하는 아티팩트를 공격자가 설계한 버전으로 대체해 악성 코드를 심을 수 있음
                - 필요한 아티팩트를 개발자가 통제할 수 있는 서버에 미러링해놓고, 빌드 시스템이 Maven Central 같은 서드파티 아티팩트 리포지터리를 이용하지 못하게 하면 됨
                - 또한 프로젝트에 필요한 의존성을 복사해 프로젝트에 포함하는 방법도 있음 ⇒ Vendoring