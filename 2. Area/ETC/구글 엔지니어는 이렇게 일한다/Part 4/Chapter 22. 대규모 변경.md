- 대규모 변경이란?
    - 정의 : Large-Scale Change는 논리적으로는 연관되어 있으나, 현실적인 한계 때문에 원자적으로 서브밋할 수 없는 변경들의 집합
    - LSC로 인해 생성되는 변경들의 분류
        - 코드베이스 전반을 훑는 분석 도구로 찾은 공통 안티패턴 청소
        - 폐기 대상 API 호출 대체
        - (컴파일러 업그레이드 등) 저수준 인프라 개선사항 활성화
        - 사용자들을 옛 시스템에서 새로운 시스템으로 마이그레이션
    - LSC 촉발 원인
        - 명확성, 최적화, 미래 호환성 개선이 목표
- 누가 대규모 변경을 처리하나?
    - 인프라팀이 관리
    - 이유
        - 하부 시스템을 구축하고 관리하는 인프라팀들은 그 시스템을 활용하는 수만 개의 참조를 수정하는 데 필요한 도메인 지식을 가지고 있음
        - 합당한 보상 없이 할 일만 늘어나는 상황을 좋아할 사람은 없다 → 자발적으로 업그레이드할 만한 매력을 느끼지 못할 수도 있음
        - 대규모로 변경해야 할 시스템을 소유한 팀이 주도해야 변경을 완료하는 데 유리
- 원자적 변경을 가로막는 요인
    - 기술적 한계
        - 대부분의 VCS는 기능을 수행하는 비용이 변경의 크기에 비례해 증가함
        - 변경 자체가 불가할 수도 있다는 것
    - 병합 충돌
        - 변경의 규모가 커질수록 자연스럽게 병합 시 충돌 가능성 증가
    - 유령의 묘지
        - 유령의 묘지 → 너무 오래되고 둔하고 복잡해서 아무도 손대려 하지 않는 시스템
        - 이는 거대한 마이그레이션이 깔끔하게 마무리되지 못하게 하고 낡은 시스템을 폐기시키지 못하게 함
    - 이질성
        - LSC에 수반되는 작업 대부분은 사람이 아닌 컴퓨터가 처리해줘야하므로 컴퓨터가 변경 코드를 정확한 위치에 올바르게 반영하려면 환경이 일관되어야함
    - 테스트
        - 모든 변경은 테스트되어야한다 → 변경의 크기가 커지면 테스트하기 어려워짐
    - 코드 리뷰
        - 거대한 커밋을 검토하기란 지루하고 번거롭고 오류가 스며들기 쉬움
- 대규모 변경 인프라
    - 정책과 문화
        - 구글은 수많은 소스 코드를 하나의 리포지터리에 보관해 모든 엔지니어가 그 안의 코드 대부분을 볼 수 있음 → 그로 인한 변경 비용 & 리뷰 비용 발생
    - 코드베이스 인사이트
        - 텍스트 기반의 전통적인 분석 & 의미를 추적하는 분석도 중요
        - 컴파일러 기반 인덱스를 사용해 코드베이스에 대한 추상 구문 트리 기반 분석과 변환 수행
    - 변경 관리
        - 대규모 변경 인프라에서 가장 중요한 도구는 마스터 변경을 어려 개의 샤드로 나눈 후 테스트, 메일링, 리뷰, 커밋 단계를 독립적으로 관리해주는 도구
    - 테스트
        - 테스트 문화와 인프라가 갖춰져 있다면 도구가 생성한 변경의 부작용을 테스트를 통해 더 강하게 확신할 수 있음
    - 언어지원
        - 언어에 따라 LSC 난이도 차이
        - 정적 타입 언어가 동적 타입 언어보다 유리
- 대규모 변경 프로세스
    - 권한 부여
        - 문서 작성 요청
            - 변경을 제안하는 이유
            - 코드베이스 전반에 주는 예상 영향
            - 리뷰어들이 던질만한 질문과 그에 대한 답변
        - 관련된 변경을 일괄적으로 승인
    - 변경 생성
        - 승인을 받은 LSC 작성자는 실제로 코드를 수정하기 시작 → 거대한 전역 변경 하나를 생성한 후 다수의 독립적인 샤드로 쪼갠다
        - 변경 생성 프로세스는 가능한 한 자동화해야함 → 변경된 코드에서 병합 충돌이 발생했을 때 상위 변경을 업데이트해야 하기 때문
        - 스타일 가이드와 자동 포맷팅 도구 적용 필요
    - 샤드로 나누기와 서브밋
        - 거대한 변경을 하나로 입력받아 서브밋할 수 있는 작은 변경(샤드)들로 쪼갬 → 프로젝트 경계와 소유권 규칙 참고 → 개별 샤드를 독립된 테스트-메일-서브밋 파이프라인에 태움
        - 테스트하기
            - LSC 프로세스에서 개별 샤드는 독립적으로 커밋할 수 있어야하고 샤드 생성 단계에서 헤더 파일과 그 구현처럼 서로 연관된 변경을 같은 그룹화 필요
            - 대규모 변경의 샤드들도 리뷰하고 커밋하기 전에 프로젝트별 검사 항목들을 통과해야함
        - 리뷰어에게 메일 보내기
            - 테스트 수행 후 변경이 안전하다고 검증한 후 적절한 리뷰어에게 메일 전송
        - 리뷰하기
            - 표준 코드 리뷰 프로세스를 거침
        - 서브밋하기
            - 개별 변경 사항 커밋
    - 마무리 청소
        - 어떤 경우든 대규모 변경이 애써 제거한 심볼이나 시스템이 다시 사용되는 일을 막아주는 방책이 꼭 필요함