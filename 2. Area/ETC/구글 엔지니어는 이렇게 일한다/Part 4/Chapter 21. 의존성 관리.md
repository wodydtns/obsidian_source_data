- 정의 : 우리가 통제하지 못하는 라이브러리, 패키지, 그 외 의존성들의 네트워크를 관리하는 일
- 의존성 관리는 시간과 확장 양 축 모두에서 복잡도를 키움 →외부 라이브러리는 내부 코드를 볼 수 없기 때문
- 소스 관리와 의존성 관리는 **하위 프로젝트의 개발/업데이트/관리를 우리 조직이 통제하는가?로 구분 지울 수 있음**
- 다른 조건이 모두 동일하다면 의존성 관리 문제보다 소스 관리 문제를 선택할 것→ 의존성 관리 문제보다 소스 관리 문제가 생각하기 훨씬 쉽고 처리 비용도 저 적음
- 의존성 관리가 어려운 이유
    - 요구사항 충돌과 다이아몬드 의존성
        - 버전 비호환 문제의 대표적인 예
        - 의존성 계층이 최소 세 개 이상일 때 상호간에 의존성을 가진 라이브러리들의 버전 차이로 인한 문제가 일어남 (ex.A,B,C 라이브러리가 상호간 의존 → B 라이브러리는 update, A,C는 미 update → 의존성 문제 발생)
        - 비호환 문제가 발생할 경우 근본 원인을 직접 밝혀내야함
- 의존성 임포트하기
    - 호환성 약속
        - 개발 비요을 줄이기 위해 의존성을 임포트하는 것이 꼭 옳은 선택은 아님 → 지속적인 유지보수 비용까지 감안해야함
        - 고려할 수 있는 요인
            - 호환성이 얼마나 잘 지켜지나요?
            - 진화가 얼마나 빠르게, 크게 이루어지나요?
            - 변경 처리 방법은 무엇일까요?
            - 각 버전의 지원 기간은 어떻게 되나요?
    - 임포트 시 고려사항
        - 프로그래밍 프로젝트라면 의존성 임포트는 거의 공짜 → 의존성이 하위 호환을 약속하지 않더라도 의존성 업그레이드를 하지 않는 이상 문제 X
        - 소프트웨어 엔지니어링에선 같은 의존성도 비용이 증가함
        - 의존성 임포트 시 고려사항 - 의존성 자체
            - 실행해볼 수 있는 테스트가 존재하는지
            - 테스트는 모두 통과하는지
            - 의존성 제공자는 누구인지
            - 지향하는 호환성 정책은?
            - 앞으로 어떤 분야나 용도를 지원할 것인지 자세히 설명하는 지
            - 얼마나 인기있는 프로젝트인지
            - 언제까지 이용할건지
            - 파괴적인 변경이 얼마나 빈번하게 행해지는 지
        - 의존성 임포트 시 고려사항 - 조직 관점
            - 새로운 기능을 구현하려면 얼마나 복잡한가
            - 의존성을 최신 상태로 유지하면 어떤 이점이 있는가
            - 업그레이드의 책임자는?
            - 업그레이드의 난이도는?
        - 의존성 임포트
            - 구글의 절차
                - 구글 빌드 시스템에서 잘 빌드 되는가?
                - 같은 패키지가 이미 존재하지 않음을 확인
                - 유지보수를 맡아줄 엔지니어를 찾아 OWNER에 추가
- 의존성 관리
    - 모든 형태의 요구사항 충돌 문제로부터 보호되어야함
    - 안정적인 의존성 관리 체계는 시간과 규모 모든 면에서 유연해야함
    - 변경 불가(정적 의존성 모델)
        - 애초부터 변경 자체를 허용하지 않는 방법
        - 사용자 코드 동작에서 영향을 주지 않는 선에서의 버그 수정만 허용
        - 프로젝트가 오래 살아남을수록 가정이 틀릴 가능성이 커지며 언제까지 유효할 지 정확하게 알 수 있는 지표가 없음
    - 유의적 버전(SemVer)
        - 2.4.27과 같이 숫자 세 개로 표현
        - 메이저 버전 : API가 변경되어 의존성을 이용하던 기존 코드를 깨드릴 수 있음
        - 마이너 버전 : 순수하게 기능 추가만 있음(기존 코드를 깨뜨리지 않음)
        - 패치 : API에 영향을 주지 않는 내부 구현 개선과 버그 수정
        - SemVer 기반의 의존성 관리는 대체로 SAT 솔버 이용 → 의존성 네트워크 전체를 대상으로 어떤 알고리즘을 수행해 모든 버전 요구사항을 충족하는 의존성 버전을 찾는 행위 → 버전 선택
        - 만족스러운 버전 조합이 네트워크에 존재하지 않는 상항 → 의존성 지옥
    - 하나로 묶어 배포하기
        - 애플리케이션 구동에 필요한 의존성들을 모두 찾아서 애플리케이션과 함께 배포하는 방법
        - 배포자(distributor) → 함께 묶어 배포할 버전들을 찾고, 이 버전들로 채운 의존성 트리에서 문제가 없는지 확인하고, 문제가 생기면 해결하는 일 담당
    - 헤드에서 지내기
        - 모든 컴포넌트가 항상 최신 버전에 의존하며, 의존하는 쪽에서 수용하기 어려운 형태의 변경을 허용하지 않음
        - 헤드에서 지내기의 상황 가정
            - 단위 테스트와 CI가 갖춰져 있음
            - API 제공자 다운스트림 의존성들이 깨지는지를 확인할 수 있음
            - API 소비자가 테스트들이 계속 통과하고 지원 가능한 방식으로 의존성을 이용 중
        - 이에 대한 보상
            - API 제공자 : 변경이 소비자들에게 신속하고 매끄럽게 받아들여짐
            - API 소비자 : 테스트들이 쳐주는 보호막 유지
- 유의적 버전의 한계
    - 지나치게 구속할 수 있다
        - 실제로 라이브러리 하나에서 제공하는 인터페이스들 모두가 서로 연결되어 있는 경우가 거의 없지만 SemVer가 과도하게 구속한다면 자동 패키지 관리자와 SAT 솔버가 의존성 업데이트 할 수 없을 수 있음
    - 확실하지 않은 약속일 수 있다
        - 변경 자체만으로는 파괴적인지 아닌지 판단할 수 없음 → 어떻게 쓰이고 있는가라는 맥락이 고려되어야만 판단할 수 없음 → 변경이 파괴적이다는 말이 진실이라는 절대적인 답은 없음
        - SemVer SAT 솔버가 의존성들과 문제없이 작동할 것이라고 알려줘도 실제로는 그렇지 않을지 모른다
    - 버전업 동기
        - 의존성 maintainer에게 파괴적인 변경이나 메이저 버전업을 하지 못하도록 하는 위축 요인이 있을 수 있음
        - 사람에 의한 오류 발생 가능성이 있음
    - 최소 버전 선택
        - 미래를 100% 확신할 수 없다면 가능한 한 차이가 작게 버전업하는 게 가장 안전
    - 그래서 유의적 버전을 이용해도 괜찮은가?
        - 어느 정도 규모까지는 SemVer가 충분히 잘 작동함
        - 잘 작동할 수 있는 조건
            - (SemVer 버전업 시 사람에 의한 오류가 나지 않도록) 의존성 제공자들이 버전을 정확하고 책임감 있게 관리
            - (지나친 구속과 지나친 약속을 피하기 위해) 의존성들이 충분히 세분화되어 있음
            - (직간접적으로 사용하는 외전성에서 호환된다고 가정하고 진행한 변경임에도 코드가 예기치못한 방식으로 오작동하는 일을 피하기 위해) 모든 API를 제공자의 의도대로 사용
- 자원이 무한할 때의 의존성 관리
    - 현재 업계가 SemVer에 의지하는 이유
        - 내부 정보만 있으면 된다(API 제공자가 다운스트림 사용자가 어떻게 이용하는지까지 알 필요 없음)
        - 충분한 테스트를 수행할 컴퓨팅 자원, 테스트 결과를 모니터링해줄 CI 시스템이 존재하지 않아도 된다
        - 관행
    - 의존성 내보내기
        - 조직의 해를 끼치는 방식
            - 구현 품질이 떨어지거나 관리 불량
            - 동기화를 유지할 수 없다면 선의의 릴리스가 엔지니어링 효율을 떨어뜨림