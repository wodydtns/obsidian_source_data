- 버전 관리란
    - 진실 공급원
        - 중앙집중형 VCS는 시스템 설계에서부터 source-of-truth 개념 사용
        - 트렁크에 가장 최근 커밋된 것 → 현재 버전
        - 분산형 VCS는 Single Source of Truth가 없기 때문에 중앙 통제나 조율 없이 커밋 태그와 Pull Request을 전혀 다른 개발 브랜치로 전달할 수 있음 ⇒ 정책과 규범 명확해야함
    - 버전 관리 vs 의존성 관리
        - VCS 정책은 주로 코드를 어떻게 관리할지를 다루고, 대체로 훨씬 세세하게 관리
- 브랜치 관리
    - 상이한 버전들을 관리하는 방식 → 브랜치 관리
    - 진행 중인 작업은 브랜치와 비슷하다
        - 진행 중인 작업은 하나의 브랜치와 같다
    - 개발 브랜치
        - 개발 브랜치는 “**구현은 다 했지만 커밋하진 않았어요”와 “이제부터 이 코드를 기준으로 개발하세요”의 중간 단계**
        - 큰 단위로 한꺼번에 병합하기보다는 작게 작게 자주 병합하는 게 쉬움
        - 개발 브랜치에 중독되어 가는 과정
            - **오래된 개발 브랜치를 병합하니 안정성이 떨어진다 ⇒ 병합은 위험하다는 결론**
            - 테스트와 CI를 적극 활용해 모든 빌드와 테스트가 항상 성공하도록 관리하며, 완벽하지 않거나 테스트되지 않은 기능은 비활성화 ⇒ 트렁크 기반 개발은 버전이 하나이므로 단일 진실 공급원으로 좁히는 것
        - 릴리스 브랜치
            - 제품의 릴리스 간격이 몇 시간 이상이면 릴리스 브랜치를 따로 생성하는게 좋음
            - 트렁크로부터 하루에도 몇 번씩 릴리스 할 수 있는 지속적 배포가 잘 자리 잡은 조직에서는 대체로 릴리스 브랜치를 건너띈다
            - **트렁크 기반 개발 & 장기간 유지되는 개발 브랜치가 적은 조직 ⇒** 기술적 성취가 뛰어나다
- 버전 관리
    - 모노리포 관리 → 단일 레파지토리
    - 원-버전
        - 어느 레파지토리의 어느 브랜치가 진실 공급원인지를 개발자가 명확히 알도록한다
    - 시나리오: 여러 버전을 허용한다면?
        - 같은 라이브러리의 여러 버전을 하나의 바이너리에서 깔끔하게 공유하려는 트릭(ex. 자바의 shading)은 한계에 봉착
    - 원-버전 규칙
        - 개발자가 ‘이 구성요소는 어떤 버전을 사용해야 하죠?’라고 묻는 상황을 만들지 않아야 한다
        - 의존성을 새로 추가할 때 **선택할** 수 있는 버전을 제한한다
    - 장수 브랜치는 (웬만하면) 금지
        - 개발 브랜치를 되도록 만들지 말고, 만들더라도 매우 짦게 쓰고 없애야한다
        - 빌드 호라이즌 → 프로덕션 환경에서 구동 중인 모든 제품은 최대 6개월 안에 다시 빌드해 재배포해야한다는 정책
        - 장수 개발 브랜치 유지는 최소한으로
    - 릴리스 브랜치는 어떤가?
        - 릴리스 브랜치는 최소한의 수정만 반, 트렁크로 병합 X
- 모노리포(단일 리포저터리)
    - 원-버전 고수의 용이함
    - 레포지터리 개수의 문제 X → **원-버전** 원칙 준수가 필요함
- 버전 관리의 미래
    - 모노리포의 우려는 모든 것을 하나의 리포저티러에 담을 수 있는 기술이 있느냐
    - Open Source Software 세계의 개발 방식과 어울리지 않는 다는 우려
    - 버전 관리와 의존성 관리는 앞으로 더 발전할 것
    - VCS는 확장성을 개선해 더 큰 리포지터리를 지원할 것으로 보임