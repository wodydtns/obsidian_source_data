- Code Search
[Getting started with Code Search | Google Developers](https://developers.google.com/code-search/user/getting-started)
- Code Search UI
    - 개발자가 파일, 심볼, 디렉터리를 빠르게 찾도록 활용
- 구글 개발자가 Code Search를 이용하는 방법
    - 어디에?
        - 결과에 랭킹을 매겨 보여주고 표현력 좋은 질의어를 제공
        - Code Search의 결과를 동료과 공유하기 쉽게 함
    - 무엇을?
        - 무언가를 변경하기 전에 소스 코드를 읽고 더 잘 이해하기 위해, 다른 사람이 변경한 코드를 이해하기 위해 이요
    - 어떻게?
        - 특정 문제에 활용할 라이브러리를 찾은 다음, 그 안에서 가장 적합한 구현 방법의 선택을 도와줌
    - 왜?
        - 코드베이스의 정확한 상태를 찾고 탐색할 수 있는 기능이 중요
    - 누가 언제?
        - 특정 코드 조각을 누가 언제 추가했는 지 사용
- 독립된 웹 도구로 만든 이유
    - 대규모 코드베이스 지원
        - 구글의 코드베이스가 너무 거대해서 코드베이스 전체를 로컬로 복사하는 것이 불가능하기 때문
    - 설정 업이 모든 코드 보기
        - 코드베이스 전체에서 최신 코드를 정확하게 브라우징할 수 있다면 재사용할 라이브러리나 복사해서 쓸 좋은 예시를 찾는 것이 용이함
    - 기능 특화
        - IDE가 아니기 때문에 편집이 아닌 코드 탐색과 이해에 사용자 경험을 최적화할 수 있음
    - 다른 도구에 통합
    - API 제공
        - API를 통해 플러그인 제작을 통한 개발자 생산성 증대
- 규모가 설계에 미치는 영향
    - 검색 쿼리 지연시간
        - 지연시간 증가는 개발자의 집중도에 영향을 줌
    - 인덱싱 지연시간
        - 규모가 인덱스를 생성하는 데 영향을 줌
- 구글은 어떻게 구현했나?
    - 검색 인덱스
        - 초기 트라이그램 기반 방식
        - 커스텀한 접미사 배열 기반 → 희소 n-그램
        - 기존의 grep 보다 500배 이상 & 정규 표현식 검색에도 빠르게 응답
    - 랭킹
        - 쿼리 독립적 시그널 = 문서(파일)에만 의존적인 시그널
            - 파일 조회수 & 파일 참조량 가져올 수 있음
            - 피드백 루프 문제 → 자주 조회되어 점수를 높이면 개발자들이 다시 조회할 가능성이 높아져 다른 문서 검색이 순위에 들어올 가능성이 낮아짐 ⇒ 탐색과 활용
            - 파일을 가르키니는 참조의 수도 이용
            - 주의 사항
                - 참조 정보를 안정적으로 추출해낼 수 있어야함
                - 핵심적인 오픈 소스 라이브러리 등에서 종종 진행되는 대규모 리팩토링
        - 쿼리 의존적 시그널 = 검색 쿼리와 쿼리와 문서의 매치에 의존하는 시그널
            - 인덱스러부터 빠르게 얻을 수 있는 쿼리와 정보만 이용해야함
            - 파일 내용 외 파일 이름과 심볼의 전체 이름과도 비교
        - 검출(검색)
            - 문서에 점수를 매기기 전에 검색 쿼리와 일치할 가능성이 있는 후보군 찾는 단계
            - 관련이 적은 수많은 파일 중에서 관련도 높은 소수의 파일을 찾는 일
        - 결과 다양성
            - 분류별로 최상의 결과를 다양하게 보여주어야한다
            - 자바 언어에서 찾은 결과와 파이썬 언에서 찾은 결과를 함께 제공하는 것
- 구글이 선택한 트레이드오프
    - 완벽성 : 헤드 리포저티러
        - 텍스트가 아닌 바이너리 파일은 인덱싱 제거
        - 파일을 제외하면 때론 피드백에 구멍이 생겨 혼란과 생산성 손실 발생 가능
    - 완벽성 : 전부 vs 가장 관련성 높은 결과만
        - 파일들을 우선순위대로 정렬하고 코드베이스 전체를 샤드(조각)로 나누기 → 갹 샤드에서 우선순위가 높은 파일들과만 일치 여부 확인
    - 완벽성 : 헤드 vs 브랜치 vs 모든 변경 이력 vs 작업 공간
        - 코드베이스의 변경 기록 인덱싱 → 어느 코드 버전을 인덱싱해야하는가 |
    - 표현력 : 토큰 vs 부분 문자열 vs 정규 표현식
        - 코드베이스 크기, 가용한 자원, 초당 검색 수를 기초로 인덱스 크기 및 검색 지연시간과 자원 소비 사이의 적절한 균형점 조절 필요