## 1.1 작업을 동시에 실행하는 일에 대한 (아주) 간략한 역사

- 운영체제가 생긴 이유
    - 자원활용
        - 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하기 위해서
    - 공정성
        - 더 작은 단위로 컴퓨터를 공유하기 위해서
    - 편의성
        - 때론 여러 작업을 전부 처리하는 프로그램 하나보다 각기 다른 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율하는 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직함
- 순차적 프로그래밍 모델
    - 한 번에 한 가지씩 순차적으로 처리
- 스레드
    - 메모리, 파일 핸들과 같이 프로세스에 할당된 자원을 공유
    - 각 스레드는 각기 별도의 프로그램 카운터, 스택, 지연 변수를 갖는다
    - 하드웨어 병렬성을 이용할 수 있다
    - 현대 운영체제의 대부분은 프로세스가 아니라 스레드를 기본 단위로 CPU 자원의 스케줄을 결정
    - 스레드는 자신이 포함된 프로세스의 메모리 주소 공간을 공유하기 때문에 한 프로세스 내 모든 스레드는 같은 변수에 접근하고 같은 힙에 객체를 할당

## 1.2 스레드의 이점

### 1.2.1 멀티프로세서 활용

- 프로세서가 하나라도 여러 개의 스레드를 활용하면 처리 속도를 높일 수 있다

### 1.2.2 단순한 모델링

- 비동기적인 작업 흐름을 각기 별도 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇개로 나눌 수 있다
- 이 장점은 서블릿, RMI와 같은 프레임웍에서 종종 활용된다
    - 프레임웍은 요청 관리, 스레드 생성, 로드 밸런싱, 작업 흐름 내 적절한 시점에 적절한 애플리케이션 컴포넌트에게 요청을 분배하는 상세한 부분 처리
    - 서블릿의 service 메서드 호출 시 해당 요청은 마치 단일 스레드 프로그램인 것처럼 ㅓ리

### 1.2.3 단순한 비동기 이벤트 처리

- 여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우 각 연결마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업이 수월해짐
- 이전까지 OS에서 하나의 프로세스가 생성할 수 있는 스레드 개수의 제약이 심해 최대 수백 개 정도 였지만 유닉스의 select, poll 시스템 콜과 같은 다중화 I/O 수단. 표준 자바 API의 대기 상태에 들어가지 않는 I/O를 지원하는 java.nio 패키지 추가

### 1.2.4 더 빨리 반응하는 사용자 인터페이스

- 시간이 오래 걸리는 작업을 별도의 스레드에서 실행한다면 이벤트 스레드는 UI 처리에만 신경 쓰게 되어, UI 반응이 높아짐

## 1.3 스레드 사용의 위험성

### 1.3.1 안전성 위해 요소

- 스레드는 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서가 예측하기 어렵다
- 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있다
- 동기화를 하지 않으면 컴파일러, 하드웨어, 실행환경 각각에서 명령어의 실행 시점이나 순서를 자유롭게 조정할 수 있고, 프로세서별 캐시 메모디레 변수를 캐싱해둘 수도 있다
- 이와 같은 최적화 작업은 프로그램에 오류가 발생하지 않도록 스레드 간에 데이터가 공유되고 있는지를 명확하게 구분해 줘야하는 부담을 프로그래머가 떠안아야 한다

### 1.3.2 활동성 위험

- 동시 수행 코드를 개발할 때는 반드시 스레드 안전성 문제를 신경 써야 한다
- 활동성 장애
    - 어떤 작업이 전혀 진전되지 못하는 상태에 빠지는 것
    - 예시 ⇒ 무한 루프, 데드락, 기아(starvation), 라이브락(live lock) 등
    - 이를 발생시키는 오류를 초기에 파악하는 것이 매우 어려움

### 1.3.3 성능 위험

- 추가적인 스레드 사용으로 인해 서비스 시간, 반응성, 처리율, 자원 소모, 규모에 따른 확장성 등에 문제가 발생할 수 있다
- JVM 실행 시
    - Main 메소드를 실행하는 주 스레드
    - GC, 객체 종료(object finalization)와 같은 JVM 내부 작업을 담당할 스레드도 생성
- 외부 스레드에서 프로그램 코드를 호출하는 것
    - 타이머 - Timer
        - Timer는 추후에 한 번 혹은 주기적으로 실행될 작업을 스케쥴하기 위한 편의 수단
        - Timer 사용 시 TimerTask에 지정된 작업이 프로그램이 아닌 Timer가 관리하는 스레드에서 실행
        - 만약 기본 프로그램의 스레드가 사용하는 데이터에 TimerTask 의 작업이 접근하면, TimerTask 뿐 아니라 해당 데이터에 접근하는 다른 모든 클래스도 스레드에 안전하게 해야한다
        - 스레드를 안전하게 하는 것은 공유된 데이터 객체 내부에 스레드 안전성을 캡슐화 하는 것
    - 서블릿과 JSP
        - 서블릿은 application-scoped 객체(ServletContext 객체에 저장)나 session-scoped 객체처럼 다른 서블릿과 공유하는 상태 정보에 접근할 때도 있다
        - 서블릿이 서블릿 간 혹은 요청들 간에 공유되는 객체에 접근할 때는 적절한 동기화 작업이 필요
    - 원격 메소드 호출(Remote Method Invocation)
        
        - RMI는 다른 JVM에서 실행 중인 객체의 메소드를 호출할 수 있게 해줌
        - RMI로 원격 메소드를 호출하면, 메소드 인자는 바이트 스트름으로 marshalled 되고 네트워크를 통해 원격 JVM으로 전달되고 원격 JVM에서 원래대로 unmarshalled되어 원격 메소드에 인자로 전달
        - 다른 객체와 공유될 수 있는 상태에 접근할 때, 원격 객체 자체의 상태에 접근할 때도 스레드 안전성에 주의해야함
        
        ## 1.4 스레드는 어디에나