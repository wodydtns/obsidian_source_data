## 1.1 자바 성능 : 잘못된 방법

- JVM의 자동 인라이닝(automatic managed inlining) 덕분에 가상 디스패치조차 대부분 call site(호출부)에서 사라짐

> **automatic managed inlining**  
> "Inlining"은 컴파일 타임 최적화 기술의 한 종류로, 메소드 호출을 메소드가 호출하는 코드 자체로 대체하는 방법입니다. 이는 메소드 호출에 따른 오버헤드를 줄여 성능을 향상시키는 효과가 있습니다. "Automatic managed inlining"은 이 과정을 자동으로 관리하는 것을 의미합니다. JVM은 실행 시간(runtime) 동안 프로그램의 동작을 분석하여 자주 호출되는 메소드나 짧은 메소드를 자동으로 인라인 처리합니다. 이는 개발자가 직접 최적화할 필요 없이 성능을 개선할 수 있게 해줍니다.  

---


> **Dispatch  
>   
> **"Dispatch"는 메소드 호출을 처리하는 방식을 말합니다. 이는 특히 객체 지향 프로그래밍에서 중요한 개념으로, 다형성을 실현하는 메커니즘입니다. "Dispatch"는 크게 세 가지 형태로 나뉩니다:
> 
> 1. **Static Dispatch**: 컴파일 시간에 어떤 메소드가 호출될지 결정됩니다. 이는 오버로딩된 메소드의 경우에 해당합니다.
> 2. **Dynamic Dispatch**: 런타임에 어떤 메소드가 호출될지 결정됩니다. 이는 오버라이드된 메소드 호출, 즉 다형성을 활용한 메소드 호출에서 주로 발생합니다.
> 3. **Late Binding** 또는 **Virtual Dispatch**: 객체의 실제 타입을 런타임에 확인하고 해당 타입에 맞는 메소드를 호출하는 방식입니다. Java에서는 이를 위해 가상 메소드 테이블(virtual method table, vtable)을 사용합니다.
> ---

> **JVM에서의 처리**
> 
> JVM은 "automatic managed inlining"과 "dispatch"를 다음과 같이 처리합니다:
> 
> - **Automatic Managed Inlining**: JVM의 JIT(Just-In-Time) 컴파일러는 실행 시간 동안 프로그램의 동작을 분석하여 자주 호출되는 메소드를 자동으로 인라인합니다. 이는 메소드 호출 오버헤드를 줄여주고, 더 나아가 분기 예측(branch prediction)의 정확성을 높여 프로세서의 성능을 극대화할 수 있습니다.
> - **Dynamic Dispatch**: JVM은 오버라이드된 메소드 호출을 처리하기 위해 "late binding" 기술을 사용합니다. 이 과정에서 가상 메소드 테이블을 조회하여 호출할 메소드의 실제 주소를 결정합니다. 이는 다형성을 지원하지만, 추가적인 런타임 비용을 발생시킵니다.
> - **최적화**: JVM은 프로파일링 정보를 기반으로 동적 디스패치를 최적화할 수 있습니다. 예를 들어, 특정 타입의 객체만 항상 사용되는 경우, JVM은 해당 메소드 호출을 더 빠른 정적 디스패치로 변경할 수 있습니다.

- JVM 최적화에 대한 일반적인 원칙
    - JVM을 더 빨리 작동시키는 ‘마법의 스위치’ 같은 건 없다
    - 자바를 더 빨리 실행하게 만드는 ‘팁, 트릭’은 없다
    - 우리들이 못보는 꼭꼭 숨겨둔 ‘비밀 알고리즘’은 없다

## 1.2 자바 성능 개요

> 자바 성능의 본질 - 제임스 고슬링  
> 자바는 블루 칼라 언어입니다. 박사 학위 논문 주제가 아니라 일을 하려고 만든 언어죠.  

- JVM의 탈착형 GC 서브시스템 형태의 자동 메모리 관리 덕분에 프로그래머는 수동으로 메모리를 의식하며 개발할 필요가 없다
- 측정 행위 자체도 오버헤드를 일으키고, 너무 잦은 샘플링이나 결과기록도 성능 결과 수치에 영향을 끼친다.
- **자바/JVM 어플리케이션을 우직한 기법으로 접근하면 부정확한 결과가 나올 공산이 크다**

## 1.3 성능은 실험과학이다

- 성능은 일종의 실험과학이다
    - 통계치에 근거에 적절히 결과를 처리하는 활동

## 1.4 성능 분류
- 가장 일반적인 성능 지표
    - 처리율
    - 지연
    - 용량
    - 사용률
    - 효율
    - 확장성
    - 저하
### 1.4.1 처리율

- (서브)시스템이 수행 가능한 작업 비율을 나타낸 지표
- 보통 일정 시간동안 완료한 작업 단위 수로 표시(ex. 초당 처리 가능한 트랜잭션 수)
- 처리율이 실제 성능을 반영하는 의미있는 지표가 되려면 수치를 얻은 기준 플랫폼에 대해서도 내용 기술이 필요(ex. 하드웨어, 소프트웨어 스펙, 단일 서버 or 클러스터 등)
- 트랜잭션이 모두 동일해야한다
### 1.4.2 지연

- 하나의 트랜잭션을 처리하고 그 결과를 반대편에서 받아볼 때 걸리는 시간
### 1.4.3 용량

- 시스템이 보유한 작업 병렬성의 총량
- 시스템이 동시 처리 가능한 작업 단위 개수
- 시스템에 동시 부하가 증가할수록 처리율에 영향을 받는다
### 1.4.4 사용률
- 시스템 리소스 활용률

### 1.4.5 효율
- 처리율을 리소스 사용률로 나눈 값

### 1.4.6 확장성
- 리소스 추가에 따른 처리율 변화

### 1.4.7 저하
### 1.4.8 측정값 사이의 연관 관계
- 각각의 요소들에 성능은 영향을 받는다

## 1.5 성능 그래프 읽기
- 성능 엘보(performance elbow)
        ![[Untitled 16 1.png]]
    
- 부하가 증가했을 때 지연 발생 예시 그래프
        ![[Untitled 1 1.png]]
