## 2.1 인터프리팅과 클래스로딩

- JVM은 스택 기반의 해석 머신
- 레지스터는 없지만 일부 결과를 실행 스택에 보관하며, 이 스택의 맨 위에 쌓인 값들을 가져와 계산
- JVM 인터프리터의 로직
    - 평가 스택을 이용해 중간값들을 담아두고, 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구성하는 opcode를 하나씩 순서대로 처리하는 “**while loop 안의 switch 문”**
    - java HelloWorld 명령을 내려 자바 애플리케이션을 실행하면 OS는 가상 머신 프로세스(자바 바이너리)를 구동 ⇒ 자바 가상 환경이 구성되고 스택 머신이 초기화된 다음, 실제로 유저가 작성한 HelloWorld 클래스 파일이 실행
- 자바 클래스로딩 메커니즘
    - 부트스트랩 클래스가 자바 런타임 코어 클래스를 load
        - 다른 클래스로더가 나머지 시스템에 필요한 클래스를 로드할 수 있게 최소한의 필수 클래스(ex. java.lang.Object, Class, Class loader)만 로드
    - 확장 클래스로더 생성
        - 부트스트랩 클래스로더를 자기 부모로 설정하고 필요할 때 클래스로딩 작업을 부모에게 넘김
        - 널리 쓰이지 않으나, 확장 클래스로더를 이용하면 특정 OS나 플랫폼에 네이티브 코드를 제공하고 기본 환경을 오버라이드할 수 있다
        - 자바 8에 내장된 자바스크립트 런타임 Nashorn을 로드
    - 애플리케이션 클래스로더가 생성되고 지정된 클래스패스에 위치한 유저 클래스를 로드
- 자바는 프로그램 실행 중 처음 보는 새 클래스를 dependency에 로드
- 클래스를 찾지 못한 클래스로더는 기본적으로 자신의 부모 클래스로더에게 대신 look up(찾아보기)을 넘김 ⇒ 부모에 부모… 부트스트랩도 룩업하지 못하면 ClassNotFoundException 발생

## 2.2 바이트코드 실행

- 자바 소스 코드의 실행을 위한 변환 과정
    1. 자바 컴파일러인 javac를 이용해 컴파일
        1. 바이트코드인 .class 파일로 변경
            
            ![[Untitled 2 1.png]]
            
        2. 바이트 코드는 중간 표현형
            
            > 중간 표현형 : 소스 코드를 표현하기 위해 컴파일러 또는 가상 시스템에서 내부적으로 사용하는 데이터 구조나 코드
            
        3. 클래스 파일 해부도
            
            ![[Untitled 3 1.png]]
            
            1. 0xCAFEBABE - 매직 넘버
                1. 이 파일이 클래스 파일임을 나타내는 것
            2. 메이저, 마이너 버전
                1. 메이저/마이너 버전에서 호환되지 않으면 런타임에 UnsupportedVersionError
            3. 상수 풀
                1. 코드 곳곳에 등장하는 상수값
                2. 코드 실행 시 런타임에 배치된 메모리 대신, 상수 풀 테이블을 찾아 필요한 값 참조
            4. 액세스 플래그
                1. 클래스에 적용한 수정자를 결정
                2. 플래그의 첫 부분은 public class인지, 그 다음은 Final 클래스인지 표시
                3. 이 클래스 파일이 인터페이스인지, 추상 클래스인지도 표시
                4. 플래그 끝 부분은 클래스 파일이 소스 코드에 없는 합성 클래스인지, 애너테이션 타입인지, Enum 인지를 각각 나타냄
            5. this class, upser class, 인터페이스 엔트리
                1. 클래스에 포함된 타입 계층
                2. 각각 상수 풀을 가리키는 인덱스로 표시
            6. 필드 & 메서드
                1. 시그니처 비슷한 구조를 정의
                2. 수정자도 포함
            7. 속성
                1. 더 복잡하고 크기가 고정되지 않은 구조를 나타낼 때 사용
    2. 예시
        1. 예시 코드
            
            ```Java
            public class HelloWorld {
            	public static void main(String[] args){
            		for (int i = 0; i < 10; i++){
            			System.out.println("Hello World");
            		}
            	}
            }
            ```
            
        2. 결과
            
            ```Java
            
            public class HelloWorld {
            	public HelloWorld(); 
            		Code:
            			0: aload_0
            			1: invokespecial \#1 // Method java/lang/Object."<init>":()2
            			4: return
            	public static void main(java.lang.String[]);
            		Code:
            			0: iconst_0
            			1: istore_1
            			2: iload_1
            			3: bipush 10
            			5: if icmpge 22
            			8: getstatic \#2 // Field java/lang/System.out...
            			11: ldc  \#3 // String Hello World
            			13: invokevirtual \#4 // Method java/io/PrintStream.println...
            			16: iinc 1, 1
            			19: goto 2
            			22: return
            	}
            ```
            
            1. aload_0
                1. this 래퍼런스를 스택 상단에 올려놓음
            2. invokespecial
                1. 슈퍼 생성자들을 호출, 객체를 생성하는 등 특정 작업을 담당하는 인스턴스 메서드 실행
                2. HelloWorld는 default 생성자라 오버라이드한 코드가 없으므로 Object 디폴트 생성자 배치
            3. Main 메서드
                1. iconst_0 - 정수형 상수 0을 평가 스택에 push
                2. istore_1로 이 상수값을 오프셋 1에 위치한 지역 변수(Loop의 i)에 저장
                3. 지역 변수 오프셋은 0부터 시작, 인스턴스 메서드에서 0번째 엔트리는 무조건 this
                4. 오프셋 1의 변수를 스택으로 다리 iload/_1한 뒤, 상수 10을 push(bipush 10)한 다음 if_icmpge로 둘을 비교(정수값이 10보다 같거나 큰가?)
                5. System.out의 정적 메서드를 해석(getstatic \#2)하고 상수 풀에서 “Hello World”라는 문자열을 로드(ldc \#3)
                6. invokevirtual 명령으로 이 클래스에 속한 인스턴스 메서드를 실행
                7. 정수값을 1 증가(iinc)되고 goto를 만나 2번 명령으로 이동
                8. 이 과정이 if_icmpge 테스트가 성공할 때 마다(i≥10 일 경우) 반복되다가 마지막에 22번 명령으로 제어권이 넘어가 메서드 반환
            
              
            

## 2.3 핫스팟 입문

- 핫스팟 JVM> [!important]  
    > 제로 코스트 추상화(zero cost abstraction)  
    
    ![[Untitled 4 1.png]]
    
    - 자바는 제로-오버헤드 추상화에 동조하지 않고, 프로그램의 런타임 동작을 분석하고 성능을 최적화하는 핫스팟을 사용
    - 핫스팟 VM의 목표는 개발자가 억지로 VM 틀에 맞게 프로그램을 욱여넣는 대신, 자연스럽게 자바 코드를 작성하고 바람직한 설계 원리를 따르도록 하는 것

### 2.3.1 JIT 컴파일이란?

- 자바 프로그램은 바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작
- CPU를 추상화한 구조라 다른 플랫폼에서도 클래스 파일을 문제없이 실행할 수 있지만, 프로그램이 최대 성능을 내려면 네이티브 기능을 활용해 CPU에서 직접 프로그램을 실행시켜야 함
- 핫스팟
    - 프로그램 단위(메서드와 루프)를 인터프리티드 바이트코드에서 네이티브 코드로 컴파일 ⇒ **JIT(just in time) 컴파일**
    - 인터프리티드 모드로 실행하는 동안 애플리케이션을 모니터링하면서 가장 자주 실행되는 코드 파트를 발견해 JIT 컴파일을 수행
    - 특정 메서드가 어느 임계점을 넘어가면 profiler가 특정 코드 섹션을 컴파일/최적화 수행
- JIT 컴파일 이점
    - 컴파일러가 해석 단계에서 수집한 추적 정보를 근거로 최적화를 결정하는 점
        - 상황별로 수집한 다양한 정보를 토대로 핫스팟이 더 올바른 방향으로 최적화
    - 핫스팟이 새 버전이 나올 때마다 최신 최적화 기법과 혜택을 추가해, 핫스팟 새 버전에서 자바 애플리케이션을 실행하는 것이 좋음
    - 자바처럼 프로필 기반 최적화(profile-guided optimization)를 응용하는 환경에서는 대부분의 AOT 플랫폼에서 불가능한 방식으로 런타임 정보를 활용할 수 있으므로 동적 인라이닝(dynamic inlining) 또는 가상 호출(virtual call) 등의 성능 개선 가능
        
        > AOT 컴파일러  
        > 프로그램을 실행하기 전에 코드를 기계어로 컴파일하는 기술  
        > AOT 컴파일러의 주요 목적은 실행 시간을 단축하고 성능을 최적화하는 것  
        >   
        > **Java는 전통적으로 JIT 컴파일러를 사용했지만, Java 9부터 선택적으로 AOT 컴파일 지원**
        
        > 동적 인라이닝
        > 
        > [동적 인라이닝](https://www.notion.so/1a0224ba0bd94d859937ce4411a7834b?pvs=21)
        
        > 가상 콜
        > 
        > [가상 호출](https://www.notion.so/423ff925c50e460fb3cf59705a353eca?pvs=21)
        

## 2.4 JVM 메모리 관리

- 자바는 Garbage Collector라는 프로세스를 이용해 힙 메모리를 자동 관리하는 방식으로 메모리 관리 수행
- GC : JVM이 더 많은 메모리를 할당해야 할 때 불필요한 메모리를 회수하거나, 재사용하는 불확정적 프로세스

## 2.5 스레딩과 자바 메모리 모델(JMM)

- JVM 구현체에서 자바 애플리케이션 스레드는 각각 정확히 하나의 전용 OS 스레드에 대응
- 공유 스레드 풀을 이용해 전체 자바 애플리케이션 스레드를 실행 시키는 방안(green threads)도 있지만, 복잡도만 가중 시킬 뿐, 만족할 만한 성능은 나오지 않는다
- 자바 멀티스레딩 방식의 세 가지 기본 설계 원칙
    - 자바 프로세스의 모든 스레드는 가비지가 수집되는 하나의 공용 힙을 가진다
    - 한 스레드가 생성한 객체는 그 객체를 참조하는 다른 스레드가 액세스할 수 있다
    - 기본적으로 객체는 변경 가능하다.즉, 객체 필드에 할당된 값은 프로그래머가 애써 Final 키워드로 불변 표시하지 않는 한 바뀔 수 있다
- JMM은 서로 다른 실행 스레드가 객체 안에 변경되는 값을 어떻게 바라보는지를 기술한 공식 메모리 모델

## 2.6 JVM 구현체 종류

- OpenJDK
    - 오라클이 직접 프로젝트를 주관/지원하며 자바 릴리즈 기준을 발표
- Oracle java
    - OpenJDK 기반
    - 오라클 상용라이선스
- Zulu
    - Azul systems에서 제작한 자바 풀 인증을 받은 무료(GPL 라이선스) opendjk
- IcedTea
    - 래드햇 제품, 자바 풀 인증을 받았고 재배포 가능
- Zing
    - 아줄 시스템이 제작한 고성능 상용 JVM
    - 자바 풀 인증을 받았고 64비트 리눅스에서만 작동
    - 대용량 힙 메모리와 멀티 CPU 서버급 시스템을 위해 설계
- J9
    - IBM에서 제작
    - 상용 JVM에서 중간에 오픈소스로 변경
    - 이클립스 OMR 프로젝트 기반
- Avian
    - 완전한 솔루션은 아니지만, JVM의 세부 작동 원리가 궁금한 개발자에게는 훌륭한 학습 도구
- Android

- 2.6.1 JVM 라이선스
    - JVM 구현체는 거의 다 오픈 소스

## 2.7 JVM 모니터링과 툴링

### 2.7.1 VisualVM

- 자바 관리 확장(java management Extensions)(JMX)
    - JVM과 그 위에서 동작하는 애플리케이션을 제어하고 모니터링하는 강력한 범용 툴
    - 메서드 호출 및 매개변수 변경 가능
- 자바 에이전트(java agent)
    - java.lang.instrument 인터페이스로 메서드 바이트코드 조작
    - 에이전트 추가 설치 플래그
        
        ```Java
        -javaagent:<에이전트 JAR 파일이 위치한 경로>=<옵션>
        ```
        
        - 에이전트 JAR 파일에 manifest(manifest.mf 파일)은 필수
        - Premain-class속성에 에이전트 클래스명을 반드시 지정해야함
        - Premain-class는 등록 후크(registeration hook) 역할을 수행하는 public static premain() 메서드 구현 필요
- JVM 툴 인터페이스(JVM tool interface)(JVMTI)
    - JVM의 네이티브 인터페이스
    - JVMTI를 사용하는 에이전트는 필수로 C/C++ 같은 네이티브 컴파일 언어로 작성 필요
    - 네이티브 에이전트 설치 플래그
        
        ```Java
        -agentlib:<에이전트 라이브러리명>=<옵션>
        ```
        
        ```Java
        -agentpath:<에이전트 경로>=<옵션>
        ```
        
- 서버서빌리티 에이턴트(SErviceability Agent)(SA)
    - 자바 객체, 핫스팟 자료 구조 모두 표출 가능한 API와 툴을 모아놓은 것
    - SA를 이용하면 대상 JVM엣 코드를 실행할 필요 없음
    - 핫스파 SA는 symbol lookup 같은 기본형을 사용하거나 프로세스 메모리를 읽는 방식으로 디버깅
    - SA는 코어 파일(core file, crash dump file) & 자바 프로세스까지 디버깅 가능

- JVM 모니터링 툴의 일종

> [!important]  
> attach mechanism : 자바 Attach API를 이용해 어플리케이션을 타깃 JVM에 부착하는 장치  

- VisualVM은 attach mechanism을 이용해 실행 프로세스를 실시간 모니터링
- 로컬 프로세스는 화면 좌측에 프로세스 나열
- 원격 프로세스는 원격지로부터 JMX를 통해 인바운드(안으로 들어오는) 접속이 허용돼야한다
    - 탭에서 hostname, display name을 입력해 원격 프로세스에 접속
- JVM의 탭들
    - 개요(Overview)
        - 자바 프로세스에 관한 요약 정보 표시
        - 프로세스에 전달한 전체 플래그와 시스템 프로퍼티, 실행중인 자바 버전 조회
    - 모니터(Monitor)
        - CPU, 힙 사용량 등 JVM을 고수준에서 원격 측정한 값들 표시
        - 로드/언로드된 클래스 개수 및 실행 중인 스레드 개수 등 현황 파악
    - 스레드(Thread)
        - 실행 중인 애플리케이션 각 스레드(애플리케이션 스레드 + VM 스레드)가 시간대별로 표시
        - 스레드별 상태와 짧은 변화 추이를 보면서 필요시 Thread Dump를 뜰 수 있음
    - 샘플러 및 프로파일러(Sample and profiler)
