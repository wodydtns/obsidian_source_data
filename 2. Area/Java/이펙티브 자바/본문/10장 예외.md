### 아이템 69. 예외는 진짜 예외 상황에만 사용하라

- 적절하게 예외 처리하기
    - JVM의 예외 접근 방법
        - 예외는 예외 상황에 쓸 용도로 설계되었으므로, JVM 구현자 입장에서 명확한 검사만큼 빠르게 만들어야 할 동기가 약하다. 즉 최적화에 별로 신경쓰지 않았을 가능성이 크다
        - 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다
        - 배열을 순회하는 표준 관용구는 앞서 걱정한 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애준다
    - **예외는 그 이름이 말해주듯 오직 예외 상황에서만 써야 한다. 절대로 일상적인 제어 흐름용으로 쓰여선 안된다**
        - 표준적이고 쉽게 이해되는 관용구를 사용하고, 성능 개선을 목적으로 과하게 머리를 쓴 기법은 자제하라
    - **잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다**
        - 특정 상태에서만 호출할 수 있는 ‘상태 의존적’ 메서드를 제공하는 클래스는 ‘상태 검사’ 메서드도 함께 제공해야 한다
            - Iterator 인터페이스의 next와 hasNext가 각각 상태 의존적 메서드와 상태 검사 메서드에 해당한다
    - 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침
        - 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용한다. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문이다
        - 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택한다
        - 다른 모든 경우엔 상태 검사 메서드 방식이 좀 더 낫다고 할 수 있다. 가독성이 살짝 좋고, 잘못 사용했을 때 발견하기 쉽다. 상태 검사 메서드 호출을 깜빡 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 들어낼 것이다. 반면 특정 값은 검사하지 않고 지나쳐도 발견하기가 어렵다
- 핵심 정리
- 예외는 예외 상황에서 쓸 의도로 설계 되었다. 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안된다

### 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라

- 예외 사용 예를 구분하기
    - 지침
        - **호출하는 쪽에서 복구하리라 여겨지는 상황이라면 검사 예외를 사용하라**
            - 검사 예외를 던지면 호출자가 그 예외를 catch로 잡아 처리하거나 더 바깥으로 전파하도록 강제하게 된다. 따라서 메서드 선언에 포함된 검사 예외 각각은 그 메서드를 호출했을 때 발생할 수 있는 유력한 결과임을 API 사용자에게 알려주는 것이다
            - API 설계자는 API 사용자에게 검사 예외를 던져주어 그 상황에서 회복해내라고 요구하는 것이다
        - 비검사 throwable
            - 런타임 예외 & 에러
            - 프로그램에서 비검사 예외나 에러를 던졌다는 의미는 복구가 불가능하거나 더 실행해봐야 득보다 실이 많다는 뜻
            - 이런 throwable을 잡지 않은 스레드는 적절한 오류 메시지를 내뱉으며 중단된다
            - **throwable은 사용하지 말자**
            - **throwable 클래스는 대부분 오류 메시지 포맷을 상세히 기술하지 않는데, 이는 JVM이나 릴리스에 따라 포맷이 달라질 수 있다는 뜻이다. 따라서 메시지 문자열을 파싱해 얻은 코드는 깨지기 쉽고 다른 환경에서 동작하지 않을 수 있다**
        - **프로그래밍 오류를 나타낼 때는 런타임 예외를 사용하자**
            - 런타임 예외의 대부분은 전제조건을 만족하지 못했을 때 발생한다 ⇒ 복구할 수 있는 오류인지 항상 명확히 구분하기 어렵다
            - 복구가 가능하다고 믿는다면 검사 예외를, 아니라면 런타임 예외를 사용하자
        - 당신이 구현하는 비검사 throwable은 모두 RuntimeException의 하위 클래스여야 한다. Error는 상속하지 말아야할 뿐만 아니라, throw 문으로 직접 던지는 일도 없어야 한다(AssertionError는 예외)
- 핵심 정리
    - 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자
    - 확실하지 않다면 비검사 예외를 던지자
    - 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지도 말자
    - 검사 예외라면 복구에 피룡한 정보를 알려주는 메서드도 제공하자

### 아이템 71. 필요 없는 검사 예외 사용은 피하라

- 제대로 검사 예외 사용하기
    - 검사 예외는 발생한 문제를 프로그래머가 처리해 안정성을 높힐 수 있다
    - 어떤 메서드가 검사 예외를 던질 수 있다고 선언됐다면, 이를 호출하는 코드에서는 catch 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다.
    - API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 있는 조취를 취할 수 있는 경우라면 이 정도 부담쯤은 받아들일 수 있다. 하지만 둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는 게 좋다
    - 검사 예외가 프로그래머에게 지우는 부담은 메서드가 단 하나의 검사 예외만 던질 때 특히 크다.이미 다른 검사 예외도 던지는 상황에서 검사를 추가한다면 catch 문 하나만 추가하면 되지만, 검사 예외가 단 하나뿐이라면 그 예외 때문에 API 사용자가 try 블록을 추가하고 스트림에서 직접 사용하지 못하게 된다 ⇒ 이런 상황에선 검사 예외를 안 던지는 방법이 없는지 고민해볼 가치가 있다
    - 검사 예외 회피 방법
        - 적절한 결과 타입을 담은 옵셔널을 반환 ⇒ 검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환
            - 이 방식의 단점은 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다
            - 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다
        - 검사 예외를 던지는 메서드를 2개로 쪼개 비검사 예외로 변경
            - 예시
                
                ```Java
                if (obj.actionPermitted(args)) {
                	obj.actrion(args);
                } else {
                	... // 예외 상황에 대처한다
                }
                ```
                
- 핵심 정리
    - 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다
    - API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자
    - 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자.
    - 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자

### 아이템 72. 표준 예외를 사용하라

- 표준 예외 사용하기
    - 표준 예외를 재사용 시 얻는 것
        - API가 다른 사람이 익히고 사용하기 쉬워짐 ⇒ 이미 익숙한 규약을 그대로 따르기 때문
        - 익숙한 코드라 가독성이 높아짐
        - 예외 클래스 수가 적을수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸린다
    - IllegalArgumentException
        - 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외
        - 대상 객체의 상태가 호출된 메서드를 수행하기에 적합하지 않을 때 주로 던진다. 예를 들어 제대로 초기화되지 않은 객체를 사용하려 할 때
    - ConcurrentModificationException
        - 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때 발생
    - UnsupportedOperationException
        - 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때
        - 보통 구현하려는 인터페이스의 메서드 일부를 구현할 수 없을 때
        - 예를 들어 원소를 넣을 수만 있는 List 구현체에 대고 누군가 remove 메서드를 호출 시
    - **Exception, RuntimeException, Throwable, Error는 직접 재사용하지 말자**
        - **이 클래스는 추상 클래스라고 생각하라**
    - **인수 값이 무엇이었든 어차피 실패했을 거라면 IllegalStateException, 그렇지 않으면 IllegalArgumentException을 던지자**

### 아이템 73. 추상화 수준에 맞는 예외를 던지라

- 추상화 수준에 따른 예외 사용
    - **상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야한다(예외 번역(exception translation)**
    - 예시
        
        ```Java
        try {
        	... // 저수준 추상화를 이용
        } catch (LowerLevelException e) {
        	// 추상화 수준에 맞게 번역
        	throw new HigherLevelException(...);
        }
        ```
        
    - 예외를 번역할 때, 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄(exception chaining)를 사용하는 게 좋다
        - 예외 연쇄란 문제의 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식
        - 예시
            
            ```Java
            try {
            	... // 저수준 추상화를 이용
            } catch (LowerLevelException cause) {
            	// 추상화 수준에 맞게 번역
            	throw new HigherLevelException(cause);
            }
            ```
            
        - 예외 연쇄용 생성자
            
            ```Java
            class HigherLevelException extends Exception {
            	HigherLevelException(Throwable cause) {
            		super(cause);
            	}
            }
            ```
            
    - **무턱대고 예외를 전파하는 것보다 예외 번역이 우수한 방법이지만, 남용해서는 안된다**
    - 가능하면 저수준 메서드가 반드시 성공하도록해 아래 계층에서는 예외가 발생하지 않도록 하는 것이 최선이다
    - 때론 상위 계층 메서드의 매개변수 값을 아래 계층 메서드로 건네기 전에 미리 검사하는 방법으로 이 목적을 달성할 수 있다
    - 차선책
        - 아래 계층의 예외를 피할 수 없다면, 상위 계층에서 그 예외를 조용히 처리하고 문제를 API 호출자에까지 전파하지 않는 방법 사용
            - 이 경우 발생한 예외는 java.util.logging 같은 적절한 로깅 기능을 활용해 기록하자
- 핵심 정리
    - 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라
    - 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다

### 아이템 74. 메서드가 던지는 모든 예외를 문서화하라

- 메서드의 예외 문서화
    - **검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독이 @throws 태그를 사용해 정확히 문서화하자**
    - 극단적으로 메서드가 Exception이나 Throwable을 던진다고 선언해서는 안된다
    - 비검사 예외도 검사 예외처럼 정성껏 문서화 해두면 좋다
        - 자신이 일으킬 수 있는 오류들이 무엇인지 알려주면 프로그래머는 자연스럽게 해당 오류가 나지 않도록 코딩하게 된다
        - 잘 정비된 비검사 예외 문서는 사실상 그 메서드를 성공적으로 수행하기 위한 전제 조건
        - public 메서드라면 필요한 전제조건을 문서화해야 하며, 비검사 예외들을 문서화는 것이 제일 좋다
    - **메서드가 던질 수 있는 예외를 각각 @throws 태그로 문서화하되, 비검사 예외는 메서드 선언의 throws 목록에 넣지 말자**
    - 비검사 예외도 모두 문서화라고 했지만 현실적으로 불가능한 경우가 있다
        - 클래스를 수정하면서 새로운 비검사 예외를 던지게 되어도 소스 호환성과 바이너리 호환성이 그대로 유지된다는 게 큰 이유
        - **한 클래스에 정의된 많은 메서드가 같은 이유로 같은 예외를 던진다면 그 예외를 각각의 메서드가 아닌 클래스 설명에 추가하는 방법도 있다**
- 핵심 정리
    - 메서드가 던질 가능성이 있는 모든 예외를 문서화하라
    - 검사 예외든 비검사 예외든, 추상 메서드든 구체 메서드든 마찬가지다 ⇒ 자바독의 @throws태그를 사용하라
    - 검사 예외만 메서드 선언의 throws 문에 일일이 선언하고, 비검사 예외는 메서드 선언에는 기입하지 말자
    - 발생 가능한 예외를 문서로 남기지 않으면, 다른 사람이 이 클래스나 인터페이스를 효과적으로 사용하기 어렵거나 심지어 불가능할 수도 있다

### 아이템 75. 예외의 상세 메시지에 실패 관련 정보를 담으라

- 예외의 상세 메시지 남기기
    - 예외의 toString 메서드에 실패 원인에 관한 정보를 가능한 한 많이 담아 반환하는 일이 아주 중요하다. 달리 말하면 ,사후 분석을 위해 실패 순간의 상황을 정확히 포착해 예외의 상세 메시지에 담아야한다
    - **실패 순간을 포착하려면 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메시지에 담아야한다**
        - IndexOutOfBoundsException의 상세 메시지는 범위의 최솟값, 최대값, 범위를 벗어났다는 인덱스의 값을 담아야한다
        - 상세 메시지에 비밀번호나 암호 키 같은 정보까지 담아서는 안된다
        - 문제를 분석하는 사람은 스택 추적뿐 아니라 관련 문서와 필요하다면 소스코드를 함께 살펴본다
    - 예외의 상세 메시지와 최종 사용자에게 보여줄 오류 메시지를 혼동해서는 안된다.
        - 최종 사용자에게는 친절한 안내 메시지를 보여줘야 하는 반면, 예외 메시지는 가독성보다 담긴 내용이 훨씬 중요하다. 예외 메시지는 주로 프로그래머와 SRE 엔지니어가 보기 때문이다
    - 실패를 적절히 포착하려면 필요한 정보를 예외 생성자에서 모두 받아 상세 메시지까지 미리 생성해놓는 방법도 있다.
        - 예시
        
        ```Java
        public IndexOutBoundsException(int lowerBound, int upperBound, int index) {
        	//실패를 포착하는 상세 메시지를 생성한다
        	super(String.format("최솟값: %d, 최대값: %d, 인덱스: %d", 
        					lowerBound, upperBound, index));
        	// 프로그램에서 이용할 수 있도록 실패 정보를 저장해둔다
        	this.lowerBound = lowerBound;	
        	this.upperBound = upperBound;
        	this.index = index;
        }
        ```

### 아이템 76. 가능한 한 실패 원자적으로 만들라

- 메서드를 실패 원자적으로 만들기
    - **호출된 메서드가 실패하더라도 해당 객체는 메서드 호출 전 상태를 유지해야 한다 ⇒ 실패 원자적(failure-atomic)**
    - 메서드를 실패 원자적으로 만드는 방법
        - 불변 객체로 설계
            
            - 불변 객체는 태생적으로 실패 원자적이다
            - 예시
            
            ```Java
            public Object pop() {
            	if (size == 0) {
            		throw new EmptyStackException();
            	}
            	Object result = elements[--size];
            	elements[size] = null ; // 다 쓴 참조 해제
            	return result;
            }
            ```
            
    - 샐프 가능성이 있는 모든 코드를, 객체의 상태를 바꾸는 코드보다 앞에 배치하는 방법
        - 예시 - TreeMap
            - TreeMap은 원소들을 어떤 기준으로 정렬 → TreeMap에 원소를 추가하려면 그 원소를 TreeMap의 기준에 따라 비교할 수 있는 타입이어야 함 ⇒ 엉뚱한 타입의 원소를 추가할 경우 해당 원ㅅ과 들어갈 위치를 찾는 과정에서 ClassCastException이 발생함
    - 객체의 임시 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교환하는 것
        - 데이터를 임시 자료구조에 저장해 작업하는 게 더 빠를 때 적용하기 좋은 방식
            - 어떤 정렬 메서드는 정렬을 수행하기 전에 입력 리스트의 원소들을 배열로 옮긴다 → 배열을 사용하면 정렬 알고리즘의 반복문에서 원소들에 훨씬 바르게 접근할 수 있기 때문
    - 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성해 작업 전 상태로 되돌리는 방법
        - 주로 디스크 기반의 내구성을 보장해야 하는 자료구조에 사용
    - 실패 원자성은 권장되는 덕목이지만 항상 달성하기 어렵다
        - 예를 들어 두 스레드가 동기화 없이 같은 객체를 동시에 수정한다면 그 객체의 일관성이 깨질 수 있다. 따라서 ConcurrentModificationException을 잡아냈다고 해서 그 객체가 여전히 쓸 수 있는 상태라고 가정해서는 안된다
        - Error는 복구할 수 없으므로, AssertionExrror에 대해 실패 원자적으로 만드려는 시도조차 할 필요가 없다
    - 실패 원자성을 만들 수 있다 하더라도 항상 그래야하는 것은 아니다
        - 이를 달성하기 위한 비용이나 복잡도가 아주 큰 연산이 있기 때문이다

### 아이템 77. 예외를 무시하지 말라

- 예외를 소중히
    - **try-catch 에서 catch블록을 비우지 마라**
    - 예외를 무시해야할 경우
    - FileInputStream을 닫을 때
        - 입력 전용 스트림이므로 파일의 상태를 변경하지 않았으니 복구할 것이 없고, 스트림을 닫는다는 것은 이미 필요한 정보는 다 읽었다는 뜻이니 남은 작업을 중단한 이유도 없다
    - **예외를 무시하기로 했다면 catch 블록 안에 그렇게 결정한 이유를 주석으로 남기고 예외 변수의 이름도 ignored로 바꿔놓도록 하자**