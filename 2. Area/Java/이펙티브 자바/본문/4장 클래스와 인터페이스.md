### 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라

- 정보 은닉
    - 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리 → 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개이치 않음
    - 정보 은닉의 장점
        - 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다
        - 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악해 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문이다
        - 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다. 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문이다
        - 소프트웨어 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다
        - 큰 시스템을 제작하는 난이도를 낮춰준다. 시스템 자체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문이다.
    - 접근 제한자를 활용하는 것이 정보 은닉의 핵심
    - 정보 은닉의 기본 원칙
        - **모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다 → 소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야한다.**
    - 패키지 외부에서 사용할 이유가 없다면 package-private으로 선언 → 클라이언트에 아무런 피해 없이 다음 릴리스에서 수정,교체 제거 가능 | public은 API가 되므로 하위 호환을 위해 영원히 관리해줘야한다.
    - 한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스 안에 private static으로 중첩 → 톱레벨로 두면 같은 패키지의 모든 클래스가 접근할 수 있지만, private static으로 중첩시키면 바깥 클래스 하나에서만 접근
    - public일 필요가 없는 클래스의 접근 수준을 package-private으로 줄여야함
    - 멤버(필드, 메서드, 중첩 클래스, 중첩 인터페이스)에 부여할 수 있는 접근 수준
        - private : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다
        - package-private : 멤버가 소속도 패키지 안의 모든 클래스에서 접근할 수 있다. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준(단 인터페이스의 멤버는 기본적으로 public이 적용된다)
        - pretected : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다
        - public : 모든 고셍서 접근할 수 있다.
    - 권한을 풀어주는 일을 자주 하게 된다면, 시스템에서 컴포넌트를 더 분해해야 하는 것은 아닌지 고민 필요
    - private & package-private 멤버는 모두 해당 클래스의 구현에 해당 → 보통 공개 API에 영향을 주지 않는다. 단 Serializable을 구현한 클래스에서는 그 필드들도 의도치 않게 공개 API가 될 수 있음
        - 예시
            
            ```Java
            import java.io.Serializable;
            
            public class MyClass implements Serializable {
                private int privateField;
                int packagePrivateField;
                public int publicField;
            
                public MyClass(int privateField, int packagePrivateField, int publicField) {
                    this.privateField = privateField;
                    this.packagePrivateField = packagePrivateField;
                    this.publicField = publicField;
                }
            }
            ```
            
            - 설명
                - `MyClass`에는 `privateField`, `packagePrivateField` 및 `publicField`의 세 가지 필드가 있습니다. 일반적으로 private 및 package-private 필드는 클래스 외부에서 액세스할 수 없습니다. 그러나 이 클래스의 개체가 직렬화되면 직렬화 메커니즘에서 개인 및 패키지 개인 필드에 액세스할 수 있습니다.
        - Myclass를 사용해 공용 API 만들기
            
            ```Java
            import java.io.FileInputStream;
            import java.io.ObjectInputStream;
            
            public class AnotherClass {
                public static void main(String[] args) {
                    try {
                        FileInputStream fileIn = new FileInputStream("serializedObject.ser");
                        ObjectInputStream in = new ObjectInputStream(fileIn);
                        MyClass obj = (MyClass) in.readObject();
                        in.close();
                        fileIn.close();
            
                        int privateFieldValue = obj.privateField;  // Accessible even though it's private
                        int packagePrivateFieldValue = obj.packagePrivateField;  // Accessible even though it's package-private
                        int publicFieldValue = obj.publicField;  // Accessible as expected
            
                        // Use the values...
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
            ```
            
        - 설명
            - `MyClass`의 개체를 역직렬화하고 원래 공개 API의 일부가 아니었던 private 및 package-private 필드에 직접 액세스합니다. 이는 직렬화가 그렇지 않으면 액세스할 수 없는 필드를 실수로 노출할 수 있는 방법을 보여줍니다
    - 멤버 접근성을 좁히지 못하게 하는 제약
        - 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없음 ⇒ 리스코프 치환 원칙을 지키기 위해 필요 ⇒ 위반 시 컴파일 에러
    - 코드 테스트 목적
        - 적당한 수준까지 가능 → public 클래스의 private 멤버를 package-private 까지 풀어주는 것은 허용할 수 있지만 그 이상 X ⇒ 테스트만을 위해 클래스, 인터페이스, 멤버를 공개 API를 만들어서는 안된다
    - **public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.**
        - 필드가 가변 객체 참조, final이 아닌 인스턴스 필드를 public으로 선언 시 필드에 담을 수 있는 값을 제한할 수 없음 ⇒ **public 가변 필드를 갖는 클래스는 일반적으로 thread safety하지 않음**
    - 꼭 필요한 구성요소로써의 상수라면 public static final 필드로 공개해도 좋음
        - 대문자 알파벳, 각 단어 사이에 밑줄(_)을 넣음
        - 반드시 기본 타입 값이나 불변 객체를 참조해야함
    - **클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안된다.**
        - 문제 코드
            
            ```Java
            // 보안 취약점 있음 -> 어떤 IDE가 생성하는 접근자는 private 배열 필드의 참조를 반환해 문제 있음
            public static final Thing[] VALUES = { ... } ;
            ```
            
        - 해결책1 
            
            ```Java
            public static final Thing[] PRIVATE_VALUES = { ... } ;
            public static final List<Thing> VALUES =
            	Collections.unmodifiableList(Array.asList(PRIVATE_VALUES));
            ```
            
        - 해결책2 
            
            ```Java
            public static final Thing[] PRIVATE_VALUES = { ... } ;
            public static final Thing[] values() {
            		return PRIVATE_VALUES.clone():
            }
            ```
            
- 자바 9의 모듈 시스템
    - 암묵적 접근 수준
        - 모듈 = 패키지들의 묶음
        - 모듈은 자신에 속하는 패키지 중 export할 것들을 선언(관례상 module-info.java)
        - 모듈 안에서는 exports 선언했는지 여부에 아무런 영향 X ⇒ 모듈 시스템을 활용하면 클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서 자유롭게 공유
        - 각각 public , protected 수준이 동일, 효과가 모듈 내부로 한정되는 변종
        - 모듈이 공개했는지 여부와 상관없이, public 클래스가 선언할 모든 public 혹은 protected 멤버를 모듈 밖에서도 접근할수 있게 됨
    - 모듈의 장점을 누리기 위해 해야할 일
        
        1. 패키지들을 모듈 단위로 묶기
        2. 모듈 선언에 패키지들의 모든 의존성을 명시
        3. 소스 트리를 재배치
        4. 모듈 안으로부터 (모듈 시스템을 적용하지 않는) 일반 패키지로의 모든 접근에 특별한 조치를 해야함
        
        - 꼭 필요한 경우가 아니라면 당분간은 사용하지 않는 게 좋을 것 같다
- 핵심 정리
    - 프로그램 요소의 접근성은 가능한 한 최소한으로 하라
    - 꼭 필요한 것만 최소한의 pulbic API를 설계. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야한다
    - public 클래스는 상수용 public static final 필드 외에는 어떤 public 필드도 가져서는 안된다
    - public static final 필드가 참조하는 객체가 불변인지 확인하라

### 아이템 16.public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

- 캡슐화
    - 접근자와 변경자(mutator) 메서드를 활용해 데이터를 캡슐화한다 
        
        ```Java
        class Point {
        	private double x;
        	private double y;
        
        	public Point(double x,double y) {
        		this.x = x;
        		this.y = y;
        	}
        
        	public double getX() { return x; }
        	public double getY() { return y; }
        
        	public void setX(double x) { this.x = x; }
        	public void setY(double y) { this.y = y; }
        }
        ```
        
        - 패키지 바깥에서 접근할 수 있눈 클래스라면 접근자를 제공 → 유연성 획득
    - package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등 문제 X ⇒ 그 클래스가 표현하려는 추상 개념만 올바르게 표현하면 됨
        
        ```Java
        package com.example;
        
        class PackagePrivateClass {
            int packagePrivateField;
        
            PackagePrivateClass(int packagePrivateField) {
                this.packagePrivateField = packagePrivateField;
            }
        }
        
        public class OuterClass {
            private static class PrivateNestedClass {
                int privateNestedField;
        
                PrivateNestedClass(int privateNestedField) {
                    this.privateNestedField = privateNestedField;
                }
            }
        
        		// main에서 PackagePrivateClass , PrivateNestedClass 인스턴스 생성을 통해 데이터 필드에 액세스하고 조작 가능
            public static void main(String[] args) {
                PackagePrivateClass packagePrivateObj = new PackagePrivateClass(42);
                System.out.println(packagePrivateObj.packagePrivateField);  // Accessing package-private field
        
                PrivateNestedClass privateNestedObj = new PrivateNestedClass(123);
                System.out.println(privateNestedObj.privateNestedField);  // Accessing private nested field
            }
        }
        ```
        
    - 자바 플랫폼 라이브러리의 public 클래스 필드 직접 노출을 어기는 사례 - java.awt.package 패키지의 Point, Dimension
        
        [예시](https://www.notion.so/27178660d67b413fa541c083d0670fa3?pvs=21)
        
    - 불변 필드를 노출한 public 클래스 - 과연 좋은가?
        - public 클래스의 필드가 불변이라면 직접 노출의 단점은 조금 줄어들지만 좋은 생각은 X
        - API를 변경하지 않고는 표현 방식을 바꿀 수 없고, 필드를 읽을 때 부수 작업을 수행할 수 없다
        - 코드
            
            ```Java
            public final class Time {
            	private static final int HOURS_PER_DAY = 24;
            	private static final int MINUTES_PER_HOUR = 60;
            
            	public final int hour;
            	public final int minute;
            
            	public Time(int hour, int minute) {
            		if (hour < 0 || hour >= HOURS_PER_DAY ) {
            			throw new IllegalArgumentException("시간: " +  hour);
            		}
            		if (minute< 0 || minute>= MINUTES_PER_HOUR ) {
            			throw new IllegalArgumentException("분: " +  minute);
            		}
            		this.hour = hour;
            		this.minute= minute;
            	}
            }
            ```
            
- 핵심 정리
    - public 클래스는 절대 가변 필드를 직접 노출해서는 안된다
    - 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다.
    - package-private 클래스나 private 중첩 클래스에서는 종종( 불변 , 가변) 필드를 노출하는 편이 나을때도 있다

### 아이템 17. 변경 가능성을 최소화하라

- 불변 클래스 만들기
    - 불변 클래스 예시 : String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal
    - 클래스 불변 설계의 이유 : 가변 클래스보다 설계, 구현, 사용이 용이 & 오류 발생 가능성이 적고 안전
    - 불변으로 클래스를 만들기 위한 다섯 가지 규칙
        - **객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다**
        - **클래스를 확장할 수 없도록 한다**
            - 하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아준다
            - 대표적 예시로 클래스를 final로 선언
        - **모든 필드를 final로 선언한다**
            - 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법
            - 새로 생성된 인스턴스를 동기화 없이 다른 스레드로 건네도 문제없이 동작하게끔 보장하는 데도 필요
        - **모든 필드를 private으로 선언한다**
            - 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다
            - 기술적으로 기본 타입 필드나 불변 객체를 참조하는 필드를 public final로만 선언해도 불변 객체 ⇒ 비권장
        - **자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다**
            - 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야한다
            - 이런 필드는 절대 클라이언트가 제공한 객체 참조를 가리키게 해서는 안 되며, 접근자 메서드가 그 필드를 그대로 반환해서는 안된다.
            - **생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행하라**
    - 불변 복소수 클래스 예시 - 함수형 프로그래밍
        
        ```Java
        public final class Complex {
        	private final double re;
        	private final double im;
        
        	public Complex(double re, double im) {
        		this.re = re;
        		this.im = im;
        	}
        
        	public double realPart() {return re; }
        	public double imaginaryPart() {return im; }
        
        	public Complex plus(Complex c) {
        		return new Complex(re + c.re, im + c.im);
        	}
        
        	public Complex minus(Complex c) {
        		return new Complex(re - c.re, im - c.im);
        	}
        
        	public Complex times(Complex c) {
        		return new Complex(re * c.re - im * c.im,
        											re * c.re + im * c.im );
        	}
        
        	public Complex dividedBy(Complex c) {
        		double tmp = c.re * c.re + c.im * c.im;
        		return new Complex((re * c.re + im * c.im) / tmp,
        											(im * c.re - re * c.im) /tmp  );
        	}
        
        	@Override
        	public boolean equals(Object o) {
        		if (o == this){
        			return true;
        		}
        		if (!(o instanceof Complex)) {
        			return false;
        		}
        		Complex c = (Complex) o;
        		// equals 대신 compare 사용
        		return Double.compare(c.re, re) == 0
        					Double.compare(c.im, im) == 0;
        	}
        
        	@Override
        	pulbic int hashCode() {
        		returnj 31 * Double.hashCode(re) + Double.hashCode(im);
        	}
        
        	@Override
        	public String toString() {
        		return "(" + re + " + " + im + "i)";
        	}
        }
        ```
        
    - **불변 객체는 단순하다**
    - 불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직한다 → 모든 생성자가 클래스 불변식을 보장한다면 그 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않더라도 영원히 불변으로 남는다
    - **불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요 없다**
    - **불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변 객체는 안심하고 공유할 수 있다 ⇒ 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용해라**
        - 예시 - 정적 팩터리 제공
            
            ```Java
            public static final Complex ZERO = new Complex(0,0);
            public static final Complex ONE = new Complex(1,0);
            public static final Complex I = new Complex(0,1);
            ```
            
        - 여러 클라이언트가 인스턴스를 공유해 메모리 사용량과 가비지 컬렉션 비용이 줄어듦
        - 정적 팩터리를 통해 클라이언트를 수정하지 않고도 필요에 따라 캐시 기능을 붙이기 가능함
    - 불변 객체를 자유롭게 공유 → 방어적 복사도 필요 없다 ⇒ clone 메서드나 복사 생성자를 제공하지 않는 것을 권유 | String 클래스의 복사 생성자를 되도록 사용하지 말아야함
     **불변 객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다 ⇒ BigInteger 클래스는 내부에서 값의 부호(sign)와 크기(magnitude)를 따로 표현**
    ```Java
            import java.math.BigInteger;
            
            public class BigIntegerExample {
            
                public static void main(String[] args) {
                    // BigInteger 생성
                    BigInteger bigInteger = new BigInteger("-1234567890123456789");
            
                    // 부호(signum) 확인
                    int signum = bigInteger.signum();
                    System.out.println("Signum: " + signum);  // 출력: Signum: -1
            
                    // 크기(magnitude) 확인
                    BigInteger magnitude = bigInteger.abs();
                    System.out.println("Magnitude: " + magnitude);  // 출력: Magnitude: 1234567890123456789
            
                    // 새로운 부호와 크기를 가진 BigInteger 생성
                    BigInteger newBigInteger = BigInteger.valueOf(signum).multiply(magnitude);
                    System.out.println("New BigInteger: " + newBigInteger);  // 출력: New BigInteger: -1234567890123456789
                }
            }
            ```
            
    - **객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많음**
        - 값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 수월함
    - **불변 객체는 그 자체로 실패 원자성을 제공한다 ⇒ 상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없음**> [!important]  
        > 실패 원자성 "실패 원자성(Failure Atomicity)"은 프로그래밍 및 컴퓨터 과학의 개념 중 하나로, 특히 자료구조 및 알고리즘, 데이터베이스 시스템, 분산 시스템 등에서 중요한 역할을 합니다.실패 원자성은 어떤 연산이 실패했을 때도 시스템의 상태가 해당 연산이 시작하기 전의 상태로 유지되는 속성을 의미합니다. 즉, 연산은 모두 성공하거나, 일부만 수행된 후 실패한 경우 원래의 상태로 롤백되는 것입니다.이 속성은 프로그램이 예기치 못한 문제나 예외 상황에 직면했을 때 데이터의 일관성을 보장하는 데 매우 중요합니다. 예를 들어, 데이터베이스 트랜잭션에서는 ACID 원칙 중 하나인 원자성(Atomicity)이 이에 해당합니다. 원자성은 트랜잭션이 완전히 성공하거나 (모든 변경 사항이 데이터베이스에 반영되거나) 아니면 전혀 실행되지 않은 것처럼 (어떠한 변경 사항도 반영되지 않거나) 보이는 것을 보장합니다.Java의 컬렉션 프레임워크에서도 이 원칙이 적용됩니다. 예를 들어, List 인터페이스의 addAll 메소드는 모든 요소가 성공적으로 추가되거나, 예외가 발생한 경우 원래의 상태로 되돌립니다. 즉, 일부만 추가되고 실패하는 상황을 허용하지 않습니다. 이것이 바로 실패 원자성입니다.  
        
    - **불변 클래스는 값이 다르면 반드시 독립된 객체로 만들어야하는 단점이 있다**
        - 예시
    - 원하는 객체를 완성하기까지 단계가 많고, 그 중간 단계에서 만들어진 객체를 버려짐
        - 해결 방법
            - 다단계 연산(multistep operation)을 예측해 기본 기능으로 제공하는 방법 ⇒ 각 단계마다 객체를 생성하지 않아도 되기 때문
    - 불변 클래스를 만드는 또 다른 설계 방법
        - 모든 생성자를 private 혹은 package-private로 만들고 public 정적 팩터리를 제공하는 방법 - 사실상 이 불변 객체는 final
            
            ```Java
            public class Complex {
            	private final double re;
            	private final double im;
            
            	private Complex(double re, double im) {
            		this.re = re;
            		this.im = im;
            	}
            	public static Complex valueOf(double re, double im) {
            		return new Complex(re,im);
            	}
            
            	... // 나머지 코드는 생략
            }
            ```
            
    - BigInteger, BigDecimal → 신뢰할 수 없는 클라이언트로부터 이 두 인스턴스를 인수로 받는다면 주의 필요 ⇒ **이 인수들을 가변이라 가정하고 방어적으로 복사해 사용**
        
        ```Java
        public static BigInteger safeInstance(BigInteger val) {
        	return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray());
        }
        ```
        
    - 직렬화 시 추가 주의점
        - Serializable을 구현하는 불변 클래스의 내부에 가변 객체를 참조하는 필드가 있다면 readObject나 readResolve 메서드를 반드시 제공하거나, ObjectOutputStream.writeUnshared와 ObjectInputStream.readUnshared 메서드를 사용해야 한다
        - 플롯폼이 제공하는 기본 직렬화 방법이면 충분하더라도 그래야한다. 그렇지 않으면 공격자가 이 클래스로부터 가변 인스턴스를 만들어낼 수 있다
    - **클래스는 꼭 필요한 경우가 아니라면 불변이어야한다 ⇒ getter가 있다고 해서 setter룰 무조건 만들지 말자 ⇒ PhoneNumber와 Complex 같은 단순한 값 객체는 항상 불변으로 만들자**
    - **String & BigInteger처럼 무거운 값 객체도 불변으로 만들 수 있는지 고심해야 한다 → 성능 때문에 어쩔 수 없다면 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하자**
    - **불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자**
    - 객체가 가질 수 있는 상태의 수를 줄이면 그 객체를 예측하기 쉬워지고 오류 발생 가능성이 줄어듦으로 꼭 변경해야 할 필드를 뺀 나머지 모두를 final로 선언하자 ⇒ **다른 합당한 이유가 없다면 모든 필드는 private final이어야한다**
    - **생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야한다 ⇒ 확실한 이유가 없다면 생성자와 정적 팩터리 외에는 어떤 초기화 메서드도 public으로 제공해서는 안된다**
        - 예시 - java.util.concurrent 패키지의 CountDownLatch
### 아이템 18. 상속보다는 컴포지션을 사용하라

- 상속의 문제
    - 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다
    - 상위 클래스의 구현에 따라 하위 클래스의 동작에 이상이 생길 수 있다
    - 상위 클래스에 새로운 메서드를 추가한 경우
        - 하위 클래스에 추가한 메서드와 시그니처가 같고 반환 타입은 다른 경우 컴파일이 되지 않음
        - 반환 타입마저 같다면 상위 클래스의 새 매서드를 재정의한 것과 동일
    - 예시
        
        ```Java
        public class InstrumentedHashSet<E> extends HashSet<E> {
        	// 추가된 원소의 수
        	private int addCount = 0;
        	
        	public InstrumentedHashSet(){}
        
        	public InstrumentedHashSet(int initCap, float loadFactor) {
        		super(initCap, loadFactor);
        	}
        	@Override
        	public boolean add(E e) {
        		addCount++;
        		return super.add(e);
        	}
        	@Override
        	public boolean addAll(Collection<? extens E> c) {
        		addCount += c.size();
        		return super.addAll(c);
        	}
        	public int getAddCount(){
        		return addCount;
        	}
        
        	// 이 클래스를 상속받아 다른 클래스에서 addAll에 원소 3개 추가
        	InstrumentedHashSet<String> s = new InstrumentedHashSet();
        	s.addAll(List.of("틱", "틱틱", "펑"));
        	// 6을 return -> HashSet의 addAll은 각 원소를 add 메서드를 호출해 추가(InstrumentedHashSet의 add) 
        //=> addCount에 값이 중복해서 더해짐 -> 값이 6
        	System.out.println(getAddcount());
        }
        ```
        
    - 좋은 해결 방법
        - 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하도록 하는 것 ⇒ 컴포지션
- 컴포지션
    - 정의 : 기존 클래스가 새로운 클래스의 구성요소로 쓰이도록 설계하는 방법
    - 새 클래스의 인스턴스 메서드들은(private 필드로 참조하는) 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환 → forwarding(전달), forwarding method(새 클래스의 메서드들)
    - 이를 통해 새로운 클래스는 기존 클래스의 내부 구현 방식의 영향에서 벗어나고, 기존 클래스에 새로운 메서드가 추가되더라도 영향이 X
        - 예시 - wrapper class - 상속 대신 컴포지션 사용
            
            ```Java
            // Decorator pattern 
            public class InstrumentedHashSet<E> extends ForwardingSet<E> {
            	private int addCount = 0;
            	
            	public InstrumentedHashSet(){
            		super(s);
            	}
            	@Override
            	public boolean add(E e) {
            		addCount++;
            		return super.add(e);
            	}
            	@Override
            	public boolean addAll(Collection<? extens E> c) {
            		addCount += c.size();
            		return super.addAll(c);
            	}
            
            	public int getAddCount() {
            		return addCount;
            	}
            }
            ```
            
        - 재사용할 수 있는 전달 클래스    
            ```Java
            public class ForwardingSet<E> implements Set<E> {
            	private final Set<E> s;
            	// 임의의 Set에 계측 기능을 덧씌워 새로운 Set을 생성
            	public ForwardingSet(Set<E> s) {this.s = s;}
            
            	public void clear() {s.clear();}
            	public boolean contains(Object o) { return s.contains(o); }
            	public boolean isEmpty() { return s.isEmpty(); }
            	public int size() { return s.size(); }
            	public Iterator<E> iterator() { return s.iterator(); }
            	public boolean add(E e) { return s.add(e); }
            	public boolean remove(Object o) { return s.remove(o); }
            	public boolean containsAll(Collection<?> c) { return s.containsAll(c); }
            	public boolean addAll(Collection<? extends E> c) { return s.addAll(c); }
            	public boolean removeAll(Collection<?> c) { return s.removeAll(c); }
            	public boolean retainAll(Collection<?> c) { return s.retainAll(c); }
            	public Object[] toArray() { return s.toArray() ; }
            	public <T> T[] toArray(T[] a) { return s.toArray(a); }
            	@Override
            	public boolean equals(Object o) {return s.equals(o); }
            
            	@Override
            	public int hashCode() {return s.hashCode(); }
            
            	@Override
            	public String toString() { return s.toString(); }
            }
            ```
            
            - 상속 방식은 구체 클래스 각각을 따로 확장
            - 지원하고 싶은 상위 클래스의 생성자 각각에 대응하는 생성자를 별도로 정의 필요
            - 전달 메서드가 성능에 주는 영향, 래퍼 객체가 메모리 사용량에 주는 영향은 별로 없음
            - 전달 메서드들을 작성하는 것은 지루하지만 재사용할 수 있는 전달 클래스를 인터페이스당 하나씩만 만들어두면 원하는 기능을 덧씌우는 전달 클래스를 아주 쉽게 구현 ex) Guava
        - wrapper 클래스의 단점
            - wrapper class가 callback 프레임워크와 어울리지 않는다
            - 콜백 프레임워크에서는 자기 자신의 참조를 다른 객체에 넘겨 다음 콜백 때 사용하도록 함
            - 내부 객체는 자신을 감싸고 있는 래퍼의 존재를 모르니 대신 this의 참조를 넘기고, 콜백 때는 wrapper가 아닌 내부 객체를 호출 ⇒ ==**SELF 문제**==
        - 전
- 컴포지션 OR 상속
    - 컴포지션 대신에 상속
        - 하위 클래스가 상위 클래스의 “진짜” 하위 타입인 상황에서만 써야한다
        - class B가 class A와 is-a 관계일 때만 클래스 A를 상속해야 한다
        - 진짜 하위타입이 아니라면 A를 private 인스턴스로 두고, A와는 다른 API를 제공해야한다
        - 예시 → 상속 대신 컴포지션을 사용했어야 하는 경우
            - Stack을 사용한 Vector
            - Properties를 사용한 HashTable
        - 컴포티션을 써야할 상황에 상속을 사용 시 문제
            - 내부 구현이 불필요하게 노출 ⇒ 내부 구현이 묶이고 그 클래스의 성능도 영원히 제한된다 &
            - 클라이언트가 노출된 내부에 직접 접근도 가능해짐
                - Properties의 인스턴스인 p가 있을 때, p.getProperty(key)와 p.get(key)의 결과가 상이
                - 전자는 Properties의 기본 동작, 후자는 Properties의 상위 클래스인 HashTable에서 물려받은 메서드이기 때문
            - 클라이언트에서 상위 클래스를 직접 수정해 하위 클래스의 불변식을 해칠 수 있음
                - Properties는 key, value로 문자열만 허용
                - HashTable의 메서드를 직접 호출 시 이 불변식을 해칠 수 있음
                - 불변식이 깨지면 load, store 같은 Properties API 사용 불가
    - 컴포지션 대신에 상속 결정 시에 해야하는 질문
        - 확장하려는 클래스의 API에 아무런 결함이 없는가
        - 결함이 있다면, 이 결함이 당신의 클래스의 API까지 전파돼도 괜찮은가
- 핵심정리
    - 상속은 강력하지만 캡슐화를 해친다는 문제가 있다. 상속은 상위 클래스-하위 클래스가 순수한 is-a 관계일 때만 써야한다
    - is-a 관계이더라도 하위 클래스의 패키지가 상위 클래스와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제일 수 있다
    - 상속의 취약점을 피하려면 상속 대신 컴포지션과 전달을 사용하자. 특히 wrapper 클래스로 구현할 적당한 인터페이스가 있다면 더욱 그렇다. wrapper 클래스는 하위 클래스보다 견고하고 강력하다

### 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
> [!info]  
> 재정의 가능 : public, protected 메서드 중 final이 아닌 모든 메서드  
- 상속을 고려한 설계와 문서화
    - 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야한다
    - 어떤 순서로 호출하는지, 각각의 호출 결과가 이어지는 처리에 어떤 영향을 주는지 문서에 남겨야한다
    - 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야한다
        - 백그라운드 스레드, 정적 초기화 과정 등
    - 적용 방법
        - api 문서 중 Implementation Requirements로 시작 → 메서드의 내부 동작 방식 설명
        - 이 절은 메서드 주석에 @implSpec 태그 → 자바독 도구 생성
        - @implSpec 활성화하려면 명령줄 매개변수로 -tag “implSpec:a:Implementaion Requirements:”를 지정
    - 예시 - java.util.AbstractCollection
        
        > public boolean remove(Object o)  
        > 주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거한다(선택적 동작). 더 정확하게 말하면, 이 컬렉션 안에 ‘Object.equals(o, e)가 참인 원소 e가 하나 이상 있다면 그 중 하나를 제거한다. 주어진 원소가 컬렉션 안에 있었다면(즉, 호출 결과 이 컬렉션이 변경됐다면) true를 반환한다.  
        > Implementation Requirements : 이 메서드는 컬렉션을 순회하며 주어진 우너소를 찾도록 구현되었다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거한다. 이 컬렉션이 주어진 객체를 갖고 있으나, 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면 UnsupportedOperationException을 던지니 주의하자.  
        
        - iterator 재정의 시 remove의 동작에 영향이 발생
        - 좋은 API 문서란 ‘어떻게’가 아닌 ‘무엇’을 하는지를 설명해야 한다는 격언과 대치 ⇒ 상속이 캡슐화를 해치기 때문
    - 클래스의 내부 동작 과정 중간에 끼어들 수 있는 hook을 잘 선별해 protected 메서드 형태로 공개해야할 수도 있다
    - 예시 - java.util.AbstractList의 removeRange
        
        > protected void removeRange(int fromIndex, int toIndex)  
        > fromIndex(포함)부터 toIndex(미포함)까지의 모든 원소를 이 리스트에서 제거한다. toIndex 이후의 원소들은 앞으로 (index만큼씩) 당겨진다. 이 호출로 리스트는 ‘toIndex - fromIndex’만큼 짧아진다( toIndex == fromIndex라면 아무런 효과가 없다.)  
        > 이 리스트 혹은 이 리스트의 부분 리스트에 정의된 clear 연산이 이 메서드를 호출한다. 리스트 구현의 내부 구조를 활용하도록 이 메서드를 재정의하면 이 리스트와 부분리스트의 clear 연산 성능을 크게 개선할 수 있다.  
        > Implementation Requirements : 이 메서드는 fromIndex에서 시작하는 리스트 반복자를 얻어 모든 원소를 제거할 때까지 ListIterator.next와 ListIterator.remove를 반복 호출하도록 구현되었다. 주의 : ListIterator.remove가 선형 시간이 걸리면 이 구현의 성능은 제곱에 비례한다.  
        > Parameters:  
        > fromIndex : 제거할 첫 원소의 인덱스  
        > toIndex : 제거할 마지막 원소의 다음 인덱스  
        
        - 하위 클래스에서 부분리스트의 clear 메서드를 고성능으로 만들기 쉽게하기 위해서 → removeRange 메서드가 없다면 하위 클래스에서 clear 메서드를 호출하면 제거할 원소 수의 제곱에 비례해 성능이 느려지거나 부분리스트의 메커니즘을 밑바닥부터 새로 구현해야 했을 것
    - 상속용 클래스 설계 시 어떤 메서드를 protected로 노출해야할까? → 실제 하위 클래스를 만들어 시험해보는 것이 최선
    - 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 **유일하다**
        - 꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성 시 드러난다
        - 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private 이었어야 할 가능성이 큼
        - 검증 시 하위 클래스 3개 정도가 적당 + 그 중 하나는 제3자가 작성
    - **상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야한다**
    - **상속하려는 사람을 위해 덧붙인 설명은 단순히 그 클래스의 인스턴스만 만들어 사용할 프로그래머에게는 군더더기 일뿐**
    - **상속용 클래스의 생성자는 직접적이든 간접적이든 재정의 기능 메서드를 호출해서는 안된다.**
        
        - 이 규칙을 어기면 오작동이 일어날 수 있음 ⇒ 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출 ⇒ 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도대로 동작 X
        - 예시
        
        ```Java
        public class Super {
        	// 잘못된 예 - 생성자가 재정의 기능 메서드를 호출한다.
        	public Super() {
        		overrideMe();
        	}
        	public void overrideMe(){}
        }
        ```
        
        ```Java
        public final class Sub extends Super {
        	// 초기화되지 않은 final 필드, 생성자에서 초기화한다.
        	private final Instant instant;
        	Sub(){
        		instant = Instant.now();
        	}
        
        	// 재정의 가능 메서드, 상위 클래스의 생성자가 호출한다.
        	@Override
        	public void overrideMe() {
        		System.out.println(instant);
        	}
        
        	public static void main(String[] args) {
        		Sub sub = new Sub();
        		sub.overrideMe();
        	}
        }
        ```
        
        - 문제점 해석
            
            이 코드의 주요 문제는 하위 클래스 (`**Sub**`)의 생성자가 완료되기 전에 `**this**`를 사용하고 있어 문제가 발생할 수 있다는 것입니다. `**overrideMe()**` 메서드는 `**Sub**` 클래스에서 재정의되며, `**Super**` 생성자가 실행되는 시점에 아직 초기화되지 않은 `**instant**`를 호출하고 있습니다. 이로 인해 `**Super**` 생성자에서 `**Sub**`의 `**overrideMe**` 메서드를 호출하면 `**NullPointerException**`이 발생합니다.
            
            다음은 그 과정입니다:
            
            1. `**main**` 메서드에서 새로운 `**Sub**` 객체를 생성하면, `**Sub**`가 `**Super**`의 하위 클래스이므로 먼저 `**Super**` 생성자가 호출됩니다.
            2. `**Super**` 생성자에서 `**overrideMe()**`를 호출합니다. 이 메서드는 `**Sub**`에서 재정의되므로, 실제로는 `**Sub**`의 `**overrideMe()**` 메서드가 호출됩니다.
            3. 그러나, `**Sub**`의 생성자가 아직 실행되지 않아 `**instant**`가 초기화되지 않았습니다. 따라서 `**Sub**`의 `**overrideMe()**` 메서드가 `**instant**`를 출력하려고 하면, `**instant**`가 아직 `**null**`인 상태이므로 `**NullPointerException**`이 발생합니다.
            4. `**Super**` 생성자가 완료된 후에 `**Sub**` 생성자는 `**instant**`를 초기화하지만, 이미 `**NullPointerException**`이 발생한 후이므로 너무 늦습니다.
            
            이는 생성자 (`**Super**` 생성자) 내에서 오버라이딩 가능한 메서드를 호출하는 것과 관련된 설계 문제로, 하위 클래스가 아직 올바른 상태가 아닐 수 있으므로 일반적으로 권장되지 않습니다.
            
    - Cloneable & Serializable
        - 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계 하는것 → 별로 좋지 않음
        - clone & readObject 직접적이든 간접적이든 재정의 가능 메서드를 호출해서는 안된다
            - clone & readObject 메서드는 생성자와 비슷한 효과를 낸다 ⇒ Cloneable & Serializable에서도 생성자와 비슷한 제약사항이 있음
        - readObject의 경우 하위 클래스의 상태가 미처 다 역직렬화되기 전에 재정의한 메서드부터 호출
        - clone의 경우 하위 클래스의 clone 메서드가 복제본의 상태를 올바른 상태로 수정하기 전에 재정의한 메서드를 호출
        - clone은 원본 객체에 피해를 줄 수 있음 → 재정의한 메서드가 원본 객체의 깊숙한 내부 자료구조까지 완전 복사했다고 가정하고 복제본을 수정 시 완전복사 하지 못한 복제본에서 원본 객체의 데이터를 참조할 경우 원본 객체도 문제가 발생함
        - Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메서드를 갖는다면 이 메서드들은 private가 아닌 protected로 선언 - private으로 선언하면 하위 클래스에서 무시하기 때문
    - 클래스를 상속용으로 설계하려면 엄청난 노력이 들고 그 클래스에 안기는 제약이 상당하다
    - **상속용으로 설계하지 않은 클래스는 상속을 금지하라**
        - 방법
            1. 클래스를 final로 선언하는 방법
            2. 모든 생성자를 private나 package-private으로 선언하고 public 정적 팩터리를 만들어주기
    - 구체 클래스가 표준 인터페이스를 구현하지 않고 상속을 허용해야할 때의 방법
        - 클래스 내부에서 재정의 가능 메서드를 사용하지 않게 만들고 이 사실을 문서화 → 상속해도 위험하지 않은 클래스를 만들 수 있음 ⇒ 메서드를 재정의해도 다른 메서드의 동작에 아무런 영향을 주지 않기 때문
- 핵심정리
    - 상속용 클래스를 설계하기란 결코 만만치 않다. 클래스 내부에서 스스로 어떻게 사용하는지(자가사용 패턴) 모두 문서로 남겨야 하며, 일단 문서화한 것은 그 클래스가 쓰이는 한 반드시 지켜야 한다. 그렇지 않으면 그 내부 구현 방식을 믿고 활용하던 하위 클래스를 오동작하게 만들 수 있다
    - 다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않다면 상속을 금지하는 편이 낫다.
    - 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다

### 아이템 20. 추상 클래스보다는 인터페이스를 우선하라

- 인터페이스
    - 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다
    - 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다
        - mixin
            - 클래스가 구현할 수 있는 타입
            - 믹스인을 구현한 클래스에 원래의 ‘주된 타입’ 외에도 특정 선택적 행위를 제공한다고 선언하는 효과
                - Comparable은 자신이 구현한 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스
            - 대상 타입의 주된 기능에 선택적 기능을 혼합
            - 추상 클래스로는 믹스인을 정의할 수 없음 → 기존 클래스에 덧씌울 수 없기 때문
    - 인터페이스로는 계층구조가 없는 타입 프레임워크를 만들 수 있다
        - 타입을 계층적으로 정의하면 수많은 개념을 구조적으로 잘 표현 가능
    - 계층을 엄격하게 구분하기 어려운 개념도 있음
        - 예시
            
            ```Java
            public interface Singer {
            	AudioClip sing(Song s);
            }
            
            public interface Songwriter {
            	Song compose(int chartPosition);
            }
            // Singer & Songwriter 모두 확장하고 새로운 메서드까지 추가한 제3의 인터페이스 정의 가능
            public interface SingerSongwirter extends Singer, Songwriter {
            	AudioClip strum();
            	void actSensitiver();
            }
            ```
            
    - ==조합 폭발(combinatiorial explosion)==
        - ==속성이 n개라면 지원해야 할 조합수 2의 n승==
    - wrapper 클래스 관용구와 함께 사용하면 인터페이스는 기능을 향상시키는 안전하고 강력한 수단이 됨
    - 타입을 추상 클래스로 정의하면 타입에 기능을 추가하는 방법은 상속 → wrapper 클래스보다 활용도가 떨어지고 깨지기 쉬움
    - 인터페이스의 메서드 구현 방법 → 디폴트 메서드로 제공
        - 디폴트 메서드를 제공할 때는 상속하려는 사람을 위한 설명을 @implSpec 자바독 태그를 붙여 문서화
        - 디폴트 메서드의 제약
            - equals, hashCode 같은 Object 메서드를 정의하고 있지만, 이들을 디폴트 메서드로 제공하면 안된다
            - 인터페이스는 인스턴스 필드를 가질 수 없고, public이 아닌 정적 멤버도 가질 수 없다(private 정적 메서드 예외)
            - 인터페이스에는 디폴트 메서드를 추가할 수 없음
    - 인터페이스와 추상 골격 구현(skeletal implementation) 클래스를 함께 제공 - **템플릿 메서드 패턴**
        - 인터페이스와 추상 클래스의 장점 취하는 방법
        - 인터페이스로 타입 정의, 필요하면 디폴트 메서드 몇 개 추가 제공
        - 골격 구현 클래스는 나머지 메서드들 구현
        - 단순히 골격 구현 확장만으로 인터페이스를 구현하는 데 필요한 일이 대부분 완료
        - 골격 구현 인터페이스 이름 예시
            - AbstractInterface
            - 컬렉션 프레임워크의 AbstractCollection, AbstractSet, AbstractList, AbstractMap
        - 골격 구현을 사용해 완성한 구체 클래스
            
            ```Java
            static List<Integer> intArrayAsList(int[] a) {
            	Objects.requireNonnull(a);
            	
            	// 다이아몬드 연산자를 이렇게 사용하는 건 자바 9부터 가능하다.
            	// 더 낮은 버전을 사용한다면 <Integer>로 수정하자
            	// 익명 클래스로 구현
            	return new AbstractList<>() {
            		@Override
            		public Integer get(int i) {
            			return a[i]; 
            		}
            
            		@Override
            		public Integer set(int i,Integer val) {
            			int oldVal = a[i]; 
            			a[i] = val;
            			return oldVal;
            		}
            
            		@Override
            		public int size() {
            			return a.length;
            		}
            	}
            }
            ```
            
        - 추상 클래스처럼 구현을 도와주는 동시에, 추상 클래스로 타입을 정의할 때 따라오는 심각한 제약에서 자유로움
        - 골격 구현 클래스의 우회적 사용 - 다중 상속(simulated multiple inheritance)
            - 인터페이스를 구현한 클래스에서 해당 골격 구현을 확장한 private 내부 클래스를 정의하고, 각 메서드 호출을 내부 클래스의 인스턴스에 전달
            - **==예시==**
    - 골격 구현 작성 순서
        
        1. 인터페이스를 잘 살펴 다른 메서드들의 구현에 사용되는 기반 메서드들을 선정 → 선택된 메서드는 골격 구현에서 추상 메서드로 구현
        2. 기반 메서드들을 사용해 직접 구현할 수 있는 메서드를 모두 디폴트 메서드로 제공. 단, equals와 hashCode 같은 Object 의 메서드는 디폴트 메서드로 제공X
            1. 인터페이스의 메서드 모두가 기반 메서드와 디폴트 메서드가 된다면 골격 구현 클래스를 별도로 만들 이유 X
        
        - 골격 구현 클래스
            
            ```Java
            // Map.Entry 인터페이스나 그 하위 인터페이스로는 이 골격 구현을 제공할 수 없다
            public abstract class AbstractMapEntry<K, V> implements Map.Entry<K,V> {
            	// 변경 가능한 엔트르는 이 메서드를 반드시 재정의해야 한다
            	@Override
            	public V setValue(V value) {
            		throw new UnsupoortedOperationException();
            	}
            
            	@Override
            	public boolean equals(Object o) {
            		if (o == this) {
            			return true;
            		}
            		if (!(o instanceof Map.Entry)) {
            			return false;
            		}
            		Map.Entry<?,?> e = (Map.Entry) o;
            		return Objects.equals(e.getKey(), getKey()) && Objects.equals(e.getValue(), getValue()); 
            	}
            
            	// Map.Entry.hashCode의 일반 규약을 구현
            	@Override
            	public int hashCode() {
            		return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue())  
            	}
            	@Override
            	public String toString() {
            		return getKey() + "=" + getValue();
            	}	
            }
            ```
            
    - 단순 구현(simple implementation)은 골격 구현의 작은 변종
        - 동작하는 가장 단순한 구현
        - ==Abstract Map.SimpleEntry==
- 핵심 정리
    - 일반적으로 다중 구현용 타입으로는 인터페이스가 가장 적합하다.
    - 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법을 꼭 고려해보자
    - 골격 구현은 ‘가능한 한’ 인터페이스의 디폴트 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다.‘가능한 한’이라고 한 이유는, 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문이다.

### 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

- 디폴트 메서드의 문제
    - 디폴트 메서드 선언 → 인터페이스를 구현 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 사용됨
    - 자바 8에서 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가 되었음 → 람다 호라용을 위해서
    - **생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기는 어렵다**
    - 자바 8의 Collection 인터페이스에 추가된 디폴트 메서드
        
        ```Java
        default boolean removeIf(Predicate<? super E> filter) {
        	Objects.requireNonNull(filter);
        	boolean result = false;
        	for (Iterator<E> it = iterator(); it.hasNext(); ) {
        		if (filter.test(it.next())) {
        			it.remove();
        			result = true;
        		}
        	}
        	return result;
        }
        ```
        
        - 모든 Collection 구현체와 잘 어울리지 않음의 예시
            - org.apache.commons.collections4.collections.SynchronizedCollection - java.util의 Collections.synchroizedCollection의 정적 팩터리 메서드가 반환하는 클래스와 유사
            - 아파치 버전은 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공 → 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 wrapper 클래스
            - 현 시점에서 SynchronizedCollection 클래스는 removeIf 메서드를 재정의하지 않고 있음 → 모든 메서드 호출을 알아서 동기화해주지 않음
            - SynchronizedCollection 인스턴스를 여러 스레드가 공유하는 환경에서 한 스레드가 removeIf 호출 시 ConcurrentModificationException 발생 or 다른 문제 발생
            - 구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업 수행을 강제
                - 예시 - Collections.synchroizedCollection
                - Collections.synchroizedCollection에서 반환하는 package-private 클래스는 removeIf 재정의 & 다른 메서드들은 디폴트 구현을 호출하기 전 동기화하도록 강제
    - 디폴트 메서드는 컴파일이 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다
        - 흔한 일은 아니지만, 일어나지 않으리라는 보장은 없다
        - 자바 8에서 컬렉션 인터페이스에 꽤 많은 디폴트 메서드를 추가 → 기존 자바 코드에 영향이 있음
        - **기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니라면 피해야한다**
        - 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는 데 유용한 수단 & 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해준다
    - **디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도는 아니다**
    - **디폴트 메서드라는 도구가 생겼더라도 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야한다**
    - 새로운 인터페이스라면 릴리스 전에 반드시 테스트를 거쳐야한다.
        - 서로 다른 방식으로 최소한 세 가지는 구현해볼 것
        - 각 인터페이스의 인스턴스를 다양한 작업에 활용하는 클라이언트도 여러 개 생성해볼 것
    - **인터페이스를 릴리스한 후라도 결함을 수정하는 게 가능한 겨우도 있겠지만 절대 그 가능성에 기대서는 안된다**

### 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라

- 인터페이스의 사용
    - 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할 ⇒ 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 것 ⇒ **인터페이스는 오직 이 용도로만 사용해야한다**
    - 상수 인터페이스 안티패턴 - 사용금지!
        
        ```Java
        public interface PyhsycalConstants {
        	static final double AVOGADROS_NUM = 6.022_140_857e23;
        	static final double BOLTZMANN_NUM = 1.380_648_52e-23;
        		static final double ELECTRON_MASS = 9.109_383_56-e31;
        }
        ```
        
        - **상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예!**
            - 상수는 외부 인터페이스가 아니라 내부 구현에 해당하기 때문 ⇒ 이는 내부 구현을 클래스의 API로 노출하는 행위
            - 이는 사용자에게 의미가 없고, 사용자에게 혼란을 주며, 클라이언트 코드가 내부 구현에 해당하는 이 상수들에 종속되게 한다
            - 예시 - java.io.ObjectStreamConstants 등
    - 상수 공개 목적 시 사용할 수 있는 선택지
        - **특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야한다**
        - 예시 : Interger & Double의 MIN_VALUE,MAX_VALUE
        - 상수 유틸리티 클래스
            
            ```Java
            package effectivejava.chapter4.item22.constantutilityclass;
            
            public class PhysicalConstants {
            	private PhysicalConstants() {} // 인스턴스화 방지
            	
            	// 부동소수점이 5자리 이상일 경우 세 자리씩 묶어 (_)를 기입해주는 것이 좋다
            	public static final double AVOGADROS_NUM = 6.022_140_857e23;
            	public static final double BOLTZMANN_NUM = 1.380_648_52e-23;
            	public static final double ELECTRON_MASS = 9.109_383_56-e31;
            }
            ```
            
        - **정적 임포트(static import) - 유틸리티 클래스의 상수가 빈번히 사용된다면**
            
            - 예시
            
            ```Java
            import static effectivejava.chapter4.item22.constantutilityclass.PhysicalConstants .*;
            
            public class Test {
            	double atoms(double mols) {
            		return AVOGADROS_NUMBER * mols;
            	}
            }
            ```
            
- 핵심 정리
    - 인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하지 말자

### 아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

- 태그 달린 클래스
    - 두 가지 이상의 의미를 표현 가능, 그 중 현재 표현하는 의미를 태그 값으로 알려주는 클래스
    - **태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적이다**
    - 예시 - 태그 달린 클래스 - 클래스 계층구조보다 훨씬 나쁘다
        
        ```Java
        class Figure {
        	enum Shape { RECTANGLE, CIRCLE };
        	
        	// 태그 필드 - 현재 모양을 나타낸다
        	final Shape shape;
        
        	double length;
        	double width;
        	double radius;
        
        	Figure(double radius) {
        		shape = Shape.CIRCLE;
        		this.radius = radius;
        	}
        
        	Figure(double length, double width) {
        		shape = Shape.RECTANGLE;
        		this.length = length;
        		this.width= width;
        	}
        
        	double area() {
        			switch(shape){
        				case RECTANGLE:
        					return length * length;
        				case CIRCLE:
        					return Math.PI * (radius * radius);
        				default:
        					 throw new AssertionError(shape);
        			}
        	}
        }
        ```
        
    - 단점
        - enum type, 태그 필드 , switch 문 등 쓸데없는 코드가 많음
        - 여러 구현이 한 클래스에 혼합 → 가독성이 좋지 않음
        - 코드도 언제나 함께 하니 메모리도 많이 사용
        - 필드들을 final로 선언하려면 해당 의미에 쓰이지 않는 필드들까지 생성자에서 초기화해야함
        - 엉뚱한 필드를 초기화해도 런타임에 문제가 발생함 → 코드 수정이 필요함
            - 위의 코드에선 switch에 새 의미를 처리하는 코드를 추가해야함 → 하나라도 빠지면 런타임에 문제가 발생함
        - 인스턴스의 타입만으로는 현재 나타내는 의미를 알 길이 없다
    - **태그 달린 클래스는 클래스 계층구조를 어설프게 흉내낸 아류일 뿐이다**
- 서브타이핑(subtyping)
    - 클래스 계층구조를 활용
    - 태그 달린 클래스를 클래스 계층구조로 바꾸는 방법
        - 계층구조의 root가 될 추상 클래스 정의
        - 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언
        - 태그 값에 상관없이 동작이 일정한 메서드들을 루트 클래스에 일반 메서드로 추가
        - 모든 하위 클래스에서 공통으로 사용하는 데이터 필드들도 전부 루트 클래스로 올림
        - 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의
        - 루트 클래스가 정의한 추상 메서드를 각자의 의미에 맞게 구현
    - 예시 - 태그 달린 클래스를 클래스 계층구조로 변환
        
        - setter 메서드 없이 필드 노출 → 단순 예제코드 → 실 사용은 설계 X
        
        ```Java
        abstract class Figure {
        	abstract double area();
        }
        
        class Circle extends Figure {
        	final double radius;
        
        	Circle(double radius) {this.radius = radius; }
        
        	@Override
        	double area() { Math.PI * (radius * radius); } 
        }
        
        class Rectangle extends Figure {
        	final double length;
        	final double width;
        
        	Rectangle(double length, double width) {
        		this.length = length;
        		this.width = width;
        	}
        
        	@Override
        	double area() { length * width; } 
        }
        ```
        
        - 쓸데 없는 코드 없음
        - 각 의미를 독립된 클래스에 담아 관련 없던 데이터 필드 모두 제거 - final로 필드 선언
        - 각 클래스의 생성자가 모든 필드를 남김없이 초기화
        - 추상 메서드를 모두 구현했는지 컴파일러가 확인 - case문으로 인한 런타임 오류 X
        - 클래스를 독립적으로 확장 가능
        - 타입이 의미별로 존재해 변수의 의미를 명시하거나 제한 가능
        - 특정 의미만 매개변수로 받을 수 있음
        - 타입 사이의 자연스러운 계층 관계 반영 → 유연성, 컴파일타임 타입 검사 능력 향상
        - 확장 시 코드
        
        ```Java
        class Square extends Rectangle {
        	Square(double side) {
        		super(side,side);
        	}
        }
        ```
        
- 핵심정리
       - 태그 달린 클래스를 써야 하는 상황은 거의 없다
    - 새로운 클래스를 작성하는 데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각해보자
    - 기존 클래스가 태그 필드를 사용하고 있다면 계층구조로 리팩터링하는 걸 고려해보자

### 아이템 24. 멤버 클래스는 되도록 static으로 만들라

- 중첩 클래스
    - 다른 클래스 안에 정의된 클래스
    - 자신을 감싼 바깥 클래스에서만 쓰여야하며, 그 외의 쓰임새가 있다면 톱레벨 클래스로 만들어야한다
    - 바깥 클래스의 private 멤버에도 접근할 수 있다는 점을 제외하고 일반 클래스와 동일
    - 종류
        - 정적 멤버 클래스, (비정적) 멤버 클래스, 익명 클래스, 지역 클래스
        - 첫 번째를 제외한 나머지는 inner class
    - 정적 멤버 클래스
        - 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 사용
            
            ```Java
            public class OuterClass {
                private static String msg = "Hello, World!";
            
                // 정적 멤버 클래스
                public static class StaticNestedClass {
                    // Non-static method
                    public void printMessage() {
                        System.out.println("Message from static nested class: " + msg);
                    }
                }
            
                public static void main(String[] args) {
                    // Create instance of nested Static class
                    OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
                    nestedObject.printMessage();
                }
            }
            ```
            
    - 비정적 멤버 클래스
        - static이 없음
        - 바깥 클래스의 인스턴스와 암묵적으로 연결
        - 비정적 멤버 클래스의 인스턴스와 바깥 인스턴스 사이의 관계는 멤버 클래스가 인스턴스화 될 때 확립, 변경 불가
        - 예시
            
            - 'OuterClass'의 인스턴스를 사용하여 인스턴스화해야 하며 외부 클래스의 정적 및 비정적 멤버 모두에 액세스
            - 비정적 멤버 클래스의 인스턴스 메서드에서 정규화된 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조
            - 개념상 중첩 클래스의 인스턴스가 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야함 ⇒ 비정적 멤버 클래스는 바깥 인스턴스 없이는 생성할 수 없기 때문
            
            ```Java
            public class OuterClass {
                private String msg = "Hello, World!";
            
                // Inner class
                public class InnerClass {
                    public void printMessage() {
            						// 정규화된 this : OuterClass.this.msg - 바깥 클래스 이름을 명시하는 방법
                        System.out.println("Message from inner class: " + OuterClass.this.msg);
                    }
                }
            
                public static void main(String[] args) {
                    // Create instance of outer class
                    OuterClass outerObject = new OuterClass();
            
                    // Create instance of inner class
            				// 수동으로 생성 -> 관계 정보는 비정적 멤버 클래스의 인스턴스 안에 만들어져 
                    // 메모리 공간 점유 & 생성 시간 증가
                    OuterClass.InnerClass innerObject = outerObject.new InnerClass();
            
                    // Call method of inner class
                    innerObject.printMessage();
                }
            }
            ```
            
        - 어댑터 정의 시 자주 사용→ 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게하는 뷰로 사용
            
            - 예시
            
            ```Java
            public class MySet<E> extends AbstractSet<E> {
            	... // 생략
            	@Override
            	public Iterator<E> iterator() {
            		return new MyIterator();
            	}
            	
            	private class MyIterator implements Iterator<E>{
            		...
            	}
            }
            ```
            
        - 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만들자 → static 생략 시 바깥 인스턴스로의 숨은 외부 참조를 가짐 ⇒ 이 참조 저장 시 시간과 공간 소비 & GC가 바깥 클래스의 인스턴스를 수거하지 못함으로 메모리 누수 가능성이 있음
    - private 정적 멤버 클래스
        - 바깥 클래스가 표현하는 객체의 한 부분(구성요소)을 나타낼 때 사용
        - 예시
            - 많은 Map 구현체는 Entry 객체들을 가진다
            - 모든 엔트리가 맵과 관련 있음 , but 엔트리의 메서드들(getKey, getValue, setValue)은 맵을 직접 사용하지 않음
            - 엔트리를 비정적 멤버 클래스로 표현하는 것은 낭비 & private 정적 멤버 클래스가 가장 알맞음
            - 엔트리 선언 시 static을 빠뜨려도 맵은 동작하겠지만, 모든 엔트리가 바깥 맵으로의 참조를 갖게 되어 공간, 시간 낭비
    - 익명 클래스
        - 이름이 없고, 바깥 클래스의 멤버도 아님
        - 쓰이는 시점에 선언과 동시에 인스턴스가 만들어짐 → 제약이 많음
        - 코드의 어디서든 만들 수 있음
        - 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조 가능
        - 정먹 문맥에서라도 상수 변수 이외의 정적 멤버를 가질 수 없음 → final 기본 타입 & 문자열 필드만 가질 수 있음
        - instancof 검사나 클래스의 이름이 필요한 작업은 수행 X
        - 여러 인터페이스를 구현할 수 없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속 X
        - 익명 클래스를 사용하는 클라이언트는 그 익명 클래스가 상위 타입에서 상속한 멤버 외에는 호출 X
        - 익명 클래스는 표현식 중간에 등장하므로, 10줄 이하로 짧지 않으면 가독성이 떨어짐
        - 쓰임새
            - 람다 지원 전 즉석에서 작은 함수 객체나 처리 객체(process object)를 만드는데 주로 사용
                
                ```Java
                // Define a simple functional interface
                interface Greeting {
                    void sayHello(String name);
                }
                
                public class Main {
                    public static void main(String[] args) {
                        // Create an instance of the Greeting interface using an anonymous class
                        Greeting greeting = new Greeting() {
                            @Override
                            public void sayHello(String name) {
                                System.out.println("Hello, " + name + "!");
                            }
                        };
                
                        // Use the instance
                        greeting.sayHello("World");
                    }
                }
                ```
                
            - 정적 팩터리 메서드 구현 시
    - 지역 클래스
        - 지연변수를 선언할 수 있는 곳이면 실질적으로 어디서든 선언
        - 유효 범위도 지역변수와 동일
        - 이름이 있고 반복해서 사용 가능
        - 비정적 문맥에서 사용될 때만 바깥 인스턴스 참조 가능
        - 정적 멤버를 가질 수 없고 가독성을 위해 짧게 작성해야 한다
- 핵심 정리
    - 중첩 클래스에는 네 가지가 있고 각각의 쓰임새가 다르다
    - 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기 너무 길다면 멤버 클래스로 만든다
    - 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로, 그렇지 않으면 정적으로 만든다
    - 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 이미 있다면 익명 클래스로 만들고 , 그렇지 않으면 지역 클래스로 만들자

### 아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라

- 톱레벨 클래스
    - 소스 파일 하나에는 톱레벨 클래스(인터페이스)를 하나만 담자
    - 한 소스 파일에 여러 개의 톱레벨 클래스를 작성한 경우
        - 예시
            - main
                
                ```Java
                public class Main {
                	public static main(String[] args) {
                		//pancake
                		System.out.println(Utensil.NAME + Dessert.NAME); 
                	}
                }
                ```
                
            - 두 클래스가 한 파일에 정의 되었다1(**따라하지 말것)**
                
                ```Java
                class Utensil{
                	static final String NAME ="pan";
                }
                
                class Dessert {
                	static final String NAME ="cake";
                }
                ```
                
            - 두 클래스가 한 파일에 정의 되었다1(**따라하지 말것) - 우연히 만듦**
                
                ```Java
                class Utensil{
                	static final String NAME ="pot";
                }
                
                class Dessert {
                	static final String NAME ="pie";
                }
                ```
                
            - 동작
                - javac [Main.java](http://Main.java) [Dessert.java](http://Dessert.java) command 실행 시
                    - 컴파일 오류 & Utensil , Dessert 클래스 중복 정의를 알려줌
                    - 컴파일러는 [Main.java](http://Main.java) → 그 안의 Utensil 참조를 만나면 [Utensil.java](http://Utensil.java) 파일을 살펴 Utensil, Dessert 찾고 → 두 번째 command 상 [Dessert.java](http://Dessert.java) 처리 시 같은 클래스 정의가 있음을 알게 됨
                - javac [Main.java](http://Main.java) OR [Main.java](http://Main.java) [Utensil.java](http://Utensil.java) command 실행 시
                    - [Dessert.java](http://Dessert.java) 파일을 작성하기 전처럼 pancake 출력
                - javac [Dessert.java](http://Dessert.java) [Main.java](http://Main.java) command 실행 시
                    - potpie 출력
        - **컴파일러에 어느 소스 파일을 먼저 건네느냐에 따라 동작이 달라진다**
    - 해결방법
        
        - 톱레벨 클래스들을 서로 다른 소스 파일로 구분
        - 굳이 여러 톱레벨 클래스를 한 파일에 담고 싶다면 정적 멤버 클래스를 사용하는 방법을 고민
        - 톱레벨 클래스들을 정적 멤버 클래스로 바꿔본 모습
        
        ```Java
        public class Test {
        	public static main(String[] args) {
        		System.out.println(Utensil.NAME + Dessert.NAME); 
        	}
        
        	private static class Utensil {
        		static final String NAME ="pan";
        	}
        
        	private static class Dessert {
        		static final String NAME ="cake";
        	}
        }
        ```
        
          
        
- 핵심 정리
    - 소스 파일 하나에는 반드시 톱레벨 클래스( 혹은 톱레벨 인터페이스)를 하나만 담자
    - 이 규칙만 따른다면 컴파일러가 한 클래스에 대한 정의를 여러개 만들어내는 일은 사라진다.
    - 소스 파일을 어떤 순서로 컴파일하든 바이너리 파일이나 프로그램의 동작이 달라지는 일은 결코 일어나지 않을 것이다.