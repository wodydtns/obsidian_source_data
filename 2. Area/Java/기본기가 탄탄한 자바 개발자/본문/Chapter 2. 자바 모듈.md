2.1 배경 설명

- 모듈
    - 자바 9부터 도입된 자바 언어의 새로운 개념
    - 런타임에 의미를 가지는 응용 프로그램 배포 및 의존성의 단위
    - 모듈은 모듈 간의 의존성 정보를 정의하므로 컴파일 또는 애플리케이션 시작 시점에서 모든 종류의 해결과 연결 문제를 감지할 수 있다
    - 적절한 캡슐화를 제공해서 내부 패키지와 클래스를 조작하려는 사용자로부터 안전하게 보호할 수 있다
    - 최신 자바 런타임에서 이해하고 사용할 수 있는 메타데이터가 포함된 적절한 배포 단위임며, 자바 타입 시스템에서(예: 리플렉션을 통해) 표현된다
- 모듈 시스템의 목표는 배포 단위(모듈)를 가능한 한 서로 독립적으로 만드는 것
- 비록 실제 애플리케이션은 관련 기능을 제공하는 모듈의 그룹에 종속될 수 있지만, 모듈은 개별적으로 로드 및 링크될 수 있도록 설계

### 2.1.1 프로젝트 직소(project jigsaw)

- 프로젝트 직소
    - 모듈 기능을 제공하기 위한 OpenJDK 내 프로젝트
    - 목표
        - JDK 플랫폼 소스 모듈화하기
        - 프로세스 풋프린트 줄이기
        - 애플리케이션 시작 시간 개선하기
        - JDK와 애플리케이션 코드에서 모듈 사용할 수 있게 하기
        - 자바에서 처음으로 진정한 의미의 엄격한 캡슐화 허용
        - 이전에는 불가능했던 새로운 접근 제어 모드를 자바 언어에 추가하기
        - 단일 모놀리식 런타임 JAR(rt.jar) 끝내기
        - JDK 내부를 적절히 캡슐화해서 보호하기
        - 외부에 영향 없이 주요 내부의 변경 가능하게 하기
        - 모듈을 슈퍼 패키지로 도입하기
- 모놀리식이 아닌 모듈식 자바 런타임
    - 모듈의 새로운 형식
        - JMOD 형식
            - 기존 JAR와 유사
            - 별도의 공유 객체 파일이 아니라, 네이티브 코드를 단일 파일의 일부로 포함하는 형식
            - 대부분의 개발자의 경우 JMOD보다 모듈식 JAR로 패키징 하는것이 더 좋음
        - JIMAGE
            - 자바 런타임 이미지를 나타내는 데 사용
            - 모듈식 애플리케이션에는 프로그램 시작 전 의존성 집합을 정확히 알 수 있을만큼 메타데이터가 있어, 필요한 것만 로드하면 효율적이고 범용 자바의 전체 설치가 아닌 애플리케이션에 필요한 것만 포함된 사용자 정의 런타임 이미지만 정의할 수 있다
    - 내부의 캡슐화
        - 플랫폼 내부 변경에 큰 장애물은 자바8에 존재하는 접근 제어에 대한 자바의 접근 방식
            - public, private, protected, package-private만으로 접근 제어 수준을 정의하며, 이런 수정자는 클래스 레벨 이상에서만 적용
            - 리플렉션이나 관련 패키지에 추가 클래스 생성 등 다양한 방법으로 이러한 제한을 우회할 수 있고, 내부를 완벽하게 보호할 수 있는 완벽한 혹은 증명된 방법은 없다
        - 프로젝트 직소는 런타임 크기를 줄이고, 시작 시간을 개선하고, 내부 패키지 간의 의존성을 정리하는 등 여러 가지 문제를 한 번에 해결할 수 있는 방법
    - 모듈식 JVM
        - stack trace 형식이 자바 8에서 사용되던 형식에서 다소 변경된 것을 알 수 있다

### 2.1.2 모듈 그래프

- 모듈화의 핵심은 모듈이 서로 의존하는 방식을 나타내는 모듈 그래프
    - 모듈 그래프는 유향 비순환 그래프(directed acyclic graph, DAG)
    - 최신 자바 환경에서는 모든 애플리케이션이 모듈형 JRE 위에서 실행되므로 ‘모듈형 모드’와 ‘레거시 클래스 패스 모드’같은 것은 존재하지 않는다
- JDK 시스템 모듈
    
    ![[image 4.png]]
    

### 2.1.3 내부 보호하기

- 모듈이 해결해야 할 주요 문제 중 하나는 사용자 자바 프레임워크와 내부 구현의 세부 사항이 과도하게 결합되어 있다는 것
    - 실제로 코드를 내부 클래스에 직접 엑세스가 가능한데, 이는 해서는 안되는 것이다
    - 예 - 내부 클래스를 확장해 저수준 URL 정규화 도구(URL canonicalizer)에 엑세스
        
        ```Java
        import sun.net.URLCanonicalizer;
        
        public class MyURLHandler extends URLCanonicalizer {
        	public boolean isSimple(String url) {
        		return isSimpleHostName(url);	
        	}
        }
        ```
        

### 2.1.4 새로운 접근 제어에 대한 의미

- 모듈은 자바의 접근 제어 모델에 새로운 개념인 export 개념을 추가
- 샷건 프라이버시(shotgun privacy) - 모든 패키지의 공개 클래스에 있는 공개 메서드를 호출
    - 자바의 경우 큰 문제 → 점점 더 많은 라이브러리가 다른 방식으로 제공하기 어렵거나 불가능한 기능을 제공하기 위해 내부 API를 사용하고 있었고, 플랫폼의 장기적인 보안을 해칠 위험이 있음
- **모듈에선 자바 접근 제어 방식을 내보낸 패키지의 메서드에서만 액세스할 수 있도록 하고, 더 이상 공개 클래스의 공개 메서드가 모든 코드에 자동으로 표시되는 일이 없도록 한다**

## 2.2 기본적인 모듈 구문

- 자바 플랫폼 모듈
    - 각 모듈은 모듈 기술자(module descriptor)라고 하는 새로운 파일(module-info.java)을 선언해야함
    - 모듈 기술자에 포함되어야 하는 내용
        - 모듈 이름
        - 모듈 의존성
        - 공개 API(내보낸 패키지)
        - 리플렉션 액세스 권한
        - 제공되는 서비스
        - 소비되는 서비스
    - 모듈 기술자의 예시
        
        ```Java
        module wgjd.discovery {
        	exports wgjd.discovery;
        	
        	requires java.instrument;
        	requires jdk.attach;
        	requires jdk.internal.jvmstat;
        }
        ```
        

### 2.2.1 모듈 내보내기와 의존 모듈 선언하기

- export 키워드 예시
    
    ```Java
    export wgjd.discovery;
    ```
    
    - 모듈 설명자에서 여러 줄의 exports가 가능함
- 모듈 이름에 대한 기본 규칙과 관례
    - 모듈은 글로벌 네임스페이스에 있다
    - 모듈 이름은 고유해야 한다
    - 가능하면 표준적으로 com.company.project

### 2.2.2 전이성

- 모듈 시스템은 이 문제를 해결하기 위해 몇 가지 간단한 구문(requires transitive)을 제공
    - requires transitive를 사용하면, 모듈 A가 다른 모듈을 전이적으로 필요로 하는 경우, A에 종속된 모든 코드는 암시적으로 전이적 의존성도 함께 가져옴

## 2.3 모듈 로드하기

- JVM에는 모듀을 인식하는 클래스로더가 있고, JRE 클래스가 로드되는 방식이 자바 8과 상당히 다름
- 핵심 개념 중 하나는 모듈에 대한 일련의 경로인 module path
- 클래스 로딩에 대한 모듈식 접근 방식의 기본 원칙
    - 모듈은 과거 방식의 클래스 패스가 아닌 모듈 패스에서 해결
    - 시작 시 JVM은 비순환적이어야 하는 모듈 그래프를 확인한다
    - 하나의 모듈은 그래프의 루트이며 실행이 시작되는 곳이다. 여기에는 진입점이 될 메인 메서드가 있는 클래스를 포함한다
- 이미 모듈화된 의존성 → 애플리케이션 모듈

### 2.3.1 플랫폼 모듈

- —list-modules 플래스 → 사용 가능한 플랫폼 모듈의 목록 조회 가능
- 자격 제한 내보내기(qualified exporting)
    - 플랫폼 모듈이 일부 패키지를 지정된 모듈들에게만 내보내고 일반적으로 사용할 수 없도록 하는 것
- 수집자 모듈(aggregator module)
    - 어떤 코드도 가지지 않지만 바로 가기(shortcut) 메커니즘 제공
    - 애플리케이션이 매우 광범위한 의존성 집합을 일시적으로 가져올 수 있도록 하는 역할

### 2.3.2 애플리케이션 모듈

- 애플리케이션의 모듈화된 의존성 또는 애플리케이션 자체를 나타내는 모듈
- 라이브러리 모듈이라고도 불림
- 플랫폼 모듈과 애플리케이션 모듈 사이에는 기술적 차이가 없다

### 2.3.3 자동 모듈

- 자동 모듈
    - 모듈화되지 않은 JAR 파일을 모듈 패스로 옮기고 클래스 패스에서 제거하는 JAR
    - 자동 모듈은 포함된 모든 패키지를 내보내고 모듈 패스에 있는 다른 모든 모듈을 자동으로 의존성으로 추가
    - 자동 모듈은 모듈 시스템에서 일급 객체가 아니며, 진정한 자바 모듈과 동일한 수준의 보장을 제공하지 않음
    - JAR의 MANIFEST.MF 파일에 Automatic-Module-Name 항목을 추가해 이름을 명시적으로 선언
    - 예시 - Apache Commons Lang 라이브러리 → 완전히 모듈화되지 않았지만 자동 모듈 명으로 org.apache.commons.lang3을 제공

### 2.3.4 이름 없는 모듈

- 이름 없는 모듈
    - 클래스 패스에 있는 모든 클래스와 JAR가 단일 모듈로 추가 ⇒ 이름 없는 모듈
    - 이전 버전과의 호환성을 위해 수행되지만 일부 코드가 이름 없는 모듈에 항상 남아 있기 때문에 모듈 시스템의 효율성이 감소

## 2.4 첫 모듈형 앱 빌드하기

- 모듈 그래프
    - root module
        - 앱의 진입점 클래스
    - 애플리케이션의 모듈 그래프는 루트 모듈의 모든 모듈 의존서엥 대한 전이적 폐쇄
        - 전이적 폐쇄
            - 어떤 요소가 다른 요소를 참조하고, 그 다른 요소가 또 다른 요소를 참조하는 것과 같이 참조 관계에 따라 모든 연결된 요소를 포함하는 개념
            - 주어진 요소를 중심으로 그와 관련된 모든 요소를 포함해 완전한 세트를 형성

### 2.4.1 모듈에 대한 명령줄 스위치

- command-line switch
    - list-modules
        - 모든 모듈의 목록 인쇄
    - module-path
        - 모듈이 포함된 디렉터리를 하나 이상 지정
    - add-reads
        - resolution에 requires를 추가
    - add-exports
        - 컴파일에 exports를 추가
    - add-opens
        - 런타임에 모든 타입에 대한 리플렉션을 통한 액세스를 활성화
    - add-modules
        - 기본 세트에 모듈 목록을 추가
    - illegal-access=permit|warn|deny
        - 리플렉션을 통한 접근 규칙을 변경
- 예시
    
    ```Shell
    $ javac -d out/wgjd.discovery --add-exports=jdk.internal.jvmstat/sun.jvmstat.monitor=wgjd.discovery \
    			wgjd.discovery/module-info.java \
    			wgjd.discovery/wgjd/discovery/*.java \
    			wgjd.discovery/wgjd/discovery/internal/*
    ```
    

### 2.4.2 모듈식 앱 실행하기

### 2.4.3 모듈 그리고 리플렉션

- 자바 8에서 개발자는 리플렉션을 사용해 런타임의 거의 모든 것에 접근할 수 있다
- 모듈 시스템 개발자는 개발자에게 특정 패키지에 직접 액세스가 아닌 리플렉션을 통한 액세스가 필요
- 개방형 모듈(open module)
    - 완전히 개방된 리플렉션을 통한 액세스를 허용하는 데 사용
    - 모든 모듈의 패키지를 열어 리플렉션을 통한 액세스를 허용하지만 컴파일 시 의 액세스는 허용하지 않음

## 2.5 모듈을 위한 아키텍처

- 모듈로 마이그레이션을 위한 프로세스
    1. 자바 11로 업그레이드
    2. 자동 모듈 이름을 설정
    3. 모든 코드를 가지고 있는 모놀리식 모듈을 도입
    4. 필요에 따라 개별 모듈로 분리

### 2.5.1 분할 패키지

- 모듈 사용 시 직면하는 일반적인 문제
    - 두 개 이상의 개별 JAR에 동일한 패키지에 속하는 클래스가 포함된 분할 패키지(split package)
    - 모듈식 환경에서는 패키지가 하나의 모듈에만 속해야 하고, 분할할 수 없음

### 2.5.2 자바 8 콤팩트 프로파일

- 콤팩트 프로파일
    - JVM과 JLS를 모두 구현해야 하는, 크기가 축소된 런타임 환경
    - JLS에 명시적으로 언급된 모든 클래스와 패키지가 포함되어야 함
    - 예시
        - 서버 애플리케이션이나 다른 환경의 기반으로 사용된다는 것
    - Compact 1
        - java.io
        - java.lang
        - java.math
        - java.net
        - java.text
        - java.util
        - java.util.concurrent.atomic
        - java.util.function
        - java.crypto.inerfaces
        - javax.net.ssl
        - javax.security.auth.x500
        - java.base 모듈의 프로토타입 형태와 유사
    - Compact 2
        - XML, SQL, RMI 및 보안에 필요한 패키지 포함

### 2.5.3 다중 릴리스 JAR

- 다중 릴리스 JAR를 사용하면 자바 8과 최신의 모듈식 JVM 모두에서 작동할 수 있는 라이브러리와 컴포넌트를 포함한 JAR를 만들 수 있다
    - fallback, stubbing 접근 방식을 사용해서 이전 버전에서도 실행할 수 있다
    - fallback
        - 어떤 작업이 실패하거나 원하는 결과를 얻을 수 없을 때, 대체 수단으로 대안을 사용하는 것
    - stubbing
        - 테스트용으로 사용하는 가짜 구현체
- variant code
    - 자바 8 이후 버전을 대상으로 하는 클래스
    - META-INF/versions/<version_number>에 저장
- 프로젝트를 위한 몇 가지 기본 지침과 원칙
    - 메인 코드베이스는 자바 8로 빌드할 수 있어야 한다
    - 자바 11부분은 자바 11로 빌드해야 한다
    - 자바 11부분은 메인 빌드에서 분리된 별도의 코드 루트에 있어야 한다
    - 최종 결과는 단일 JAR이어야 한다
    - 빌드 구성을 가능한 한 단순하게 유지해야 한다
    - 다중 릴리스 JAR도 모듈식으로 만드는 것을 고려해보자

## 2.6 모듈을 넘어서

- JLink
    - 애플리케이션과 함께 축소된 자바 런타임을 패키징하는 기능
    - 이점
        - 애플리케이션과 JVM을 하나의 독립된 디렉터리로 패키지화할 수 있다
        - 애플리케이션과 JRE 번들의 설치 공간과 전체 다운로드 크기를 줄일 수 있다
        - 자바 애플리케이션과 호스트에 설치된 JVM 간의 상호작용을 디버깅할 필요가 없으므로 지원 오버헤드를 줄일 수 있다
    - 예시
        
        ```Java
        $jlink --module-path $JAVA_HOME/jmods/:out --output bundle/ 
        	--add-modules wgjd.discovery
        ```
        
    - JLink의 제한 사항
        - 완전히 모듈화된 의존성을 갖는 애플리케이션에서만 작동
        - 비모듈화 코드와는 호환되지 않는다
        - 자동 모듈만으로는 충분하지 않다
