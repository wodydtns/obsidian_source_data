>[!important]
>성능 분석은 실제로 실험 과학의 한 종류
>성능 엔지니어의 역할은 출력을 연구하고 패턴을 찾는 것

## 7.1 몇 가지 성능 용어의 기본 정의
### 7.1.1 지연 시간
- 주어진 작업량에서 하나의 작업 단위를 처리하는 데 걸리는 총 시간
- 성능 팔꿈치
	- 작업량이 증가함에 따라 성능 지표(예: 지연 시간)가 갑자기 비선형적으로 저하되는 것![[Pasted image 20241030102301.png]]
### 7.1.2 처리량
- 처리량(throughput)은 주어진 asset으로 시스템이 일정 시간 동안 수행할 수 있는 작업 단위의 개수
- 일반적으로 특정한 브랜드의 서버, 정해진 하드웨어, 운영체제, 소프트웨어 스택을 기준으로 초당 트랜잭션 수로 측정

### 7.1.3 활용도
- 활용도(utilization)는 작업 단위를 처리하는 데 사용되는 사용 가능한 에셋의 백분율
- 일반적인 작업 시간 동안 CPU가 처리하는 작업 단위의 백분율

### 7.1.4 효율성
- 효율성(efficiency)은 처리량을 사용한 에셋으로 나눈 값
- 동일한 처리량을 얻기 위해 더 많은 에셋이 필요한 시스템일수록 효율성은 낮아진다

### 7.1.5 용량
- 용량(capacity)은 시스템을 통해 동시에 처리 가능한 작업(예:트랜잭션)의 수
- 지정된 지연 시간이나 처리량에서 가능한 동시 처리량을 의미

### 7.1.6 확장성
- 확장성(scalability)는 시스템에 에셋이 추가됨에 따라 변경되는 처리량

### 7.1.7 성능 저하
- 성능저하(degradation)은 에셋을 추가하지 않고 작업 단위나 네트워크 시스템의 클라이언트를 추가 시 관찰되는 지연 시간이나 처리량

## 7.2 성능 분석에 대한 실용적인 접근 방식
>[!important]
>가장 중요한 것은 **"측정"** 해야한다는 것이다

>[!important]
>코드를 측정하기 시작하면 예상한 곳에서 시간이 소요되지 않는 경우가 흔하다. 데이터베이스 인덱스 누락, 경합하는 파일 시스템 락 등이 많은 성능 문제의 근본 원인일 수 있다


- 효과적인 성능 튜닝을 위해 알아야하는 핵심 영역
	- 측정하는 코드의 관측 가능한 측면은 무엇인가?
	- 어떻게 해당 관측 가능한 측면을 측정할 것인가?
	- 관측 가능한 측면에 대한 목표는 무엇인가?
	- 성능 튜닝이 완료됐을 때 어떻게 알아볼 것인가?
	- 성능 튜닝에 대한 최대 허용 비용은 얼마인가(개발자 시간과 코드의 추가적인 복잡성 측면에서)?
	- 최적화하면서 희생해서는 안 되는 요소는 무엇인가?
### 7.2.1 측정 대상 알기
>[!tip]
>우수한 성능 엔지니어가 되기 위해서 평균, 중앙값, 최빈값, 분산, 백분위수, 표준편차, 표본 크기, 정규 분포 같은 용어를 이해해야 한다

- 무엇을 측정하고 있는지 파악하고 수치가 정확하다는 확신을 갖는 것이 첫 번째 단계
- 성능 목표는 모호한 것이 아닌 **"SMART"** 해야 한다
	- Specific(구체적), measurable(측정 가능한), agreeds(합의되고), relevant(관련성이 있고), time-based(시간 제한이 있는) 목표여야 한다

### 7.2.2 측정 방법 알기
- 메서드나 기타 자바 코드 실행 시간을 측정하는 방법
	- 소스 측에 측정 코드를 삽입해 직접 측정 - 수동 계측(manual instrumentation)
	- 클래스 로딩 시간에 측정할 클래스를 변환 - 자동 계측(auto instrumentation)
- direct measurement(직접 측정)
	- 가장 쉬운 기술이지만, 침습적
	- 예시 -  System.currentTimeMillis()을 사용
	- 문제점
		- 시간 측정 메서드를 코드베이스 전체에 추가해야하고, 측정 횟수가 증가함에 따라 데이터가 넘치는 것을 피하기 어려움
		- 콜드 스타트 문제(cold start problem)도 발생함
		- currentTimeMillis()는 네이티브 메서드 호출과 시스템 호출로 시스템 클럭을 읽어야하는데 이는 시간이 많이 소요되는 작업
		- 실행 파이프라인에서 코드를 플러시할 수도 있으므로 측정 코드가 없는 경우에는 발생하지 않을 추가적인 성능 저하 초래
- 클래스 로딩을 통한 자동 계측
	- methodToBeMeasured()가 특수한 클래스로더에 의해 로드되고, 메서드의 시작과 끝에 바이트코드가 추가돼 메서드가 호출 및 종료된 시간을 기록
	- 이 타이밍 정보는 일반적으로 공유 데이터 구조에 기록되고, 다른 스레드에서 액세스
	- 이 스레드는 데이터를 처리하는데, 보통 로그 파일에 출력하거나 원시 데이터를 처리하는 네트워크 기반 서버에 전달하는 역할
	- 이 기술은 많은 프로페셔널급 자바 성능 모니터링 도구의 핵심 요소

### 7.2.3 성능 목표 알기
>[!important]
>성능 목표는 간단하고 명확하게 명시된 목표여야한다


- 좋은 목표 예시
	- 동시 사용자 열 명에서 90분위(90 번째) 값의 end-to-end 지연 시간 20% 줄이기
	- handleRequest()의 평균 지연 시간 40% 줄이기

### 7.2.4 언제 멈춰야 하는지 알기
- 멈추어야 할 시기를 알기 위해서 목표를 인식하는 능력뿐만 아니라 그 목표가 가치 있는지를 판단하는 감각이 필요하다. 종종 성능 목표의 90%정도를 달성하는 것으로도 충분하다
- 다른 중요한 고려 사항은 드물게 사용되는 코드 경로에 얼마나 많은 노력을 투입하고 있는지를 확인하는 것
	- 프로그램 실행 시간의 1%나 그 보다 적은 비중을 차지하는 코드를 최적화하는 것은 대부분 시간 낭비
- 최적화 대상을 선별하기 위한 간단한 지침
	- 쉽게 최적화할 수 있는 것이 아니라 중요한 것을 최적화하자
	- 가장 중요한 (보통 가장 자주 호출되는) 메서드를 우선 처리하자
	- 할 수 있는 한 간단한 최적화를 적용하되, 해당 코드가 얼마나 자주 호출되는지를 고려하자
### 7.2.5 더 높은 성능을 달성하기 위한 비용 알기
- 모든 성능 튜닝에는 비용이 든다
	- 분석을 수행하고 개선을 개발하는 데 걸리는 시간이 있다
	- 수정 사항으로 인해 도입한 추가적인 기술적 복잡성이 있을 수 있다
	- 주 처리 스레드의 처리 속도 향상을 위해 보조 작업을 수행하는 추가적인 스레드가 도입됐을 수 있으며, 하위 스레드가 더 높으 부하에서 전체 시스템에 예상치 못한 영향을 미칠 수 있다
### 7.2.6 성급한 최적화의 위험성 알기
>[!note]
>도널드 커누스의 Structured Programming with go to Statements 인용문
>***프로그래머는 프로그램에서 중요하지 않은 부분의 속도에 대해 생각하거나 걱정하는 데 엄청난 시간을 낭비하며, 효율성을 높이려는 이러한 시도는 실제로 매우 부정적인 영향을 미친다. 성급한 최적화(premature optimization)는 모든 악의 근원이다***

- 좋은 스타일의 최적화 예시
	- 필요하지 않은 객체를 할당하지 말 것
	- 필요하지 않은 경우 디버그 로그 메시지를 제거할 것
	- 로깅 가드(logging guard)
		- 로깅 시스템이 디버그 로그를 위해 설정되지 않은 경우 해당 코드가 로그 메시지를 생성하지 않아, 메서드 호출 및 객체 생성 비용을 절약하는 방법
		- 예시
```Java
if (log.isDebugEnabled()){
	log.debug("Useless log at: " + System.currentTimeMillis());
}
```

## 7.3 무엇이 문제인지 왜 신경 써야 하는가?
### 7.3.1 무어의 법칙
- 경제적으로 생산 가능한 칩 위의 트랜지스터 수가 대략 2년마다 거의 2배로 증가하는 법칙
### 7.3.2 메모리 지연 계층구조 이해하기
>[!important]
>기본적으로 모든 최신 CPU는 멀티코어다
>성능과 동시성은 서로 밀접한 관련이 있다


- 메모리 지연 시간 해결
	- 'CPU 코어가 작업할 때 필요한 데이터의 가장 가까운 복사본은 어디에 있는가'
	- '코어가 해당 데이터를 사용할 수 있는 위치까지 도달하는 데 얼마나 걸릴 것인가'
	- 두 질문에 답을 줄 수 있는 하드웨어들
	- 레지스터
		- CPU에 있으며 즉시 사용할 수 있는 메모리 위치
		- 명령어가 직접 작동하는 메모리 부분
	- 메인 메모리
		- 일반적으로 DRAM
		- 액세스 시간은 약 50나노초
	- 솔리드 스테이트 드라이브(SSD)
		- 이 디스크에 액세스하는 시간은 0.1ms 이하
	- 하드 디스크
		- 디스크에 액세스해 필요한 데이터를 주 메모리에 로드하는 데 약 5ms초
- 메모리 속도는 CPU가 트랜지스터를 추가한 것보다 더 느리게 개선 -> 처리 코어가 필요한 데이터를 처리할 수 없어 작업이 중단될 수도 있음을 의미
- **즉, 관련 데이터의 로드가 느려서 처리할 수 없는 경우 처리 코어가 유휴 상태에 빠질 위험이 있다**
- 위의 문제를 해결하기 위해 레지스터와 주 메모리 사이에 작은 용량의 빠른 메모리(SRAM)인 캐시 도입
	- 매우 비쌈
- 메모리 지연 시간 해결 방법 
	1. 캐시
		1.  L1 이나 L2 라 함
		2. 숫자는 캐시가 코어에 물리적으로 얼마나 가까운지를 나타냄(가까운 캐시일수록 더 빠름)
	2. 더 복잡한 프로세서 기능 추가
		1. 명령어 수준 병렬성(instruction-level paralleism)
		2. 칩 멀티스레딩(chip level multithreading)
	
## 7.4 자바 성능 튜닝은 왜 어려운가?
- JVM은 관리형 시스템
	- 개발자가 모든 세부 사항을 다룰 필요가 없도록 런타임이 일부 제어를 수행할 수 있게끔 하는 것이 목적
	- 이는 프로그래머들의 생산성을 높혀주지만, 일부 제어권을 포기해야한다는 의미

### 7.4.1 성능 튜닝에서 시간의 역할
>[!important]
>자바의 타이밍 시스템에서 가장 중요한 요점
> - 대부분의 시스템에는 내부의 여러 가지 시계가 있다
> - 밀리초 단위의 타이밍은 안전하고 신뢰성이 있다
> - 더 높은 정밀도의 시간은 드리프트(drift)를 피하기 위해 신중한 처리가 필요하다
> - 타이밍의 정밀도와 정확도를 인식해야 한다


- 정밀도
	- 주어진 측정값에 포함된 무작위 잡음의 양을 측정하는 것
	- 정밀도를 나타내는 일반적인 방법은 95% 신뢰 구간의 너비를 인용하는 것
- 정확도
	- 실제값에 가까운 값을 얻는 능력
	- 정확도는 측정값의 체계적인 오차를 측정
	- 정확한 측정이라고 해도 정밀도가 낮을 수 있다
- 측정값의 이해
	- 지나치게 정확해 보이는 성능 숫자에 주의하고 항상 측정의 정밀도와 정확도를 확인하자
- 입상도(granularity)
	- 가장 빠른 타이머의 주파수로 결정
	- 일반적으로 인터럽트 타이머이며, 이는 10나노초 범위에 있따
	- '서로 가까운 위치에 있지만 다른 시간에 발생했다고 명확히 말할 수 있는 가장 짧은 간격'(종종 구별력이라고 함)
- 분산 네트워크에서의 타이밍
	- 네트워크상 분산된 시스템의 성능 튜닝 수행 시 특수한 문제가 발생할 수 있다

### 7.4.2 캐시 미스 이해하기
- L1 cache miss
	- 처리량이 많은 코드의 경우 성능을 저하시키는 주요 요인 중 하나

## 7.5 가비지 컬렉션
### 7.5.1 기본적인 사항
- 표준 자바 프로세스
	- stack
		- 로컬 변수를 저장하는 곳
		- 원시 타입을 저장하는 로컬 변수는 해당 값을 직접 스택에 저장
	- heap
		- 참조 타입의 로컬 변수를 저장 하는 곳
		- 실제 객체가 생성되는 곳
- 스택과 힙에 있는 변수들
	![[Pasted image 20241030142844.png]]
- 객체의 원시 타입 필드들은 힙 내 주소에 할당하고, 자바 프로그램이 실행되면 힙에 새로운 객체가 생성되며, 객체 간의 관계가 변경(필드가 업데이트되는 등) => 힙은 새로운 객체를 생성할 공간이 부족해짐 & 불필요한 객체가 있을 수 있음
- 이로 인해 힙 내 공간은 회수되고 프로그램은 계속 실행
- 가비지 컬렉션
	- **애플리케이션 코드에서 더 이상 사용되지 않는 힙 메모리를 플랫폼이 회수하고 재사용하는 메커니즘**
### 7.5.2 마크 앤 스윕(mark and sweep)
>[!note]
>스택 프레임
>로컬 변수, 메서드 매개변수, 임시 변수나 드물겠지만 다른 가능한 경우

>[!note]
>live 객체
>사용자 스레드의 스택 프레임에서 참조를 가지는 객체

- 마크 앤 스윕(mark and sweep)
	- 간단한 가비지 컬렉션 알고리즘
	- 알고리즘 진행 과정
		1. 모든 실행 중인 프로그램 스레드를 일시 정지
		2. 활성 객체들로부터의 참조 트리를 따라가면서 경로상에서 발견되는 모든 객체를 'live'로 표시
		3. 남은 모든 것은 가비지로 간주돼 수거(스윕)함(메모리는 OS가 아닌 **JVM** 에 반환)
- 비결정적인 일시 정지는 괜찮은가?
	- 마크 앤 스윕 형태의 가비지 컬렉션은 STW(Stop The World) 상태를 야기함
	- 이로 인해 일시 정지가 비결정적인 시간 동안 계속 일어남
	- 자바 플랫폼은 기본적인 마크 앤 스윕 접근 방식에 개선을 제공 =>"세대별 가비지 컬렉터 추가"
	- 세대별 가비지 컬렉터 추가
		- 다양한 힙 메모리 영역이 자바 객체의 생명 주기에 참여하도록 함
### 7.5.3 메모리 영역
- JVM이 가지고 있는 메모리 영역
	- Eden
		- 모든 객체가 초기에 할당되는 힙 영역
		- 많은 객체에 대해서는 이 영역이 유일한 메모리 영역
	- Survivor
		- 가비지 컬렉션 주기에서 생존한 객체들이 이동한 공간
		- 처음에는 Eden에서 이동하지만, 후속 가비지 컬렉션에서는 survivor 영역 간에 이동할 수도 있다
		- 사실상 모든 객체를 처리하기 위한 장치
	- Tenured
		- '충분히 오래된' 생존 객체들이 이동하는 공간
		- Tenured 메모리는 young 컬렉션 중에는 수집되지 않는다

### 7.5.4 young 컬렉션(young collection)
- young 컬렉션(young collection)
	- young 영역(Eden, survivor)을 정리하는 프로세스
	- young 컬렉션의 프로세스
		- 마킹 단계 동안 발견된 모든 live young 객체를 옮긴다
		- 충분히 오래된 객체(이전 가비지 컬렉션 실행에서 충분히 생존한 객체)는 Tenured로 이동한다
		- 다른 young live 객체는 빈 survivor 영역으로 이동한다
		- 마지막으로 Eden과 방금 비워진 survivor 영역에는 가비지만 있기 때문에 덮어쓰고 재사용할 준비가 됐다
	- young 컬렉션은 Eden이 가득 찼을 때 트리거 됨
	- 마킹 단계는 전체 live 객체 그래프를 통과해야함
		- 만약 young 객체가 Tenured 객체를 참조한다면, Tenured 객체가 보유한 참조도 스캔되고 마킹돼야 한다. 그렇지 않으면 Tenured 객체가 Eden의 객체를 참조하지만 다른 곳에서는 참조하지 않는 상황이 발생할 수 있다
	- 실제로 전체 마킹 순회의 비용을 줄이기 위해 [[마킹 순회(Marking Traversal) 성능 향상 기법|몇 가지 성능 향상 기법]]이 사용된다
### 7.5.5 full 컬렉션
- young 컬렉션에서 객체를 Tenured로 이동시킬 수 없을 때(공간 부족으로 인해), full Collection이 트리거 된다
- 콤팩팅(compacting)
	- 사용하는 컬렉터에 따라 오래된 세대 내에서 객체를 옮기는 것
	- 오래된 세대가 필요한 경우, 큰 객체를 할당할 충분한 공간이 있는지 확인하기 위해 수행됨

### 7.5.6 세이프 포인트
- safepoint
	- JVM에서 힙이 일관된 상태에 있고 가비지 컬렉션이 수행될 수 있는 특정 시간
	- 예시 - '바이트코드 명령어 사이'
		- JVM 인터프리터는 한 번에 하나의 바이트코드를 실행하고, 그 다음 바이트코드를 스트림에서 가져옴
		- 이 순환 직전에 인터프리터 스레드는 힙에 대한 수정(예 : putfield를 통한 수정)을 완룧마ㅡ로, 스레드가 여기서 중지되면 '안전'함
	- 모든 애플리케이션 스레드가 safepoint에 도달하면 가비지 컬렉션이 수행
	- 참고 링크 : "https://blogs.oracle.com/javamagazine/post/loop-unrolling"

### 7.5.7 G1: 자바의 기본 컬렉터
- G1(Garbage-First)
	- 자바 플랫폼을 위한 상대적으로 새로운 컬렉터
	- 처음에는 저지연 컬렉터로 개발됐지만 실제로는 일반용 컬렉터로 발전해 기본 설정으로 사용됐다
	- region 기반으로 작동
		- G1 자바 힙은 힙을 동일한 크기의 region으로 분할
		- 세대는 여전히 존재하지만, 메모리에서 반드시 연속적으로 존재할 필요는 없다
	- regionalization
		- 가비지 컬렉션 일시 중단의 예측 가능성을 지원하기 위해 도입
	- 더 큰 힙에 대해서도 더 긴 일시 중단 시간이 발생하지 않는 컬렉션 전략을 제공
		- 'All or None' 식의 동작을 피하기 위해 설계
		- 일시 중단 목표
			- 'All or None' 식의 동작을 피하기 위한 핵심 개념
			- 프로그램이 가비지 컬렉션을 위해 일시 중단할 수 있는 최대 시간
			- G1은 합리적인 범위 내에서 일시 중단 목표를 달성하기 위해 최선을 다함
			- 일시 중단 동안, 생존 객체는 다른 리전으로 이동하고(Eden 객체가 survivor 객체영역으로 이동하는 것과 유사), 해당 리전은 비어 있는 리전들의 리스트에 다시 배치
	- G1에서의 young 컬렉션
		- 완전한 Stop The World
		- 완료까지 실행
		- young 컬렉션이 애플리케이션 스레드와 동시에 실행될 경우 발생할 수 있는 컬렉션과 할당 스레드 간의 경쟁 조건을 피하기 위한 것
	- G1의 오래된 객체 수집
		- 오래된 세대에 도달한 객체들은 일정 기간동안 존재하기 때문에 오래 살아남을 확률이 높음
		- 오래된 세대에 제공되는 공간은 young 세대보다 훨씬 큰 경우가 많음
		- 오래된 세대로 이동한 객체를 추적하고, 오래된 세대의 공간이 충분히 채워지면(기본적으로 45%인 [[InitiatingHeapOccupancyPercent 또는 IOHP]]에 의해 제어됨) 오래된 컬렉션이 시작
		- 이는 애플리케이션 스레드와 가능한 한 동시에 실행되므로 동시성 컬렉션이라고도 할 수 있음
		- 오래된 객체 수집의 수행 단계
			- 동시 표시 단계
			- young 컬렉션이 트리거
			- 혼합 컬렉션(mixed collection) 트리거
				- 오래된 리전에서 가비지의 양에 따라 오래된 리전을 수집(동기 마킹 도중 수집된 통계 정보로 유추)
				- 오래된 리전에서 생존한 객체는 새로운 오래된 리전으로 이동시키고(이 과정에서 압축) 메모리를 재사용함
		- 전체 오래된 세대의 수집이 한 번의 가비지 컬렉터 주기 내에 완료되지 못할 수 있음
			- 이 경우 G1은 일부 영역을 수집한 다음, 컬렉션을 완료하고, 가비지 컬렉션에 사용되던 CPU 코어를 해제
			- 오랜 기간 장수 객체의 생성이 가비지 컬렉션의 회수 능력을 초과하지 않는다면, 모든 것은 원활할 것이다
		- 할당량이 회수량을 지속적으로 초과할 경우
			- 가비지 컬렉션은 최후의 수단으로 STW full 컬렉션을 수행해, 오래된 세대를 완전히 정리하고 압축
			- 실제 이 동작은 애플리케이션에 심각한 문제가 있는 경우에만 나타남
	- G1 컬렉션 전략의 특성으로 인해 플랫폼은 한 리전을 수집하는 데 걸리는 시간에 대한 통계를 수집할 수 있음 => 이를 퇑해 **일시 중단 목표**가 정해진다
	- 단일 리전보다 큰 크기의 객체를 할당할 수 있음(거대한 리전\<humongous region>)
		- 큰 배열에 할당되는 공간은 메모리에서 연속적이어야함
		- 충분한 수의 인접한 빈 리전이 있다면, 이들은 하나의 거대한 리전으로 변환되고 배열을 할당할 수 있음
	- 배열을 할당할 수 있는 메모리 공간이 없는 경우(young 컬렉션 후에도)에는 메모리가 '조각화됐다(fragmented)'라고 말한다
	- G1이 힙을 나누는 방법
		![[Pasted image 20241030150342.png]]
### 7.5.8 parallel 컬렉터
- parallel 컬렉터
	- 자바 8 이전의 기본 설정, G1의 대안
	- 가비지 컬렉션에서의 동시성과 병렬
		- 동시성
			- 가비지 컬렉션 스레드는 애플리케이션 스레드와 동시에 실행할 수 있다
			- STW의 반대 개념
		- 병렬
			- 가비지 컬렉션(가비지 컬렉션 알고리즘 자체)은 멀티스레드로 실행되며, 다중 코어를 사용할 수 있다
			- 단일 스레드 방식의 반대 개념
	- 이 힙 구성에선 두 개의 survivor 영역이 있음
		- From, To로 언급
		- 컬렉션이 진행 중이 아닌 경우에는 항상 하나의 survivor 영역이 비어 있다
	- 단점
		- 일시 중단 목표를 설정할 수 있는 능력이 없고, STW가 발생하는 오래된 세대 수집은 시간이 걸려도 반드시 완료돼야 한다
### 7.5.9 가비지 컬렉션 구성 매개변수
- 기본적인 가비지 컬렉션 스위치

| 스위치                    | 효과                                     |
| ---------------------- | -------------------------------------- |
| -Xms\<size in MB>m     | 힙의 초기 크기를 지정하는 스위치. 기본값은 물리적 메모리의 1/64 |
| -Xmx\<size in MB>m     | 힙의 최대 크기를 지정하는 스위치. 기본값은 물리먹 메모리의 1/4  |
| -Xmn\<size in MB>m     | 힙 내 Young Generation의 크기를 지정하는 스위치     |
| -XX:-DisableExplicitGC | System.gc() 호출이 어떠한 효과도 가지지 않도록 막는 스위치 |
- -Xms 크기와 -Xmx를 동일하게 설정하는 것
	- 프로세스는 정확히 해당 힙 크기로 실행되며 실행 중에 크기를 조정하지 않음
	- 이것은 **안티패턴**
	- 현대의 가비지 컬렉션은 좋은 동적 크기 조정 알고리즘을 갖추고 있으며, 이를 인위적으로 제한하는 것은 득보다 실이 많다
- 자바 11, 17에서 '물리적 메모리'는 컨테이너의 제한을 의미하므로 힙의 최대 크기를 컨테이너의 제한 내로 맞춰야한다
- 자바 힙 메모리 이외의 공간과 JVM 이외의 다른 프로세스를 위한 공간을 확보해야 한다
- 자바 8의 초기 버전은 컨테이너 제한을 반드시 준수하지 않을 수 있으므로 애플리케이션을 컨테이너에서 실행 중이라면 **항상 자바 11로 업그레이드할 것을 권장**
- **G1 컬렉터용 플래그 - 튜닝 시 유용한 두 가지 설정**

| 스위치                           | 효과                                                       |
| ----------------------------- | -------------------------------------------------------- |
| XX:MaxGCPauseMillis=50        | G1 가비지 컬렉터에 대한 한 번의 컬렉션 동안 최대 50ms 이내로 일시 중지하도록 지시하는 스위치 |
| -XX:GCPauseIntervalMillis=200 | G1 가비지 컬렉터에게 컬렉션 간격을 최소한 200ms으로 하도록 지시하는 스위치            |
## 7.6 핫스폿에서의 JIT 컴파일
- JIT 컴파일(just-in-time complation)
	- 일부 애플리케이션과 프레임워크 클래스를 런타임에서 추가적으로 컴파일 해 기계 코드로 변환하고 직접 실행하는 것
	- 기본 사항
		- 거의 모든 현대 JVM은 어떤 형태의 JIT 컴파일러를 가지고 있다
		- 순수한 인터프리트 JVM은 비교적 매우 느리다
		- 컴파일된 메서드는 인터프리트된 코드보다 훨씬 빠르게 실행된다
		- 가장 자주 사용되는 메서드를 먼저 컴파일하는 것이 합리적이다
		- JIT 컴파일을 수행할 때는 항상 가장 쉬운 부분을 먼저 처리하는 것이 중요하다
			- 인터프리트된 상태에 있는 메서드보다 컴파일된 코드를 먼저 살펴봐야한다는 의미한다
- 메서드는 바이트코드 표현에서 인터프리트된 상태로 시작하며, JVM은 메서드가 호출된 횟수 및 일부 기타 통계를 추적한다
- 임계값에 도달해서 해당 메서드가 대상이 되면 JVM 스레드가 백그라운드에서 바이트코드를 기계 코드로 컴파일 => 컴파일 성공 시 메서드에 대한 모든 후속 호출은 컴파일된 형태를 사용하게 되며, 무효화되거나 다른 이유로 최적화가 해제되는 경우를 제외하고는 계속 사용

### 7.6.1 동적 컴파일의 필요성
- 자바 플랫폼이 동적 컴파일(dynamic complation)에 신경 쓰는 이유
	- 일반적으로 플랫폼에 독립적인 아티팩트(.jar 및 .class 파일)를 배포의 기본 단위로 사용하는 것이 플랫폼마다 다르게 컴파일된 이진 파일을 처리하는 것보다 훨씬 쉬움
	- 동적 컴파일을 사용하는 언어가 컴파일러에게 더 많은 정보를 제공할 수 있다
- 미리(AOT, ahead of time) 컴파일된 언어는 런타임의 정보에 액세스할 수 없음
	- 특정 명령어의 가용성이나 다른 하드웨어 세부 정보, 코드 실행 상태에 대한 통계 등

### 7.6.2 핫스폿 소개
- C1(클라이언트 컴파일러)
	- C1 compiler는 원래 GUI 애플리케이션에서 사용하기 위해 개발
	- 컴파일 시 보수적인 결정 수행
		- 잘못된 최적화 결정이나 잘못된 가정에 기반한 최적화를 되돌리는 동안 예기치않게 일시 중지 할 수 없다
		- 상대적으로 컴파일 임계값이 낮고, 메서드가 컴파일 대상이 대기 위해 1500번 실행해야해 상대적으로 짧은 워밍업 기간을 가진다
- C2(서버 컴파일러)
	- 컴파일 시 공격적인 가정
	- 런타임에 빠른 검사(일반적으로 가드 조건\<guard condition>)를 추가해 해당 가정이 유효한 지 확인
	- 일반적으로 위험을 회피하는 클라이언트 컴파일러보다 훨씬 더 나은 성능 제공
	- C1보다 훨씬 높은 인라인화 임곗값을 가지고 있다
		- 기본적으로 메서드가 10000번 호출될 때까지 C2 컴파일 대상이 되지 않아, 워밍업 시간이 훨씬 길다
- 실시간 자바
	- 실시간 프로그래밍은 실현할 수 있는 보장에 관한 것
	- 통계적으로 실시간 시스템은 특정 작업에 걸리는 시간의 분산을 줄이려고 하며, 이를 위해 평균 지연 시간의 일부를 희생 => 일반적인 성능이 좀 희생되더라도 더 일관된 실행을 얻기 위해 어느 정도의 평균 지연을 희생할 준비가 되어 있다
	- 더 높은 성능을 추가하는 팀은 일반적으로 더 낮은 평균 대시 시간을 추구하며, 분산이 높아도 괜찮다고 생각해, 서버 컴파일러의 공격적인 최적화가 특히 적합함
	- 현대 JVM에선 C1, C2 컴파일러 모두 사용
		- 초기에는 C1 컴파일러가 사용되고, 애플리케이션이 워밍업한 후 고급 서버 클래스 최적화를 사용한다
		- **이를 tiered compilation(계층형 컴파일)이라고 한다**
### 7.6.3 메서드 인라인화
- 인라인화
	- 호출된 메서드의 호출을 제거하고 호출한 메섣의 코드를 호출자 내부에서 배치해 동작
	- 플랫폼의 장점
		- 컴파일러가 메서드 호출 빈도와 기타 요인(예:호출자 메서드가 너무 커져 코드 캐시에 영향을 미칠 수 있는지 등)에 대한 적절한 런타임 통계를 기반으로 인라인을 결정
- 접근자 메서드는 어떨까?
	- 핫스폿에서 accessor method==접근자 메서드== (==private== 멤버 변수에 접근하는 ==public== getter) 를 인라인할 수 있다
	- 변수가 private이므로 클래스 외부의 접근이 불가능해 메서드 호출이 최적화되지 않는다고 생각하지만 **그렇지 않다**
	- 핫스폿은 메서드를 기계 코드로 컴파일할 때 access control==접근 제어== 를 무시하고, 접근자 메서드를 private 필드에 대한 직접적인 액세스로 대체
	- 메서드 인라인은 전적으로 자동이며, 거의 모든 상황에서 기본 매개변숫값으로 충분
	- 스위치는 인라인화의 내부 작동 방식을 이해할 때 유용하지만, 프로덕션 코드에선 유용하지 않은 경우도 많고 런타임 시스템의 성능에 예측할 수 없는 영향일 끼치므로 성능 기법으로는 **마지막 수단으로 고려해야한다**
### 7.6.4 동적 컴파일과 단일형 호출
- monomorphic call(단일형 호출)
	- 해당 객체에 대한 메서드 호출이 항상 한 종류의 객체에 의해 호출되는 것
	- 서버 컴파일러에 의해서만 수행되는 상당히 공격적인 최적화
```Java
MyActualClassNotInterface obj = getInstance();

obj.callMyMethod();
```
	- 호출 사이트인 obj.callMyMethod(); 에서 인스턴스 obj는 특정 클래스와 그 하위 클래스 중 하나로 한정
	- 자바 메서드 lookup를 callMyMethod()에 해당하는 컴파일된 코드에 직접 호출로 대체 가능

### 7.6.5 컴파일 로그 읽기
- 컴파일 로그 읽기
	- -XX:+PrintCompilation - JIT 컴파일 스레드가 표준 로그에 메시지 추가하도록 지시하는 플래그
	- 메시지 예시
```bash
1. java.lang.String::hashCode (64bytes)
2. java.math.BigInteger::mulAdd (81bytes)
3. java.math.BigInteger::multiplyTolen (219bytes)
4. java.math.BigInteger::addOne (77bytes)
5. java.math.BigInteger::squareTolen (172bytes)
6. java.math.BigInteger::primitiveLeftShift (79bytes)
7. java.math.BigInteger::montReduce (99bytes)
8. sun.security.provider.SHA::implCompress(491 bytes)
9. java.lang.String::charAt(33bytes)
10. 1% ! sun.nio.cs.SinglebyteDecoder::decodeArrayLoop @ 129 (308 bytes)
1% ...
39 sun.misc.FloatingDecimal::doubleValue(1289bytes)
40 org.camelot.hipparcos.DelimitedLine::getNextString(5 bytes)
...
2% ! org.camelot.CamelotStarter::populateStarStore @ 25 (106 bytes)
65 s java.lang.StringBuffer::append(8 bytes)
```
	- s : 메서드가 동기화된 메서드임을 나타낸다
	- ! : 메서드에 예외 처리기가 있음을 나타낸다
	- % : 스택 교체(on-stack replacement)
- 좀비를 조심하자
	- 서버 컴파일러 C2를 사용해 실행되는 코드의 샘플 출력 로그를 살펴보면 가끔 'made not entrant' 와 'made zombie'와 같은 줄을 볼 수 있는데, 이는 특정 메서드가 컴파일됐으나 일반적으로 클래스 로딩 작업으로 인해 무효화됐음을 의미한다

### 7.6.6 최적화 해제
>[!note]
>핫스폿은 동일한 메서드가 여러 번 최적화를 해제하고 다시 컴파일될 수 있다


- 핫스폿은 사실이 아닌 가정을 기반으로 한 코드의 최적화를 해제할 수 있다
- 많은 경우, 그 다음 다시 고려해 다른 최적화를 시도
- 코드는 안정된 컴파일 상태에 도달하고 대부분 그 상태를 유지
- **컴파일된 메서드의 정확한 세부 사항은 사용 중인 JVM 버전과 OS 플랫폼에 따라 달라져, 모든 플랫폼이 동일한 컴파일된 메서드 집합을 생성하고 특정 메서드의 컴파일된 코드가 플랫폼 간 대략 동일한 크기일 것이라고 가정하는 것은 잘못된 생각이다**

## 7.7 JDK Flight Recorder
- JFR
	- 이벤트를 바이너리 형식으로 작성하기 위한 고성능 백엔드를 갖춘 오버헤드가 낮은 이벤트 기반 프로파일링 엔진
- JMC
	- 단일 JVM의 텔레메트리(telemetry)에서 JFR이 생성한 데이터 파일을 검사하기 위한  GU구
### 7.7.1 Flight Recorder
- Flight Recorder - Java Flight Recorder(JFR)
	- OpenJDK 8의 8u262 버전 이상부터 사용 가능
	- 키 스위치
		- -XX:StartFlightRecording:\<options>
	- 일회성 덤프 파일이나 연속적인 링 버퍼로 수행할 수 있고, 개별적인 명령줄 옵션을 통해 캡처할 데이터를 제어할 수 있다
	- 100가지 이상 다양한 지표를 캡처할 수 있다 -> 약간의 오버헤드 동반
	- default.jfc
		- 매우 낮은 오버헤드로 설계
		- 거의 모든 프로적션 자바 프로세스에서 사용 가능
	- profile.jfc
		- 더 자세한 정보 제공
		- 런타임 비용이 더 높음
	- 프로세스 시작 시에 **구성할 필요가 없음**
		- ==jcmd== 명령어를 통해 cmd에서 제어 가능
		- 예시
```bash
$ jcmd <pid> JFR.start name=Recording1 settings=default
$ jcmd <pid> JFR.dump filename=recording.jfr
$ jcmd <pid> JFR.stop
```

### 7.7.2 미션 컨트롤
- JDK 미션 컨트롤(JDK Mission Control, JMC)
	- JFR 출력 파일에 포함된 데이터를 표시하는 그래픽 도구
	- ==jmc== 명령으로 시작
	- 제공 기능
		- overview telemetry(원격 측정 개요) 
		- 주요 하위 시스템 분석을 위한 화면 제공
			- 가비지 컬렉션에서 JFR 파일의 수명 동안 발생한 가비지 컬렉션 이벤트를 보여주는 화면
		- 세부 프로파일 구성
			- 새로운 할당 버퍼(TLAB)가 응용 프로그램 스레드에 제공하는 개별 이벤트 조회
		- JIT 컴파일러 작동 방식 조회
		- 코드 캐시 사용량
	- JMC는 단일 JVM 진단 가능, 전체 클러스터(전체 애플리케이션)으로는 확장이 불가능
	- 자바 14부터 도입된 JFR 스트리밍 API는 심층 분석, 모니터링을 위한 기반 제공