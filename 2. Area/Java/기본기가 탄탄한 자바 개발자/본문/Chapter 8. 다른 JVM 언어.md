## 8.1 언어 분류학
### 8.1.1 인터프리터 언어 vs 컴파일 언어
- 인터프리터 언어(==interpreted language==)
	- 소스 코드의 각 단계를 그대로 실행하는 언어
	- 실행 시작 전 전체 프로그램이 기계 코드로 변환되지 않음
- 컴파일 언어(==compiled language==)
	- 사람이 읽을 수 있는 소스 코드를 이진 형태로 변환하기 위해 컴파일러를 사용하는 언어

### 8.1.2 동적 타이핑 vs 정적 타이핑
- 동적 타이핑(==dynamic typing==)
	- 변수가 프로그램 실행 중에 다른 타입의 값을 담을 수 있음
	- 변수에 저장한 값에 대한 타입 정보를 동적 타입 언어가 가지고 있음
	- 예시
```javascript
var answer = 40;
answer = answer + 2;
answer = "What is the answer? " + answer;
```
- 정적 타이핑
	- 컴파일된 언어에 적합한 방식
	- 타입 정보가 변수에 대한 것

### 8.1.3 명령형 언어 vs 함수형 언어
- 명령형 언어
	- 프로그램의 실행 중인 상태를 가변 데이터로 모델링하고, 그 실행 상태를 변환하는 명령문 목록을 만들어내는 언어
	- 프로그램 상태가 명령형 언어에서 중심이 되는 개념
	- 자바가 이것에 해당
	- 하위 유형
		- 절차적 언어(procedual language)
			- 코드와 데이터를 완전히 분리하고 간단한 코드가 데이터 작용하는 패러다임
		- 객체지향 언어(object-oriented language)
			- 데이터와 코드(메서드 형태)가 객체로 묶여있다
			- 객체지향 시스템에서 프로그램 상태는 프로그램 내 모든 객체의 상태
			- 메타데이터(예: 클래스 정보)를 통해 추가적인 구조가 전달
		- 함수형 언어(functional language)
			- 계산 자체가 가장 중요한 개념
			- 함수는 절차적 언어에서처럼 값에 작용하지만, 입력값을 변경하는 대신 새로운 값을 반환하는 것으로 간주![[Pasted image 20241031101839.png]]
			- 일급 함수(first-class function)
				- 함수를 값으로 다룰 수 있는 기능
				- 변수에 할당하거나 다른 함수에 전달하거나 다른 함수로부터 반환할 수 있음
### 8.1.4 재구현 vs 원래 언어
- 기존 언어를 JVM으로 재구현한 언어
	- JRuby
		- Ruby를 JVM으로 재구현
		- Ruby는 동적 타입의 객체지향 언어로 일부 함수형 기능 소유
	- Jython
		- 파이썬에서 고성능 자바 라이브러리를 사용하는 방법으로 개발
		- 동적이고 주로 객체지향 언어
		- 내부적으로 파이썬 바이트코드를 생성한 다음, 해당 코드를 JVM 바이트코드로 변환
		- 파이선 2.7만 지원
	- Rhino
		- JVM상 자바스크립트 구현
		- JDK 11에서 사용 중지, 15에서 완전 제거
## 8.2 JVM에서의 다중 언어 프로그래밍
- 다중 언어 프로그래밍(==polyglot programming==)
	- 다중 언어 프로그래밍 피라미드
		![[Pasted image 20241031104702.png]]
		- 관심사를 분리하는 방식으로 구분
		- 피라미드 내에서 의존성은 한 방향으로 진행
		- 안정적 레이어
			- 다른 레이어에 비해 독립적
			- 시스템의 핵심 API, 추상화가 포함되고, 타입 안전성, 철저한 테스트, 성능 모두 중요
		- 동적 레이어
			- 안정적인 레이어를 사용함
			- 안정적인 레이어의 추상화를 사용해 작동하는 시스템을 만든다
			- 시스템이 HTTP를 통해 자신을 노출하거나 다른 백엔드 시스템과 상호작용하는 코드가 포함될 수 있다
			- 컴파일 시간과 유연성 등의 문제로 동적 계층에서 다른 언어를 고려할 수 있다
		- 도메인별 특화 레이어
			- 아래의 레이어들을 사용함
			- 프레젠테이션, 규칙 및 처리의 사용자 정의화, CI/CD와 같은 응용 프로그램 특정 관심사를 다룸
			- 애플리케이션 도메인의 특정 측면과 관련된 것
- 다중 언어 프로그래밍 피라미드의 세 가지 계층

| 명칭     | 설명                                      | 예                     |
| ------ | --------------------------------------- | --------------------- |
| 도메인 특화 | 특정 응용 프로그램 도메인의 특정 부분과 강하게 결합된 언어들      | 아파치 카멜, DSLs, 웹 템플릿 등 |
| 동적     | 빠르고 생산적이며 유연하게 기능을 개발할 수 있는 언어들         | 클로저, 그루비, JRuby       |
| 안정적    | 핵심 기능을 위해 안정적이고, 잘 테스트돼 있으며 성능이 우수한 언어들 | 자바, 코틀린, 스칼라          |
### 8.2.1 왜 자바가 아닌 언어를 사용할까?
- 자바 속성의 부담
	- 재컴파일이 번거롭다
	- 정적 타입 지정은 유연성을 제한할 수 있다
	- 배포는 무거운 과정이다
	- 자바의 문법은 엄격하며, 도메인 특화(domain specific language, DSL)를 만드는 데 자연스럽지 않을 수 있다
- 자바의 엄격한 문법
	- 자바는 매우 엄격한 문법을 갖고 있다
		- 메서드의 매개변수 구문을 선택적으로 표시할 수 없어 필드 접근과 메서드 사이의 구분이 모호할 수 없다
		- 재정의 가능한 문법의 부재는 자바를 DSL로 만들 때 문제가 될 ㅜㅅ 있다
	- 자바의 다소 지루한 문법은 일부 개발자들에게는 불편할 수 있고, 특정 유형의 버그들을 숨길 수 있다
	- 자바가 점차적으로 함수형 프로그래밍을 지원하고 있지만, 일부 패턴 적용에서는 여전히 어려움이 있다
	- 다른 언어들은 자바에는 없는 동시성에 대한 대안을 제시한다(코틀린의 coroutine, 클로저의 에이전트 등)
- 떠오르는 언어
	- 코틀린
		- 정적 타입을 정의하는 명령형 객체지향 언어
		- 컴파일 언어이며, JVM에서 실행되는 기본 기능 이상의 높은 호환성을 갖고 있다
		- 간결한 문법, null safety, 자바 코드와의 높은 상호 운용성, 대안적인 동시성 메커니즘인 코루틴 등이 주요 기능
	- 클로저
		- 리스프 계열의 언어
		- 동적으로 타입을 정의하는 함수형 언어
### 8.2.3 그 밖의 언어
- 그루비
	- 자바와 매우 유사하지만 더 유연한 구문을 가진 동적 컴파일 언어
	- 스크립팅과 테스트에 널리 사용
	- gradle 빌드 도구에 처음 사용된 언어이고, jenkins를 구성하는 데 사용
- 스칼라
	- 함수형 프로그래밍의 여러 측면을 지원하는 객체지향 언어
	- 정적으로 타입을 정의하는 컴파일 언어
	- 많은 양의 타입 추론을 수행해 동적 언어 느낌을 주는 경우도 있다
- GraalVM
	- 부분적으로 자바와 JVM의 코드베이스에서 파생된 다중 언어 가상머신 및 플랫폼
	- 구성 요소
		- 자바 핫스폿 가상머신
		- Node.js 자바스크립트 런타임 환경
		- LLVM - 바이트코드를 실행하는 LLVM 런타임
		- Graal - 자바로 작성된 JIT 컴파일러
		- Truffle - 언어 인터프리터를 구축하기 위한 툴킷 및 API
		- SubstrateVM - 네이티브 이미지를 위한 경량 실행 컨테이너
- 비 JVM 언어
	- 머신 러닝 - 파이썬
	- 네이티브 시스템 코드 - C, go, Rust
	- 사용자의 웹브라우저에서 실행 - javascript
## 8.3 프로젝트에 비자바 언어를 선택하는 방법
- 도메인 특화, 동적, 안정적 레이어에 적합한 프로젝트 영역들

| 명칭     | 내용                                                                                | 도메인 문제의 예시                                         |
| ------ | --------------------------------------------------------------------------------- | -------------------------------------------------- |
| 도메인 특화 | 도메인 특화 영역은 자바를 모르는 전문가들이 읽기 쉽게 구성할 수 있다. 소프트웨어 생명 주기 도구에서도 종종 도메인 특화 언어와 설정이 사용된다 | 빌드, CI/CD<br>Devops<br>비지니스 규칙 모델링                 |
| 동적     | 시스템의 동적 계층은 다른 언어를 사용해서 더 큰 유연성과                                                  | 빠른 웹 개발<br>프로토타이핑<br>대화형 관리와 사용자 콘솔<br>스크립팅<br>테스팅 |
| 안정적    | 안정적 계층 코드는 시스템의 핵심 추상화를 나타낸다. 더 엄격한 타입 안전성과 테스팅은 추가적인 개발자 부담을 감당할 가치가 있다          | 동시성 코드<br>응용 프로그램 컨테이너<br>핵심 비지니스 기능               |
- 기술 스택 고려 기준
	- 프로젝트 영역이 저위험인가?
	- 이 언어가 자바와 어떻게 상호 운용되나?
	- 이 언어에 대한 어떤 도구 지원이 있나?
	- 이 언어의 학습 곡선은 얼마나 가파른가?
	- 이 언어에 대한 경험이 있는 개발자를 쉽게 고용할 수 있는가?

### 8.3.1 프로젝트 영역이 저위험 지역인가?
- 시스템은 핵심 처리 외에도 많은 부분으로 구성돼 있다
	- 테스트 개선이 필요하다면 코틀린이 어려 옵션들이 있다
	- 속성 테스트(property testing)는 생성된 입력값을 대상으로 조건을 검증하는 방식의 테스트로 클로저의 test.check 라이브러리가 가능하게 함
- 시스템의 중요하지 않은 정적 데이터를 운영 사용자가 관리할 수 있는 웹 콘솔
	- 새로운 언어 및 기술 스택을 시도하기에 위험이 낮은 영역
- **위험이 낮은 영역에서 제한된 파일럿에 집중함으로써 새로운 기술 스택이 적합하지 않은 경우에 프로젝트를 종료하고 큰 혼란 없이 다른 기술로 포팅할 수 있는 옵션은 항상 존재한다**

### 8.3.2 언어가 자바와 잘 상호 운용되는가?
- 대부분의 인기 있는 JVM 다른 언어는 모두 자바와의 상호 운용성이 우수하고, 일부 언어는 통합이 거의 완벽에 가까울 정도로 뛰어나다
	- 예시
		- 코틀린의 경우 import문을 사용해서 자바 패키지에서 직접 코드를 가져올 수 있다

### 8.3.3 해당 언어에 대한 도구와 테스트 지원이 제공되는가?
- 대부분의 개발자는 자신의 환경에 익숙해지면 절약할 수 있는 시간을 과소평가한다. 하지만 강력한 IDE와 빌드 및 테스트 도구는 고품질 소프트웨어를 빠르게 제작하는 데 도움이 된다

### 8.3.4 언어를 배우기가 얼마나 어려운가?
- 대부분의 자바 개발팀은 새로운 언어가 C와 유사한 구문을 사용하는 객체지향적 언어라면 쉽게 익힐 수 있다
- 자바 개발자가 이 패러다임에서 멀어질수록 배우기 점점 더 어려워진다
- 이에 대한 대안으론 기존 언어를 재구현한 JVM 언어를 살펴보는 것

### 8.3.5 이 언어를 사용하는 개발자가 많은가?
- 조직은 항상 상위 2% 사람만 채용할 수 없고, 개발 팀이 1년 동안 수시로 바뀔 수도 있다. 
## 8.4 JVM이 다른 언어를 지원하는 방법
- JVM에서 언어가 실행되는 두 가지 방법
	- 클래스 파일을 생성하는 소스 코드 컴파일러가 있는 경우로, 코틀린과 클로저는 모두 이러한 방식으로 작동한다
	- JVM 바이트코드로 구현된 인터프리터가 있는 경우로, JRuby는 이러한 방식으로 구현된다
- 비자바 언어 런타임 지원
![[Drawing 2024-10-31 15.41.19.excalidraw]]
### 8.4.1 성능
- 신뢰할 만한 데이터 없이 X 언어가 Y 언어보다 '더 빠르다'라는 주장에는 의심을 가져야한다
- 실제로 JVM 언어의 전반적인 성능 특성은 언어의 구현 방식에 따라 상당 부분 결정될 수 있다
	- 컴파일 언어는 바이트코드로만 존재하며 자바와 같은 방식으로 JIT 컴파일 된다
	- 인터프리트 언어는 프로그램 자체가 아닌 인터프리터가 JIT 컴파일되기 때문에 성능 면에서 매우 다르게 움직일 것이다

### 8.4.2 비자바 언어의 런타임 환경
- 런타임 환경의 복잡성 확인하기
	- 런타임 구현을 제공하는 JAR 파일의 크기 확인
		- 클로저는 비교적 가볍고, JRuby는 더 많은 자원이 필요
- 다른 언어는 기본적으로 프로그래밍 개념에 대해 자바와 항상 정확히 동일한 관점을 가지지 않는다
### 8.4.3 컴파일러 픽션
- 컴파일러 픽션(compiler fiction)
	- 기존 JVM구현에 존재하지 않고 특정 언어 기능은 프로그래밍 환경과 상위 수준 언어에 합성되는 것
	- 자바 예시
		- 확인된 예외(checked exception) 와 inner 클래스
			- 내부 클래스는 항상 필요에 따라 특별히 합성된 접근 메서드가 있는 최상위(==top-level==)로 변환된다
	- 자바 람다 표현식은 익명 타입 접근 방식을 사용하지 않고, JVM의 일반적인 기능인 invokedynamic을 활용해 구현

